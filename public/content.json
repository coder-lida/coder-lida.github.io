{"meta":{"title":"一觉睡到小时候","subtitle":"","description":"三级代码，一级Bug！","author":"少年闰土","url":"http://www.lida1024.top","root":"/"},"pages":[{"title":"关于","date":"2019-12-13T00:21:43.222Z","updated":"2019-12-13T00:21:43.222Z","comments":true,"path":"about/index.html","permalink":"http://www.lida1024.top/about/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-12-13T00:22:50.140Z","updated":"2019-12-13T00:22:50.140Z","comments":true,"path":"tags/index.html","permalink":"http://www.lida1024.top/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-12-13T00:22:27.336Z","updated":"2019-12-13T00:22:27.336Z","comments":true,"path":"categories/index.html","permalink":"http://www.lida1024.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-12-13T00:23:48.029Z","updated":"2019-12-13T00:23:48.029Z","comments":true,"path":"mylist/index.html","permalink":"http://www.lida1024.top/mylist/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-01-10T02:13:00.548Z","updated":"2020-01-10T02:13:00.548Z","comments":true,"path":"links/index.html","permalink":"http://www.lida1024.top/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Java中的clone","slug":"Java中的clone","date":"2020-01-12T23:56:00.000Z","updated":"2020-01-12T23:59:25.371Z","comments":true,"path":"2020/01/13/Java中的clone/","link":"","permalink":"http://www.lida1024.top/2020/01/13/Java%E4%B8%AD%E7%9A%84clone/","excerpt":"","text":"Java中对象的创建 使用new操作符创建一个对象 使用clone方法复制一个对象这两种方式有什么相同和不同呢？new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。而clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部 。Java中的Cloneclone 顾名思义就是 复制 ， 在Java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象复制对象 or 复制引用1234Person p &#x3D; new Person(23, &quot;张三&quot;); Person p1 &#x3D; p;System.out.println(p); System.out.println(p1); 打印结果：12com.pansoft.zhangjg.testclone.Person@2f9ee1accom.pansoft.zhangjg.testclone.Person@2f9ee1ac 可以看出，打印的地址值是相同的，既然地址都是相同的，那么肯定是同一个对象。p和p1只是引用而已，他们都指向了一个相同的对象Person(23, “张三”) 。 可以把这种现象叫做 引用的复制而下面的代码是真真正正的克隆了一个对象：1234Person p &#x3D; new Person(23, &quot;张三&quot;); Person p1 &#x3D; (Person) p.clone(); System.out.println(p); System.out.println(p1); 打印结果:12com.pansoft.zhangjg.testclone.Person@2f9ee1accom.pansoft.zhangjg.testclone.Person@67f1fba0 深拷贝 or 浅拷贝上面的示例代码中，Person中有两个成员变量，分别是name和age， name是String类型， age是int类型。代码非常简单，如下所示：12345678910111213141516171819public class Person implements Cloneable&#123; private int age ; private String name; public Person(int age, String name) &#123; this.age &#x3D; age; this.name &#x3D; name; &#125; public Person() &#123;&#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override protected Object clone() throws CloneNotSupportedException&#123; return (Person)super.clone(); &#125;&#125; 由于age是基本数据类型， 那么对它的拷贝没有什么疑议，直接将一个4字节的整数值拷贝过来就行。但是name是String类型的， 它只是一个引用， 指向一个真正的String对象，那么对它的拷贝有两种方式： ①直接将源对象中的name的引用值拷贝给新对象的name字段； ②根据原Person对象中的name指向的字符串对象创建一个新的相同的字符串对象，将这个新字符串对象的引用赋给新拷贝的Person对象的name字段。 这两种拷贝方式分别叫做 浅拷贝 和 深拷贝 。 深拷贝和浅拷贝的原理如下图所示： clone是浅拷贝还是深拷贝如果两个Person对象的name的地址值相同， 说明两个对象的name都指向同一个String对象， 也就是浅拷贝， 而如果两个对象的name的地址值不同， 那么就说明指向不同的String对象， 也就是在拷贝Person对象的时候， 同时拷贝了name引用的String对象， 也就是深拷贝。验证代码如下： 1234Person p &#x3D; new Person(23,&quot;张三&quot;);Person p1 &#x3D;(Person)p.clone();String result &#x3D; p.getName() &#x3D;&#x3D; p1.getName() ? &quot;clone是浅拷贝的&quot;:&quot;clone是深拷贝的&quot;; 打印结果: 1clone是浅拷贝的","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/tags/Java/"}]},{"title":"微信小程序版本自动更新","slug":"微信小程序版本自动更新","date":"2020-01-07T09:24:00.000Z","updated":"2020-01-09T09:53:15.236Z","comments":true,"path":"2020/01/07/微信小程序版本自动更新/","link":"","permalink":"http://www.lida1024.top/2020/01/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%89%88%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/","excerpt":"","text":"公司的小程序项目上线, 后期还会有小型的版本迭代. 为了让用户能在我们进行版本迭代后及时使用最新版本的功能. 做了以下优化.. 小程序的销毁当用户点击左上角关闭，或者按了设备Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台，只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。 “冷启动” 和 “热启动”.热启动是指: 小程序打开后，在一段时间内（目前：5分钟）再次被打开，此时会将后台的小程序切换到前台。冷启动是指: 小程序首次打开或销毁后再次被打开. 更新版本冷启动时, 如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。如果要马上应用最新版本，使用 wx.getUpdateManager API 进行处理。 代码如下 12345678910111213141516171819202122232425262728293031323334&#x2F; 在app.js里写下以下代码 onLaunch () &#123; if (wx.canIUse(&#39;getUpdateManager&#39;)) &#123; const updateManager &#x3D; wx.getUpdateManager() updateManager.onCheckForUpdate(function (res) &#123; console.log(&#39;onCheckForUpdate&#x3D;&#x3D;&#x3D;&#x3D;&#39;, res) &#x2F;&#x2F; 请求完新版本信息的回调 if (res.hasUpdate) &#123; console.log(&#39;res.hasUpdate&#x3D;&#x3D;&#x3D;&#x3D;&#39;) updateManager.onUpdateReady(function () &#123; wx.showModal(&#123; title: &#39;更新提示&#39;, content: &#39;新版本已经准备好，是否重启应用？&#39;, success: function (res) &#123; console.log(&#39;success&#x3D;&#x3D;&#x3D;&#x3D;&#39;, res) &#x2F;&#x2F; res: &#123;errMsg: &quot;showModal: ok&quot;, cancel: false, confirm: true&#125; if (res.confirm) &#123; &#x2F;&#x2F; 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123; &#x2F;&#x2F; 新的版本下载失败 wx.showModal(&#123; title: &#39;已经有新版本了哟~&#39;, content: &#39;新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~&#39; &#125;) &#125;) &#125; &#125;) &#125; &#125; 小程序重新初始化时会触发onLaunch事件onLaunch事件会触发在页面onShow事件之前.获取小程序更新版本可以写在onLaunch里. 注意：在开发和体验版无法测试版本更新 需要在开发者工具里,编译时选择”模拟更新编译” (部分开发者工具版本, 每次update编译时都需要重新勾选此选项)点击确定,重新编译.页面会弹窗显示:点击确定后： 随着小程序的不断更新, 部分功能可能需要最新版的微信客户端才能使用. 这时候可以弹窗提示用户更新到最新版本微信 12345678 if (wx.canIUse(&#39;getUpdateManager&#39;)) &#123; ...&#125; else &#123; &#x2F;&#x2F; can&#39;t use getUpdateManager wx.showModal(&#123; title: &#39;提示&#39;, content: &#39;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&#39; &#125;) 完整版本: 12345678910111213141516171819202122232425262728293031onLaunch () &#123; if (wx.canIUse(&#39;getUpdateManager&#39;)) &#123; const updateManager &#x3D; wx.getUpdateManager() updateManager.onCheckForUpdate(function (res) &#123; if (res.hasUpdate) &#123; updateManager.onUpdateReady(function () &#123; wx.showModal(&#123; title: &#39;更新提示&#39;, content: &#39;新版本已经准备好，是否重启应用？&#39;, success: function (res) &#123; if (res.confirm) &#123; updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123; wx.showModal(&#123; title: &#39;已经有新版本了哟~&#39;, content: &#39;新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~&#39; &#125;) &#125;) &#125; &#125;) &#125; else &#123; wx.showModal(&#123; title: &#39;提示&#39;, content: &#39;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&#39; &#125;) &#125; &#125; 如果在onLaunch里进行请求, 这是异步请求. 如果对交互顺序有要求, 如: 版本更新–重新获取数据– 用户展示, 那么需要考虑在callback里进行重获数据.小程序启动时，正常是会热更新，下载新版本的包，下一次启动就会使用新包。但发现有更新不成功的情况发生.官方回答: 策略生效跟网络环境以及发布时间等若干因素有关，会尽可能让小程序快地更新，但无法保证每次都热更新成功。小程序的异步更新发生在冷启动过程. 官方不建议热更新. 原因:","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.lida1024.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Double为什么会失真？","slug":"Double为什么会失真？","date":"2020-01-07T05:43:00.000Z","updated":"2020-01-07T06:06:36.911Z","comments":true,"path":"2020/01/07/Double为什么会失真？/","link":"","permalink":"http://www.lida1024.top/2020/01/07/Double%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%A4%B1%E7%9C%9F%EF%BC%9F/","excerpt":"","text":"前言先来看一个double失真的例子 12345678910public class DoubleTest &#123; public static void main(String[] args) &#123; for (double i &#x3D; 0; i &lt; 1; i &#x3D; (i * 10 + 1) &#x2F; 10) &#123; for (double k &#x3D; 0; k &lt; i; k &#x3D; (k * 10 + 1) &#x2F; 10) &#123; System.out.println(i + &quot;-&quot; + k + &quot;&#x3D;&quot; + (i - k)); &#125; &#125; &#125;&#125; 输出： 0.1-0.0=0.10.2-0.0=0.20.2-0.1=0.10.3-0.0=0.30.3-0.1=0.199999999999999980.3-0.2=0.099999999999999980.4-0.0=0.40.4-0.1=0.300000000000000040.4-0.2=0.20.4-0.3=0.100000000000000030.5-0.0=0.50.5-0.1=0.40.5-0.2=0.30.5-0.3=0.20.5-0.4=0.099999999999999980.6-0.0=0.60.6-0.1=0.50.6-0.2=0.399999999999999970.6-0.3=0.30.6-0.4=0.199999999999999960.6-0.5=0.099999999999999980.7-0.0=0.70.7-0.1=0.60.7-0.2=0.499999999999999940.7-0.3=0.399999999999999970.7-0.4=0.299999999999999930.7-0.5=0.199999999999999960.7-0.6=0.099999999999999980.8-0.0=0.80.8-0.1=0.70000000000000010.8-0.2=0.60000000000000010.8-0.3=0.50.8-0.4=0.40.8-0.5=0.300000000000000040.8-0.6=0.200000000000000070.8-0.7=0.100000000000000090.9-0.0=0.90.9-0.1=0.80.9-0.2=0.70.9-0.3=0.60000000000000010.9-0.4=0.50.9-0.5=0.40.9-0.6=0.300000000000000040.9-0.7=0.200000000000000070.9-0.8=0.09999999999999998 一、 什么是浮点数？1、小数一个小数的组成：在我国，小数表示由三部分组成，分别是整数+小数点（分隔符）+小数。 2、小数为什么会被称为浮点数浮点数是属于有理数中某特定子集的数的数字表示，在计算机中用以近似表示任意某个实数。具体的说，这个实数由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到，这种表示方法类似于基数为10的科学计数法。 对于浮点数可以这样简单的理解：浮点数就是小数点可以任意浮动的数字。 在计算机的机器语言中，只有二进制，机器语言只能识别0和1。所以，计算机也是不可能存储小数的，所以需要有另一种变通的存储方案。这种方案就是指数方案：通过观察以上的图片不难发现，作为一个小数3.14。如果使用指数表现形式的话（3.14E0），其写法是多种多样的，这样写的话，小数点就可以任意浮动了。 3、Java中浮点数的表示方法对于float来说，4个字节，32位，0-22位表示尾数，23-30(8位)表示指数，31位表示符号位。 对于double来说，8个字节，64位，0-51表示尾数，52-62(11位)表示指数，63位最高位表示符号位。 二、浮点数在内存中是如何存储的？我们知道，任何数据在计算机内存中都是用‘0\\1’来存储的，浮点数亦是如此。因此十进制浮点数在存储时必定会转换为二进制的浮点数。 在内存中使用二进制的科学计数法来存储，因此分为阶码（即指数）和底数，由于也有正负之分，所以还有一位符号位。以float为例，float在内存中的存储为：float 符号位(1bit) 指数(8 bit) 尾数(23 bit) double 符号位(1bit) 指数(11 bit) 尾数(52 bit) float在内存中占8位，由于阶码实际存储的是指数的移码，假设指数的真值是e,阶码为E，则有E=e+(2^n-1 -1)。其中 2^n-1 -1是IEEE754标准规定的指数偏移量，根据这个公式我们可以得到 2^8 -1=127。于是，float的指数范围为-128 +127，而double的指数范围为-1024 +1023。其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。 float的范围为-2^128 ~ +2^127，也即-3.40E+38 ~ +3.40E+38； double的范围为-2^1024 ~ +2^1023，也即-1.79E+308 ~ +1.79E+308 这里使用移位存储，对于float来说，指数位加上127，double位加上1023(这里指的是存储，在比较的时候要分别减去127和1023) 移位存储本质上是为了保证+0和-0的一致性。 以float指数部分的这8位来分析， 那么这8位组成的新的字节，我们来用下面的一串数字表示：0000 0000 首先，我们假设不使用移位存储技术，而是单单看看这个 8位组成的新字节，到底能表示多少个数： 0000 0000 -1111 1111 即0-255，一共256个数。 但是我们知道这8位数既要表示正数也要表示负数。 所以将左边第一位拿出来表示正负的符号： 第一个区间： 0 000 0000 - 0 111 1111即+0 到127 第二个区间： 1 000 0000 - 1 111 1111即 -0到-127 这就是问题的所在:怎么会有两个0，一个正零，一个负零。 这时候使用移位存储：float使用127(0111 1111) 表示0：0+127=127 即 0000 0000 +0111 1111=0111 1111表示1：1+127=128 即 0000 0001 +0111 1111=1000 0000表示128：128+127=255 即 1000 0000+0111 1111=1111 1111 最大的正数，再大就要溢出了。 表示-1： -1+127=126=127-1 即 0111 1111-0000 0001=0111 1110表示-1： -2+127=125=127-2 即 0111 1111-0000 0010=0111 1101表示-127： -127+127=0 即0111 1111-0111 1111=0000 0000 最小的负数，在校就溢出了。 三、浮点数的进制转换1、十进制转二进制主要看看十进制转二进制，整数部分和小数部分分开处理 整数部分：整数除以2，得到一个商和余数，得到的商继续除以2并得到一个商和一个余数，继续除以2操作直至商为0，上述操作得到一系列余数，从最后一个余数开始直至第一个余数，这一系列0\\1即为转换后的二进制数。 小数部分：乘以2，然后取出整数部分，将剩下的小数部分继续乘以2，然后再取整数部分，一直取到小数部分为零为止。如果永远不为零，则按要求保留足够位数的小数，最后一位做0舍1入。将取出的整数顺序排列。 从以上转换过程可以看出，并不是任何一个十进制小数都可以用二进制精确表示出来。一个在0到1之间的小数P可用如下形式表示：从这个式子中我们也可看出二进制表示出的小数是分段的，这也是为什么在Java中浮点数很多时候并不是十分精确的表示十进制小数的根本原因。 12345678910111213public static void main(String[] args) &#123; float f1&#x3D;20f; float f2&#x3D;20.3f; float f3&#x3D;20.5f; double d1&#x3D;20; double d2&#x3D;20.3; double d3&#x3D;20.5; System.out.println(f1&#x3D;&#x3D;d1); System.out.println(f2&#x3D;&#x3D;d2); System.out.println(f3&#x3D;&#x3D;d3);&#125; truefalsetrue 以20.3举例：20转换后变为 101000.3 要转换二进制，需要乘2, 乘完之后 取整数部分，然后用乘的结果减去整数部分， 然后 接着乘2, 直至最后没有小数或者小数出现循环, 即乘完. 0.3 * 2 = 0.6 (0) 0.6 * 2 = 1.2 (1) 0.2 * 2 = 0.4 (0) 0.4 * 2 = 0.8 (0) 0.8 * 2 = 1.6 (1) 计算到这里， 将再出现0.6,进入循环了，所以，结果0.3 = 0.010011001…1001所以20.3 = 10100.010011001…1001 (二进制). 2、二进制的科学记数法表示20.3 = 10100.010011001…1001 (二进制)=1.01000100110011E10…..（十进制科学计数）=1.01000100110011E100…..(二进制科学计数) 这里使用移位存储，对于float来说，指数位加上127，double位加上1023(这里指的是存储，在比较的时候要分别减去127和1023) 同时要注意一点，以float为例，最高位表示的是整个数的符号位，指数位一共8位，最高位表示的是指数位的正负，因为有可能是E-100这样的情况，所以虽然有8位，最高位只是符号位，剩下7位才是表示真正的数值，这也是使用移位存储的原因。 对于一个数字，只要不超过和float的范围，同时小数部分不是无限小数，就可以和对应的double类型相等。 3、浮点数舍入规则以52位尾数的双精度浮点数为例，舍入时需要重点参考第53位。 若第53位为1，而其后的位数都是0，此时就要使第52位为0；若第52位为0则不用再进行其他操作，若第52位为1，则第53位就要向52位进一位。 若第53位为1，但其后的位数不全为0，则第53为就要向第52位进一位。 若不是以上两种情况，也即53位为0，那么就直接舍弃不进位，称为下舍入。 浮点数舍入规则也就证明了为何在上文中提到的浮点数舍入中，相对舍入误差不能大于机器ε的一半。 对于java来说，一般float类型小数点后保留7位，而double类型小数点后保留15位。 这个原因也是因为尾数的数据宽度限制 对于float型来说，因为2^23 = 8388608 同时最左一位默认省略了，故实际能表示2^24 = 16777216个数，最多能表示8位，但绝对精确的只能表示7位。 而对于double型来说，2^52 = 4503599627370496，共16位。加上省略的一位，能表示2^53 = 9007199254740992。故double型最多能表示16位，而绝对精确的只能表示15位。 4、机器ε机器ε表示1与大于1的最小浮点数之差。不同精度定义的机器ε不同。以双精度为例， 双精度表示1是 1.000……0000（52个0） × 2^0 而比1大的最小的双精度是（其实还能表示更小的范围，后文中会提到，但并不影响这里的机器ε） 1.000……0001 × 2^0 也即 2^-52 ≈ 2.220446049250313e-16。所以它就是双精度浮点数的机器ε。 在舍入中，相对舍入误差不能大于机器ε的一半。 对于双精度浮点数来说，这个值为0.00000005960464477539。 所以在Java中double类型中连续8个0.1相乘，就会出现表示不精确的情况。 参考：https://baijiahao.baidu.com/s?id=1618173300159774003&amp;wfr=spider&amp;for=pchttps://www.cnblogs.com/Vicebery/p/9997636.htmlhttps://blog.csdn.net/Return_head/article/details/88623060https://blog.csdn.net/u011277123/article/details/95774544https://blog.csdn.net/endlessseaofcrow/article/details/81269079","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"数据类型","slug":"数据类型","permalink":"http://www.lida1024.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"Java反射","slug":"Java反射","date":"2020-01-05T23:57:00.000Z","updated":"2020-01-06T00:11:40.137Z","comments":true,"path":"2020/01/06/Java反射/","link":"","permalink":"http://www.lida1024.top/2020/01/06/Java%E5%8F%8D%E5%B0%84/","excerpt":"","text":"一、什么是反射？JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 简单的来说：1.通过new关键字创建对象操作对象，在编译时就已经确定。2.通过反射可以在程序运行过程中动态的操作对象，可以获得编译期无法获得的信息，动态操作最大限度发挥了java扩展性。 二、反射原理Java反射的原理:java类的执行需要经历以下过程： 编译：.java文件编译后生成.class字节码文件 加载：类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例 链接验证：格式（class文件规范） 语义（final类是否有子类） 操作准备：静态变量赋初值和内存空间，final修饰的内存空间直接赋原值，此处不是用户指定的初值。解析：符号引用转化为直接引用，分配地址 初始化：有父类先初始化父类，然后初始化自己；将static修饰代码执行一遍，如果是静态变量，则用用户指定值覆盖原有初值；如果是代码块，则执行一遍操作。 Java的反射就是利用上面第二步加载到jvm中的.class文件来进行操作的。.class文件中包含java类的所有信息，当你不知道某个类具体信息时，可以使用反射获取class，然后进行各种操作。 Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。总结说：反射就是把java类中的各种成分映射成一个个的Java对象，并且可以进行操作。 三、反射机制相关与Java反射相关的类如下： 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 反射可访问的常用信息 类型 访问方法 返回值类型 说明 包路径 getPackage() Package 对象 获取该类的存放路径 类名称 getName() String 对象 获取该类的名称 继承类 getSuperclass() Class 对象 获取该类继承的类 实现接口 getlnterfaces() Class 型数组 获取该类实现的所有接口 构造方法 getConstructors() Constructor 型数组 获取所有权限为 public 的构造方法 构造方法 getDeclaredContruectors() Constructor 对象 获取当前对象的所有构造方法 方法 getMethods() Methods 型数组 获取所有权限为 public 的方法 方法 getDeclaredMethods() Methods 对象 获取当前对象的所有方法 成员变量 getFields() Field 型数组 获取所有权限为 public 的成员变量 成员变量 getDeclareFileds() Field 对象 获取当前对象的所有成员变量 内部类 getClasses() Class 型数组 获取所有权限为 public 的内部类 内部类 getDeclaredClasses() Class 型数组 获取所有内部类 内部类的声明类 getDeclaringClass() Class 对象 如果该类为内部类，则返回它的成员类，否则返回 null Java 反射机制主要提供了以下功能，这些功能都位于java.lang.reflect包。 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 生成动态代理。 四、反射的使用1、java中的Class三种获取方式 jdk提供了三种方式获取一个对象的Class，就Person person 来说 1.person .getClass()，这个是Object类里面的方法 2.Person .Class属性，任何的数据类型，基本数据类型或者抽象数据类型，都可以通过这种方式获取类 3.Class.forName(“”)，Class类提供了这样一个方法，让我们通过类名来获取到对象类 说明：在运行期间，如果我们要产生某个类的对象，Java虚拟机(JVM)会检查该类型的Class对象是否已被加载。如果没有被加载，JVM会根据类的名称找到.class文件并加载它。一旦某个类型的Class对象已被加载到内存，就可以用它来产生该类型的所有对象。 12345678910111213&#x2F;&#x2F;方式一Person person &#x3D; new Person();Class&lt;? extends Person&gt; personClazz01 &#x3D; person.getClass(); &#x2F;&#x2F;方式二try &#123; Class&lt;?&gt; personClazz02 &#x3D; Class.forName(&quot;Person&quot;);&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; &#x2F;&#x2F;方式三Class&lt;? extends Person&gt; personClazz03 &#x3D; Person.class; 2、如何通过反射获取私有成员变量和私有方法Person类 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Person &#123;private String name &#x3D; &quot;zhangsan&quot;;private String age; public String getName() &#123; return name;&#125; public void setName(String name) &#123; this.name &#x3D; name;&#125;&#125; Person person &#x3D; new Person(); &#x2F;&#x2F;打印没有改变属性之前的name值 System.out.println(&quot;before：&quot; + getPrivateValue(person, &quot;name&quot;)); person.setName(&quot;lisi&quot;); &#x2F;&#x2F;打印修改之后的name值 System.out.println(&quot;after：&quot; + getPrivateValue(person, &quot;name&quot;)); &#x2F;** * 通过反射获取私有的成员变量 * * @param person * @return *&#x2F;private Object getPrivateValue(Person person, String fieldName) &#123; try &#123; Field field &#x3D; person.getClass().getDeclaredField(fieldName); &#x2F;&#x2F; 参数值为true，打开禁用访问控制检查 &#x2F;&#x2F;setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。 &#x2F;&#x2F;所以即使是public方法，其accessible 属相默认也是false field.setAccessible(true); return field.get(person); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 运行结果 3、demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307package cn.lee.demo; import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.TypeVariable; public class Main &#123; &#x2F;** * 为了看清楚Java反射部分代码，所有异常我都最后抛出来给虚拟机处理！ * @param args * @throws ClassNotFoundException * @throws InstantiationException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IllegalArgumentException * @throws NoSuchFieldException * @throws SecurityException * @throws NoSuchMethodException *&#x2F; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, SecurityException, NoSuchFieldException, NoSuchMethodException &#123; &#x2F;&#x2F; TODO Auto-generated method stub &#x2F;&#x2F;Demo1. 通过Java反射机制得到类的包名和类名 Demo1(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo2. 验证所有的类都是Class类的实例对象 Demo2(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo3. 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]，无参构造 Demo3(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo4: 通过Java反射机制得到一个类的构造函数，并实现构造带参实例对象 Demo4(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo5: 通过Java反射机制操作成员变量, set 和 get Demo5(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等 Demo6(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo7: 通过Java反射机制调用类中方法 Demo7(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo8: 通过Java反射机制获得类加载器 Demo8(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125; &#x2F;** * Demo1: 通过Java反射机制得到类的包名和类名 *&#x2F; public static void Demo1() &#123; Person person &#x3D; new Person(); System.out.println(&quot;Demo1: 包名: &quot; + person.getClass().getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + person.getClass().getName()); &#125; &#x2F;** * Demo2: 验证所有的类都是Class类的实例对象 * @throws ClassNotFoundException *&#x2F; public static void Demo2() throws ClassNotFoundException &#123; &#x2F;&#x2F;定义两个类型都未知的Class , 设置初值为null, 看看如何给它们赋值成Person类 Class&lt;?&gt; class1 &#x3D; null; Class&lt;?&gt; class2 &#x3D; null; &#x2F;&#x2F;写法1, 可能抛出 ClassNotFoundException [多用这个写法] class1 &#x3D; Class.forName(&quot;cn.lee.demo.Person&quot;); System.out.println(&quot;Demo2:(写法1) 包名: &quot; + class1.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + class1.getName()); &#x2F;&#x2F;写法2 class2 &#x3D; Person.class; System.out.println(&quot;Demo2:(写法2) 包名: &quot; + class2.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + class2.getName()); &#125; &#x2F;** * Demo3: 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在] * @throws ClassNotFoundException * @throws IllegalAccessException * @throws InstantiationException *&#x2F; public static void Demo3() throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.Person&quot;); &#x2F;&#x2F;由于这里不能带参数，所以你要实例化的这个类Person，一定要有无参构造函数哈～ Person person &#x3D; (Person) class1.newInstance(); person.setAge(20); person.setName(&quot;LeeFeng&quot;); System.out.println(&quot;Demo3: &quot; + person.getName() + &quot; : &quot; + person.getAge()); &#125; &#x2F;** * Demo4: 通过Java反射机制得到一个类的构造函数，并实现创建带参实例对象 * @throws ClassNotFoundException * @throws InvocationTargetException * @throws IllegalAccessException * @throws InstantiationException * @throws IllegalArgumentException *&#x2F; public static void Demo4() throws ClassNotFoundException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; Class&lt;?&gt; class1 &#x3D; null; Person person1 &#x3D; null; Person person2 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.Person&quot;); &#x2F;&#x2F;得到一系列构造函数集合 Constructor&lt;?&gt;[] constructors &#x3D; class1.getConstructors(); person1 &#x3D; (Person) constructors[0].newInstance(); person1.setAge(30); person1.setName(&quot;leeFeng&quot;); person2 &#x3D; (Person) constructors[1].newInstance(20,&quot;leeFeng&quot;); System.out.println(&quot;Demo4: &quot; + person1.getName() + &quot; : &quot; + person1.getAge() + &quot; , &quot; + person2.getName() + &quot; : &quot; + person2.getAge() ); &#125; &#x2F;** * Demo5: 通过Java反射机制操作成员变量, set 和 get * * @throws IllegalAccessException * @throws IllegalArgumentException * @throws NoSuchFieldException * @throws SecurityException * @throws InstantiationException * @throws ClassNotFoundException *&#x2F; public static void Demo5() throws IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException, InstantiationException, ClassNotFoundException &#123; Class&lt;?&gt; class1 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.Person&quot;); Object obj &#x3D; class1.newInstance(); Field personNameField &#x3D; class1.getDeclaredField(&quot;name&quot;); personNameField.setAccessible(true); personNameField.set(obj, &quot;胖虎先森&quot;); System.out.println(&quot;Demo5: 修改属性之后得到属性变量的值：&quot; + personNameField.get(obj)); &#125; &#x2F;** * Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等 * @throws ClassNotFoundException *&#x2F; public static void Demo6() throws ClassNotFoundException &#123; Class&lt;?&gt; class1 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.SuperMan&quot;); &#x2F;&#x2F;取得父类名称 Class&lt;?&gt; superClass &#x3D; class1.getSuperclass(); System.out.println(&quot;Demo6: SuperMan类的父类名: &quot; + superClass.getName()); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); Field[] fields &#x3D; class1.getDeclaredFields(); for (int i &#x3D; 0; i &lt; fields.length; i++) &#123; System.out.println(&quot;类中的成员: &quot; + fields[i]); &#125; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;取得类方法 Method[] methods &#x3D; class1.getDeclaredMethods(); for (int i &#x3D; 0; i &lt; methods.length; i++) &#123; System.out.println(&quot;Demo6,取得SuperMan类的方法：&quot;); System.out.println(&quot;函数名：&quot; + methods[i].getName()); System.out.println(&quot;函数返回类型：&quot; + methods[i].getReturnType()); System.out.println(&quot;函数访问修饰符：&quot; + Modifier.toString(methods[i].getModifiers())); System.out.println(&quot;函数代码写法： &quot; + methods[i]); &#125; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;取得类实现的接口,因为接口类也属于Class,所以得到接口中的方法也是一样的方法得到哈 Class&lt;?&gt; interfaces[] &#x3D; class1.getInterfaces(); for (int i &#x3D; 0; i &lt; interfaces.length; i++) &#123; System.out.println(&quot;实现的接口类名: &quot; + interfaces[i].getName() ); &#125; &#125; &#x2F;** * Demo7: 通过Java反射机制调用类方法 * @throws ClassNotFoundException * @throws NoSuchMethodException * @throws SecurityException * @throws InvocationTargetException * @throws IllegalAccessException * @throws IllegalArgumentException * @throws InstantiationException *&#x2F; public static void Demo7() throws ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Class&lt;?&gt; class1 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.SuperMan&quot;); System.out.println(&quot;Demo7: \\n调用无参方法fly()：&quot;); Method method &#x3D; class1.getMethod(&quot;fly&quot;); method.invoke(class1.newInstance()); System.out.println(&quot;调用有参方法walk(int m)：&quot;); method &#x3D; class1.getMethod(&quot;walk&quot;,int.class); method.invoke(class1.newInstance(),100); &#125; &#x2F;** * Demo8: 通过Java反射机制得到类加载器信息 * * 在java中有三种类类加载器。[这段资料网上截取] 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\\lib\\ext目录中的类 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。 * * @throws ClassNotFoundException *&#x2F; public static void Demo8() throws ClassNotFoundException &#123; Class&lt;?&gt; class1 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.SuperMan&quot;); String nameString &#x3D; class1.getClassLoader().getClass().getName(); System.out.println(&quot;Demo8: 类加载器类名: &quot; + nameString); &#125; &#125;&#x2F;** * * @author xiaoyaomeng * *&#x2F;class Person&#123; private int age; private String name; public Person()&#123; &#125; public Person(int age, String name)&#123; this.age &#x3D; age; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125;&#125; class SuperMan extends Person implements ActionInterface&#123; private boolean BlueBriefs; public void fly() &#123; System.out.println(&quot;超人会飞耶～～&quot;); &#125; public boolean isBlueBriefs() &#123; return BlueBriefs; &#125; public void setBlueBriefs(boolean blueBriefs) &#123; BlueBriefs &#x3D; blueBriefs; &#125; @Override public void walk(int m) &#123; &#x2F;&#x2F; TODO Auto-generated method stub System.out.println(&quot;超人会走耶～～走了&quot; + m + &quot;米就走不动了！&quot;); &#125;&#125;interface ActionInterface&#123; public void walk(int m);&#125; 五、java反射调用service或mapper中的接口java中的反射需要一个实例，但是接口无法提供这样的实例，但是JDK提供了一个叫做动态代理的东西，这个代理恰恰只能代理接口。所以我们想要反射接口需要使用这个动态代理来做。 在java的动态代理机制中，有两个重要的东西，一个是 InvocationHandler(接口)、另一个则是 Proxy(类)，这是我们动态代理必须用到的两个东西。 1、静态代理先来看一下静态代理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestStaticProxy &#123; &#x2F;&#x2F;这里传入的是接口类型的对象，方便向上转型，实现多态 public static void consumer(ProxyInterface pi)&#123; pi.say(); &#125; public static void main(String[] args) &#123; &#x2F;&#x2F; TODO Auto-generated method stub consumer(new ProxyObject()); &#125;&#125;&#x2F;&#x2F;代理接口interface ProxyInterface&#123; public void say();&#125;&#x2F;&#x2F;被代理者class RealObject implements ProxyInterface&#123; &#x2F;&#x2F;实现接口方法 @Override public void say() &#123; &#x2F;&#x2F; TODO Auto-generated method stub System.out.println(&quot;say&quot;); &#125; &#125;&#x2F;&#x2F;代理者class ProxyObject implements ProxyInterface&#123; @Override public void say() &#123; &#x2F;&#x2F; TODO Auto-generated method stub &#x2F;&#x2F;dosomething for example System.out.println(&quot;hello proxy&quot;); new RealObject().say(); System.out.println(&quot;this is method end&quot;); &#125; &#125;output:hello proxysaythis is method end 2、动态代理123456789101112131415161718192021222324252627282930313233343536373839import java.lang.reflect.*;public class TestActiveProxy&#123; static void customer(ProxyInterface pi)&#123; pi.say(); &#125; public static void main(String[] args)&#123; RealObject real &#x3D; new RealObject(); ProxyInterface proxy &#x3D; (ProxyInterface)Proxy.newProxyInstance(ProxyInterface.class.getClassLoader(),new Class[]&#123;ProxyInterface.class&#125;, new ProxyObject(real)); customer(proxy); &#125;&#125;interface ProxyInterface&#123; void say();&#125;&#x2F;&#x2F;被代理类class RealObject implements ProxyInterface&#123; public void say()&#123; System.out.println(&quot;i&#39;m talking&quot;); &#125;&#125;&#x2F;&#x2F;代理类，实现InvocationHandler 接口class ProxyObject implements InvocationHandler&#123; private Object proxied &#x3D; null; public ProxyObject()&#123; &#125; public ProxyObject(Object proxied)&#123; this.proxied &#x3D; proxied; &#125; public Object invoke(Object arg0, Method arg1, Object[] arg2) throws Throwable &#123; System.out.println(&quot;hello&quot;); return arg1.invoke(proxied, arg2); &#125;;&#125; 3、应用场景假如现在我们需要通过反射得到TestMapper接口，然后调用其中的一个selectById方法 123456public interface TestMapper&#123; &#x2F;** * 根据id查对象 *&#x2F; User selectById(@Param(&quot;id&quot;) Integer id);&#125; 现在如果我们需要反射使用该接口根据用户ID获取用户对象是无法直接反射调取的，所以我们需要一个动态代理类。创建一个MyInvocationHandler实现InvocationHandler接口 12345678910111213public class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target) &#123; this.target &#x3D; target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(target,args); &#125;&#125; 去生成代理对象并调用方法 1234567891011121314 SqlSession sqlSession &#x3D; this.sqlSessionFactory.openSession(); Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.example.demo.mapper.TestMapper&quot;); Object instance &#x3D; Proxy.newProxyInstance( clazz.getClassLoader(), new Class[]&#123;clazz&#125;, new MyInvocationHandler(sqlSession.getMapper(clazz)) );&#x2F;&#x2F;这里我是通过sqlSession来获取Mapper的 Method method &#x3D; instance.getClass().getMethod(&quot;selectById&quot;,Integer.class); method.invoke(instance, 1);&#x2F;&#x2F;object为mapper中传入的参数 这里需要注意，newProxyInstance()方法中最后一个参数，即为我们创建的动态代理的类（因为我这里调用的接口为mybatis中mapper中的接口，所以需要从sqlSession中getMapper）。 参考：http://blog.qiji.tech/archives/4374https://www.jianshu.com/p/9be58ee20deehttps://blog.csdn.net/ljphhj/article/details/12858767https://developer.android.google.cn/reference/java/lang/reflect/Method?hl=zh-cn","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"反射","slug":"反射","permalink":"http://www.lida1024.top/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"zipkin","slug":"zipkin","date":"2020-01-01T03:39:00.000Z","updated":"2020-01-01T05:42:58.440Z","comments":true,"path":"2020/01/01/zipkin/","link":"","permalink":"http://www.lida1024.top/2020/01/01/zipkin/","excerpt":"","text":"Waht is zipkin?Zipkin是一种分布式跟踪系统。它有助于收集解决微服务架构中的延迟问题所需的时序数据。它管理这些数据的收集和查找。Zipkin的设计基于Google Dapper论文。 应用程序用于向Zipkin报告时序数据。Zipkin UI还提供了一个依赖关系图，显示了每个应用程序通过的跟踪请求数。如果要解决延迟问题或错误，可以根据应用程序，跟踪长度，注释或时间戳对所有跟踪进行筛选或排序。选择跟踪后，您可以看到每个跨度所需的总跟踪时间百分比，从而可以识别问题应用程序。 快速开始下面我们将逐步构建并启动Zipkin实例，以便在本地检查Zipkin。有三个选项：使用Java，Docker或从源代码运行。 如果您熟悉Docker，这是首选的方法。如果您不熟悉Docker，请尝试通过Java或源代码运行。 无论您如何启动Zipkin，请浏览http：// your_host：9411以查找跟踪！ DockerDocker zipkin工程可以创建docker 镜像, 提供脚本和一个docker-compose.yml 用于启动预建的镜像。最快的开始是直接运行最新的镜像： 1docker run -d -p 9411:9411 openzipkin&#x2F;zipkin Java如果安装了Java 8或更高版本，最快的方法是获得最新版本后，通过java启动 123&gt;curl -sSL https:&#x2F;&#x2F;zipkin.io&#x2F;quickstart.sh | bash -s&gt;java -jar zipkin.jar Running from Source（源代码运行）Zipkin可以从源代码运行。要实现这一点，您需要获得zipkin源码 get the latest source git clone https://github.com/openzipkin/zipkin cd zipkin Build the server and also make its dependencies ./mvnw -DskipTests –also-make -pl zipkin-server clean install Run the server java -jar ./zipkin-server/target/zipkin-server-*exec.jar","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"解决Tomcat8上传文件无可读权限问题","slug":"解决Tomcat8上传文件无可读权限问题","date":"2020-01-01T03:34:00.000Z","updated":"2020-01-01T03:37:36.280Z","comments":true,"path":"2020/01/01/解决Tomcat8上传文件无可读权限问题/","link":"","permalink":"http://www.lida1024.top/2020/01/01/%E8%A7%A3%E5%86%B3Tomcat8%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%A0%E5%8F%AF%E8%AF%BB%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"描述使用springmvc做了一个文件上传的功能，上传到nginx目录下的一个文件夹，但是通过目录访问的时候却报403的错误去服务器查看了一下文件的权限，发现没有可读权限，于是定位了问题，上传的文件全都没有可读权限。 为什么没有可读权限网上查阅资料发现，linux默认umask为022，对应权限为755，其它用户可读可执行。可以vim /etc/profile，搜索umusk关键字查看 1234if [ $UID -gt 199 ] &amp;&amp; [ &quot;&#96;&#x2F;usr&#x2F;bin&#x2F;id -gn&#96;&quot; &#x3D; &quot;&#96;&#x2F;usr&#x2F;bin&#x2F;id -un&#96;&quot; ]; then umask 002else umask 022 而tomcat8默认umask为027，对应权限为750，也就是说其它用户连可读的权限都没有。可打开catalina.sh文件，搜索umask查看。 12345# Set UMASK unless it has been overriddenif [ -z &quot;$UMASK&quot; ]; then UMASK&#x3D;&quot;0027&quot;fiumask $UMASK 在catalina.sh文件的开篇可以看到 1# UMASK (Optional) Override Tomcat&#39;s default UMASK of 0027 于是问题有了答案登录到服务器，进入到tomcat的bin目录下 123vim catalina.sh输入i,进入编辑模式，将umask改为0022：wq(保存退出) 可以看到接下来重启tomcat，重新上传图片即可香油可读权限。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://www.lida1024.top/tags/Tomcat/"}]},{"title":"软件版本命名规范及各阶段说明","slug":"软件版本命名规范及各阶段说明","date":"2020-01-01T03:27:00.000Z","updated":"2020-01-01T03:31:36.313Z","comments":true,"path":"2020/01/01/软件版本命名规范及各阶段说明/","link":"","permalink":"http://www.lida1024.top/2020/01/01/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%8F%8A%E5%90%84%E9%98%B6%E6%AE%B5%E8%AF%B4%E6%98%8E/","excerpt":"","text":"前言很多开发人员都没有经历过产品不断的迭代过程，基本上都是做完一套，至多经历一两个版本的迭代，基本上都会调入到另一个项目组或者离职，之后这样的事情不断地重复，直至离开这个行业。 开发人员3个月开发一个版本，定位version1，如果有bug，修复后该怎么升级这个版本号呢？可能是version2，修复这个bug后，如果还有bug呢，可能继续version3.，如果这样下去，还没到产品上线，你这个版本号都会很大，而且很难记得哪一版有什么功能。如果产品上线了以后，还会升级，大家可以想象一下，这样下去后，可能到达了version9999…. 命名格式版本控制比较普遍的 3 种命名格式 :GNU 风格的版本号命名格式、Windows 风格的版本号命名格式、.Net Framework 风格的版本号命名格式。 GNU 风格的版本号命名格式主版本号 . 子版本号 [. 修正版本号 [. 编译版本号 ]]Major_Version_Number.Minor_Version_Number[.Revision_Number[.Build_Number]]示例 :1.2.1, 2.0, 5.0.0 build-13124 Windows 风格的版本号命名格式主版本号 . 子版本号 [ 修正版本号 [. 编译版本号 ]]Major_Version_Number.Minor_Version_Number[Revision_Number[.Build_Number]]示例: 1.21, 2.0 .Net Framework 风格的版本号命名格式主版本号.子版本号[.编译版本号[.修正版本号]]Major_Version_Number.Minor_Version_Number[.Build_Number[.Revision_Number]]版本号由二至四个部分组成：主版本号、次版本号、内部版本号和修订号。主版本号和次版本号是必选的；内部版本号和修订号是可选的，但是如果定义了修订号部分，则内部版本号就是必选的。所有定义的部分都必须是大于或等于 0 的整数。 应根据下面的约定使用这些部分：Major ：具有相同名称但不同主版本号的程序集不可互换。例如，这适用于对产品的大量重写，这些重写使得无法实现向后兼容性。 Minor：如果两个程序集的名称和主版本号相同，而次版本号不同，这指示显著增强，但照顾到了向后兼容性。例如，这适用于产品的修正版或完全向后兼容的新版本。 Build ：内部版本号的不同表示对相同源所作的重新编译。这适合于更改处理器、平台或编译器的情况。 Revision ：名称、主版本号和次版本号都相同但修订号不同的程序集应是完全可互换的。这适用于修复以前发布的程序集中的安全漏洞。 程序集的只有内部版本号或修订号不同的后续版本被认为是先前版本的修补程序 (Hotfix) 更新。 因为目前市场上的软件基本上都是移动端化了，所以这里主要介绍GNU风格。 软件版本阶段说明 Base版: 此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是页面中的功能都没有做完整的实现，只是做为整体网站的一个基础架构。 Alpha版: 此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改。 Beta版: 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI。 RC版: 该版本已经相当成熟了，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。 Release版: 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(Ｒ)。 版本命名规范软件版本号由四部分组成： 第一部分为主版本号 第二部分为子版本号 第三部分为阶段版本号 第四部分为日期版本号加希腊字母版本号版本号修改规则 主版本号修改 当功能模块有较大的变动，比如增加多个模块或者整体架构发生变化。此版本号由项目决定是否修改。 子版本号修改 当功能有一定的增加或变化，比如增加了对权限控制、增加自定义视图等功能。此版本号由项目决定是否修改。 阶段版本号修改 一般是 Bug 修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的bug即可发布一个修订版。此版本号由项目经理决定是否修改。 日期版本号 用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本号。此版本号由开发人员决定是否修改。 希腊字母版本号 此版本号用于标注当前版本的软件处于哪个开发阶段，当软件进入到另一个阶段时需要修改此版本号。此版本号由项目决定是否修改。版本号阶段标志 阶段名称 阶段标识 需求控制 a 设计阶段 b 编码阶段 c 单元测试 d 单元测试修改 e 集成测试 f 集成测试修改 g 系统测试 h 系统测试修改 i 验收测试 j 验收测试修改 k","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://www.lida1024.top/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"快速搭建Spring Boot项目及常用技术整合","slug":"快速搭建Spring-Boot项目及常用技术整合","date":"2020-01-01T03:18:00.000Z","updated":"2020-01-01T03:20:50.907Z","comments":true,"path":"2020/01/01/快速搭建Spring-Boot项目及常用技术整合/","link":"","permalink":"http://www.lida1024.top/2020/01/01/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BASpring-Boot%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E6%95%B4%E5%90%88/","excerpt":"","text":"Spring Boot简介Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 Spring Boot特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成并且对XML也没有配置要求 快速入门1、访问http://start.spring.io/构建项目，也可在idea创建如下图： 2、 springboot默认生成三个文件2.1 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;groupId&gt;com.example&lt;&#x2F;groupId&gt; &lt;artifactId&gt;demo&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;name&gt;demo&lt;&#x2F;name&gt; &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;&#x2F;properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 重点就一个gav：spring-boot-starter-web，其他可以删除。 2.2 application.properties该文件默认为空，springboot的默认启动端口号：8080，可以在改文件修改。建议用yml的格式 12server: port: 8080 2.3 启动类文件1234567public class JxcApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(JxcApplication.class, args); &#125;&#125; 2.4 验证springboot在项目包路径下创建一个Controller，写一个HelloController 123456789@Controllerpublic class HelloController &#123; @RequestMapping(&quot;&#x2F;&quot;) @ResponseBody public String getHello() &#123; return &quot;hello&quot;; &#125;&#125; 浏览器查看效果 完成项目完整项目目录 1、项目依赖 web 12345678910111213141516 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;aspectjweaver.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; mysql12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; lombok(可选)12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; pagehelper(可选)12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;pagehelper.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; JWT(可选)12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;jwt.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; mybatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; shiro12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt; &lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;1.4.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; hutool(可选)12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt; &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.7&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; druid1234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.10&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.10&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; jdbc1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; fastjson12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; tomcat1234&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 附上properties123456789101112&lt;properties&gt; &lt;project.version&gt;1.0&lt;&#x2F;project.version&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;mysql.version&gt;5.1.25&lt;&#x2F;mysql.version&gt; &lt;pagehelper.version&gt;1.2.12&lt;&#x2F;pagehelper.version&gt; &lt;jwt.version&gt;0.9.1&lt;&#x2F;jwt.version&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;commons.lang.version&gt;3.9&lt;&#x2F;commons.lang.version&gt; &lt;aspectjweaver.version&gt;1.9.4&lt;&#x2F;aspectjweaver.version&gt; &lt;fastjson.version&gt;1.2.62&lt;&#x2F;fastjson.version&gt; &lt;&#x2F;properties&gt; 2、配置文件2.1修改application.properties为application.yml配置端口，项目根路径，spring配置，mybatis配置，分页插件配置1234567891011121314151617181920212223242526272829303132333435server: port: 8100 servlet: context-path: &#x2F;apispring: profiles: active: dev http: encoding: charset: UTF-8 force: true enabled: truemybatis: mapper-locations: classpath:&#x2F;mapper&#x2F;*.xml type-aliases-package: com.example.jxc.domain.entity.* configuration: cache-enabled: true lazy-loading-enabled: true multiple-result-sets-enabled: true use-column-label: true call-setters-on-nulls: true local-cache-scope: session map-underscore-to-camel-case: true default-executor-type: BATCH auto-mapping-behavior: PARTIALpagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count&#x3D;countSql mybatis中的configuration配置，这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项的意图、默认值等。| 设置名| 描述| 有效值|默认值||—–|—–|——|——|| cacheEnabled | 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。 | true false |true|| lazyLoadingEnabled| 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 | true false |false|| aggressiveLazyLoading| 当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载（参考 lazyLoadTriggerMethods)。 | true false |false （在 3.4.1 及之前的版本默认值为 true） || multipleResultSetsEnabled| 是否允许单一语句返回多结果集（需要驱动支持）。 | true false |true|| useColumnLabel| 使用列标签代替列名。不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。 | true false |true|| useGeneratedKeys| 允许 JDBC 支持自动生成主键，需要驱动支持。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能支持但仍可正常工作（比如 Derby）。 | true false |false || autoMappingBehavior| 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。 | NONE, PARTIAL, FULL |PARTIAL|| autoMappingUnknownColumnBehavior| 指定发现自动映射目标未知列（或者未知属性类型）的行为。NONE: 不做任何反应，WARNING: 输出提醒日志 (‘org.apache.ibatis.session.AutoMappingUnknownColumnBehavior’ 的日志等级必须设置为 WARN) ，FAILING: 映射失败 (抛出 SqlSessionException) | NONE, WARNING, FAILING |NONE|| defaultExecutorType| 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 | SIMPLE REUSE BATCH |SIMPLE|| defaultStatementTimeout| 设置超时时间，它决定驱动等待数据库响应的秒数。 | 任意正整数 |未设置 (null) || defaultFetchSize| 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 | 任意正整数 |未设置 (null) || defaultResultSetType| Specifies a scroll strategy when omit it per statement settings. (Since: 3.5.2) | FORWARD_ONLY SCROLL_SENSITIVE SCROLL_INSENSITIVE DEFAULT(same behavior with ‘Not Set’) |Not Set (null) || safeRowBoundsEnabled| 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 | true false |false || safeResultHandlerEnabled|允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为 false。 | true false |false || mapUnderscoreToCamelCase|是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 | true false |false || localCacheScope| MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 | SESSION STATEMENT |SESSION || jdbcTypeForNull| 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 | JdbcType 常量，常用值：NULL, VARCHAR 或 OTHER。|OTHER|| lazyLoadTriggerMethods| 指定哪个对象的方法触发一次延迟加载。 | 用逗号分隔的方法列表 |equals,clone,hashCode,toString || defaultScriptingLanguage| 指定动态 SQL 生成的默认语言。 | 一个类型别名或完全限定类名 |org.apache.ibatis.scripting.xmltags.XMLLanguageDriver || defaultEnumTypeHandler|指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5） | 一个类型别名或完全限定类名 |org.apache.ibatis.type.EnumTypeHandler || callSettersOnNulls| 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值初始化的时候比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 | true false |false || returnInstanceForEmptyRow| 当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 （如集合或关联）。（新增于 3.4.2） | true false |false || logPrefix| 指定 MyBatis 增加到日志名称的前缀。 | 任何字符串 |未设置|| logImpl| 指定 MyBatis 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 | SLF4J,LOG4J,LOG4J2,JDK_LOGGING,COMMONS_LOGGING,STDOUT_LOGGING,NO_LOGGING |未设置|| proxyFactory| 指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。 | CGLIB ,JAVASSIST |AVASSIST （MyBatis 3.3 以上） || vfsImpl| 指定 VFS 的实现 | 自定义 VFS 的实现的类全限定名，以逗号分隔。 |未设置|| useActualParamName| 允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 -parameters 选项。（新增于 3.4.1） | true false |true|| configurationFactory| 指定一个提供 Configuration 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为static Configuration getConfiguration() 的方法。（新增于 3.2.3） | 类型别名或者全类名. |未设置| 2.2 新建application-dev.yml配置数据库信息,通过application.yml中的active来启用dev配置文件 123spring: profiles: active: dev application-dev.yml完整配置 12345678910111213141516171819202122232425spring: datasource: # 数据源基本配置 username: root password: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;fhshgl type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙 filters: stat,wall maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;500 3、数据库连接池 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;) @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; &#x2F;** * 配置Druid的监控 * @return *&#x2F; @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean &#x3D; new ServletRegistrationBean(new StatViewServlet(), &quot;&#x2F;druid&#x2F;*&quot;); Map&lt;String,String&gt; initParams &#x3D; new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); &#x2F;&#x2F;默认就是允许所有访问 initParams.put(&quot;allow&quot;,&quot;&quot;); initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;); bean.setInitParameters(initParams); return bean; &#125; &#x2F;** * 配置一个web监控的filter * @return *&#x2F; @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean &#x3D; new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams &#x3D; new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,&#x2F;druid&#x2F;*&quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;&#x2F;*&quot;)); return bean; &#125;&#125; 4、shiro4.1自定义realm代码如下： 123456789101112131415161718192021222324252627public class MyRealm extends AuthorizingRealm&#123; @Autowired private UserService userService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; &#x2F;&#x2F;拿到封装好账户密码的token UsernamePasswordToken token &#x3D; (UsernamePasswordToken) authenticationToken; String userName &#x3D; token.getUsername(); &#x2F;&#x2F;用户校验 User user &#x3D; this.userService.getUser(userName); if (user &#x3D;&#x3D; null) &#123; throw new AuthenticationException(&quot;用户名或密码错误！&quot;); &#125; &#x2F;&#x2F;加盐 计算盐值 保证每个加密后的 MD5 不一样 ByteSource credentialsSalt &#x3D; ByteSource.Util.bytes(user.getUsername()); SimpleAuthenticationInfo info &#x3D; new SimpleAuthenticationInfo(user, user.getPassword(), credentialsSalt, this.getName()); return info; &#125;&#125; 4.2shiro配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Configurationpublic class ShiroConfig &#123; &#x2F;** * 主要配置一些相应的URL的规则和访问权限 *&#x2F; @Bean public ShiroFilterFactoryBean shiroFilter() &#123; ShiroFilterFactoryBean shiroFilterFactoryBean &#x3D; new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager()); &#x2F;&#x2F;拦截器. Map&lt;String, String&gt; filterChainDefinitionMap &#x3D; new LinkedHashMap&lt;String, String&gt;(); &#x2F;&#x2F;配置退出 过滤器,其中的具体的退出代码Shiro已经替我们实现了 filterChainDefinitionMap.put(&quot;&#x2F;system&#x2F;logout&quot;, &quot;anon&quot;); &#x2F;&#x2F;过滤链定义，从上向下顺序执行，一般将&#x2F;**放在最为下边 &#x2F;&#x2F;authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问&#x2F;&#x2F; filterChainDefinitionMap.put(&quot;&#x2F;static&#x2F;**&quot;, &quot;anon&quot;); shiroFilterFactoryBean.setLoginUrl(&quot;&#x2F;system&#x2F;login&quot;); filterChainDefinitionMap.put(&quot;&#x2F;**&quot;, &quot;authc&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; &#125; &#x2F;** * 注入 securityManager *&#x2F; @Bean public DefaultWebSecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager &#x3D; new DefaultWebSecurityManager(); &#x2F;&#x2F; 设置realm. securityManager.setRealm(customRealm()); return securityManager; &#125; &#x2F;** * 自定义身份认证 realm; * &lt;p&gt; * 必须写这个类，并加上 @Bean 注解，目的是注入 MyRealm， * 否则会影响 MyRealm 中其他类的依赖注入 *&#x2F; @Bean public MyRealm customRealm() &#123; return new MyRealm(); &#125; &#x2F;** * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证 * 配置以下两个bean(DefaultAdvisorAutoProxyCreator(可选)和AuthorizationAttributeSourceAdvisor)即可实现此功能 * * @return *&#x2F; @Bean @DependsOn(&#123;&quot;lifecycleBeanPostProcessor&quot;&#125;) public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() &#123; DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator &#x3D; new DefaultAdvisorAutoProxyCreator(); advisorAutoProxyCreator.setProxyTargetClass(true); return advisorAutoProxyCreator; &#125; @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor() &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor &#x3D; new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager()); return authorizationAttributeSourceAdvisor; &#125; &#x2F;** * Shiro生命周期处理器 ---可以自定的来调用配置在 Spring IOC 容器中 shiro bean 的生命周期方法. * * @return *&#x2F; @Bean public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125;&#125; 5、过滤器-跨域过滤5.1跨域过滤 1234567891011121314151617181920212223242526272829public class CostFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req &#x3D; (HttpServletRequest) request; HttpServletResponse resp &#x3D; (HttpServletResponse) response; String origin &#x3D; req.getHeader(&quot;Origin&quot;); if (origin &#x3D;&#x3D; null) &#123; origin &#x3D; req.getHeader(&quot;Referer&quot;); &#125; &#x2F;&#x2F; 允许指定域访问跨域资源 resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); &#x2F;&#x2F; 允许客户端携带跨域cookie，此时origin值不能为“*”，只能为指定单一域名 resp.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); if (&quot;OPTIONS&quot;.equals(req.getMethod())) &#123; String allowMethod &#x3D; req.getHeader(&quot;Access-Control-Request-Method&quot;); String allowHeaders &#x3D; req.getHeader(&quot;Access-Control-Request-Headers&quot;); &#x2F;&#x2F; 浏览器缓存预检请求结果时间,单位:秒 resp.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;86400&quot;); &#x2F;&#x2F; 允许浏览器在预检请求成功之后发送的实际请求方法名 resp.setHeader(&quot;Access-Control-Allow-Methods&quot;, allowMethod); &#x2F;&#x2F; 允许浏览器发送的请求消息头 resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, allowHeaders); resp.setHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;utf-8&quot;); return; &#125; chain.doFilter(request, response); &#125;&#125; 5.2 过滤器配置 12345678910111213141516@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean configureFilter()&#123; FilterRegistrationBean bean &#x3D; new FilterRegistrationBean&lt;&gt;(); bean.setName(&quot;costFilter&quot;); CostFilter costFilter &#x3D; new CostFilter(); bean.setFilter(costFilter); bean.setOrder(1); List&lt;String&gt; urlList &#x3D; new ArrayList&lt;String&gt;(); urlList.add(&quot;&#x2F;*&quot;); bean.setUrlPatterns(urlList); return bean; &#125;&#125; 6、token拦截6.1JWTjwt工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class JwtUtils &#123; public static SecretKey getBase64Key() &#123; String stringKey &#x3D; &quot;MyJwtSecret&quot;; byte[] encodeKey &#x3D; Base64.getDecoder().decode(stringKey); SecretKey key &#x3D; new SecretKeySpec(encodeKey, 0, encodeKey.length, &quot;AES&quot;); return key; &#125; &#x2F;** * 签发token * * @param userName 用户名 * @return token *&#x2F; public static String create(String userName) &#123; Date now &#x3D; new Date(System.currentTimeMillis()); String token &#x3D; Jwts.builder() .setIssuedAt(now) .setSubject(userName) .setExpiration(new Date(System.currentTimeMillis() + 60 * 60 * 1000)) .signWith(SignatureAlgorithm.HS256, getBase64Key()) .compact(); return token; &#125; &#x2F;** * 解析token * * @param token token * @return 用户名 *&#x2F; public static String parse(String token) &#123; String username &#x3D; null; try &#123; username &#x3D; Jwts.parser() .setSigningKey(getBase64Key()) .parseClaimsJws(token.replace(&quot;Bearer &quot;, &quot;&quot;)) .getBody() .getSubject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return username; &#125; &#x2F;** * 检验token是否过期 * * @param token * @return *&#x2F; public static boolean verify(String token) &#123; Date expiraDate &#x3D; null; Date currentDate &#x3D; new Date(); try &#123; expiraDate &#x3D; Jwts.parser() .setSigningKey(getBase64Key()) .parseClaimsJws(token.replace(&quot;Bearer &quot;, &quot;&quot;)) .getBody() .getExpiration(); if (currentDate.before(expiraDate)) &#123; return true; &#125; else &#123; return false; &#125; &#125; catch (Exception e) &#123; return false; &#125; &#125;&#125; 6.2token拦截器 123456789101112131415161718192021222324@Componentpublic class TokenInterceptor implements HandlerInterceptor &#123; public Log log &#x3D; LogFactory.getLog(TokenInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)&#123; if (request.getMethod().equals(&quot;OPTIONS&quot;)) &#123; response.setStatus(HttpServletResponse.SC_OK); return true; &#125; response.setCharacterEncoding(&quot;utf-8&quot;); String token &#x3D; request.getHeader(&quot;Authorization&quot;); if (token !&#x3D; null) &#123; boolean result &#x3D; JwtUtils.verify(token); if (result) &#123; return true; &#125; &#125; log.error(&quot;认证失败&quot;); response.setStatus(HttpServletResponse.SC_NON_AUTHORITATIVE_INFORMATION); return false; &#125;&#125; 6.3配置拦截器 1234567891011121314@Configurationpublic class InterceptorConfig extends WebMvcConfigurationSupport &#123; @Autowired private TokenInterceptor tokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(tokenInterceptor) .addPathPatterns(&quot;&#x2F;**&quot;) .excludePathPatterns(&quot;&#x2F;**&#x2F;login&quot;) .excludePathPatterns(&quot;&#x2F;**&#x2F;logOut&quot;); &#125;&#125; 7、完成一个登录接口LoginController123456789101112131415161718192021222324252627282930@RestController@RequestMapping(&quot;&#x2F;system&quot;)public class LoginController extends BaseController &#123; @Autowired private UserService userService; &#x2F;** * 浏览器点击登录 * * @param user * @return *&#x2F; @PostMapping(&quot;&#x2F;login&quot;) public R login(@RequestBody User user) &#123; log.debug(&quot;------浏览器点击登录------&quot;); String userName &#x3D; user.getUsername(); String passWord &#x3D; user.getPassword(); UsernamePasswordToken usernamePasswordToken &#x3D; new UsernamePasswordToken(userName, MD5.md5Salt(passWord, userName)); Subject subject &#x3D; SecurityUtils.getSubject(); try &#123; subject.login(usernamePasswordToken); String token &#x3D; JwtUtils.create(userName); return R.ok(R.SUCCESS, R.MSG_SUCCESS, token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); return R.error(R.MSG_LOGIN_ERROR); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"微服务网关 Spring Cloud Gateway","slug":"微服务网关-Spring-Cloud-Gateway","date":"2020-01-01T03:09:00.000Z","updated":"2020-01-01T05:34:50.539Z","comments":true,"path":"2020/01/01/微服务网关-Spring-Cloud-Gateway/","link":"","permalink":"http://www.lida1024.top/2020/01/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3-Spring-Cloud-Gateway/","excerpt":"","text":"什么是网关假设你现在要做一个电商应用，前端是移动端的APP，后端是各种微服务。那你可能某个页面需要调用多个服务的数据来展示。如果没有网关，你的系统看起来就是这个样子的： 而如果加上了网关，你的系统就会变成这个样子：#Spring Cloud GatewaySpring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。 Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。 相关概念 Route（路由）：这是网关的基本构建块。它由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配。 Predicate（断言）：这是一个 Java 8 的 Predicate。输入类型是一个 ServerWebExchange。我们可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。 Filter（过滤器）：这是org.springframework.cloud.gateway.filter.GatewayFilter的实例，我们可以使用它修改请求和响应。工作流程 （PS：看到这张图是不是很熟悉，没错，很像SpringMVC的请求处理过程） 请求发送到网关，DispatcherHandler是HTTP请求的中央分发器，接管请求并将请求匹配到相应的 HandlerMapping。 请求与处理器之间有一个映射关系，网关将会对请求进行路由，handler 此处会匹配到 RoutePredicateHandlerMapping，匹配请求对应的 Route。 随后到达网关的 web 处理器，该 WebHandler 代理了一系列网关过滤器和全局过滤器的实例，如对请求或者响应的 Header 处理（增加或者移除某个 Header）。 最后，转发到具体的代理服务。 简而言之：客户端向 Spring Cloud Gateway 发出请求。如果 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。 快速开始1.新建一个项目gatewayTest在项目中添加3个moduleeureka,producer,gateway项目结构 2.rureka新建module 添加eureka依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 完整pom 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.example.eureka&lt;&#x2F;groupId&gt; &lt;artifactId&gt;eureka&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;packaging&gt;jar&lt;&#x2F;packaging&gt; &lt;name&gt;eureka&lt;&#x2F;name&gt; &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt; &lt;parent&gt; &lt;groupId&gt;com.gateway.test&lt;&#x2F;groupId&gt; &lt;artifactId&gt;gatewayTest&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;relativePath&gt;..&lt;&#x2F;relativePath&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 配置文件 1234567891011121314spring: application: name: eurekaserver: port: 8761eureka: instance: hostname: localhost client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F; 启动类 123456789101112131415package com.example.eureka.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 启动程序，访问http://localhost:8761/![图片.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjU1MzI0OS05NzY5NzhkMzZmOGM1NmJlLnBuZw?x-oss-process=image/format,png)现在还没有服务进行注册 3.producer新建producer的module，同创建rureka，不同处如下图，其他都一样。 完整pom 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.example.producer&lt;&#x2F;groupId&gt; &lt;artifactId&gt;producer&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;name&gt;producer&lt;&#x2F;name&gt; &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt; &lt;parent&gt; &lt;groupId&gt;com.gateway.test&lt;&#x2F;groupId&gt; &lt;artifactId&gt;gatewayTest&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;relativePath&gt;..&lt;&#x2F;relativePath&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 配置文件 12345678910spring: application: name: producerserver: port: 8081eureka: client: service-url: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F; 启动类 123456789101112131415package com.example.producer.producer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@EnableEurekaClient@SpringBootApplicationpublic class ProducerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProducerApplication.class, args); &#125;&#125; 新建2个类控制器HelloController 123456789@RestController@RequestMapping(&quot;&#x2F;hello&quot;)public class HelloController &#123; @RequestMapping(&quot;say&quot;) public String say() &#123; return &quot;Hello Every Buddy&quot;; &#125;&#125; GoodByeController 123456789@RestController@RequestMapping(&quot;&#x2F;goodbye&quot;)public class GoodByeController &#123; @RequestMapping(&quot;say&quot;) public String say() &#123; return &quot;Bye Bye&quot;; &#125;&#125; 启动程序，访问http://localhost:8761/ 4.gateway创建过程同eureka完整pom 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.example.gateway&lt;&#x2F;groupId&gt; &lt;artifactId&gt;gateway&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;name&gt;gateway&lt;&#x2F;name&gt; &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt; &lt;parent&gt; &lt;groupId&gt;com.gateway.test&lt;&#x2F;groupId&gt; &lt;artifactId&gt;gatewayTest&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;relativePath&gt;..&lt;&#x2F;relativePath&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344test: uri: lb:&#x2F;&#x2F;producerspring: application: name: gateway# cloud:# gateway:# routes:# - id: route_producer_hello# uri: $&#123;test.uri&#125; # uri以lb:&#x2F;&#x2F;开头（lb代表从注册中心获取服务），后面接的就是你需要转发到的服务名称# predicates:# - Path&#x3D;&#x2F;api-hello&#x2F;**# filters:# - StripPrefix&#x3D;1 # 表示在转发时去掉api## - id: route_producer_goodbye# uri: $&#123;test.uri&#125;# predicates:# - Path&#x3D;&#x2F;api-goodbye&#x2F;**# filters:# - StripPrefix&#x3D;1# - name: Hystrix# args:# name: myfallbackcmd# fallbackUri: forward:&#x2F;user&#x2F;fallbackserver: port: 8080logging: level: org.springframework.cloud.gateway: TRACE org.springframework.http.server.reactive: DEBUG org.springframework.web.reactive: DEBUG reactor.ipc.netty: DEBUGeureka: client: service-url: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F; enabled: true # 是否启用注册服务 默认为true, false是不启用 instance: prefer-ip-address: true 启动类 123456789101112131415161718192021222324252627package com.example.gateway.gateway;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.gateway.route.RouteLocator;import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class GatewayApplication &#123; @Value(&quot;$&#123;test.uri&#125;&quot;) private String uri; @Bean public RouteLocator routeLocator(RouteLocatorBuilder builder)&#123; return builder.routes() .route(r -&gt;r.path(&quot;&#x2F;hello&#x2F;**&quot;).uri(uri)) .route(r -&gt;r.path(&quot;&#x2F;goodbye&#x2F;**&quot;).uri(uri)).build(); &#125; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 启动程序，访问http://localhost:8761/ 5.测试服务都已经注册到reureka,我们定义了hello和goodbye开头的请求都会转发到lb://producer服务，我们定义gateway的端口是8080，producer的端口是8081直接请求producer服务http://localhost:8081/hello/sayhttp://localhost:8081/goodbye/say 通过网关请求http://localhost:8080/hello/sayhttp://localhost:8080/goodbye/say 网关本身的负载均衡那所有微服务就只有一个网关，万一并发量上去了，网关承受不住怎么办？Spring Cloud Gateway底层是Netty的，它本身就能承受比较大的并发。如果还是承受不了并发量，那可以注册多个Gateway实例，然后在前面弄一个Nginx或者F5等负载均衡器。大概图是这样：","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"微服务注册中心为什么要使用Consul？","slug":"微服务注册中心为什么要使用Consul？","date":"2020-01-01T03:03:00.000Z","updated":"2020-01-01T03:05:59.332Z","comments":true,"path":"2020/01/01/微服务注册中心为什么要使用Consul？/","link":"","permalink":"http://www.lida1024.top/2020/01/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Consul%EF%BC%9F/","excerpt":"","text":"一、Eureka不建议使用在选型微服务注册中心时，一定要长远考虑，SpringCloud提供了Eureka作为服务注册中心，我们可以开箱即用，但是，对于服务注册中心随着业务需求的不断变化，对服务注册中心提出了更高要求，Eureka就不太适合了，看到“Eureka 2.0 开源工作宣告停止，继续使用风险自负”。这意味着如果开发者继续使用作为 2.x 分支上现有工作 repo 一部分发布的代码库和工件，则将自负风险，对此，专家建议开发者尽快将相关业务迁移到 Consul/ZooKeeper/Etcd等工具上。 二、Consul与Zookeeper的区别Consul是一个在国外流行的服务发现和配置共享的服务软件。本文翻译自Consul的官方文档，文中重点讲述：在与主流同类软件ZooKeeper、Doozerd以及Etcd比较时，Consul的优势所在。 ZooKeeper、Doozerd、Etcd在架构上都非常相似，它们都有服务节点（server node），而这些服务节点的操作都要求达到节点的仲裁数（通常，节点的仲裁数遵循的是简单多数原则）。此外，它们都是强一致性的，并且提供各种原语。通过应用程序内部的客户端lib库，这些原语可以用来构建复杂的分布式系统。 Consul在一个单一的数据中心内部使用服务节点。在每个数据中心中，为了Consule能够运行，并且保持强一致性，Consul服务端需要仲裁。然而，Consul原生支持多数据中心，就像一个丰富gossip系统连接服务器节点和客户端一样。 当提供K/V存储的时候，这些系统具有大致相同的语义，读取是强一致性的，并且在面对网络分区的时候，为了保持一致性，读取的可用性是可以牺牲的。然而，当系统应用于复杂情况时，这种差异会变得更加明显。 这些系统提供的语义对开发人员构建服务发现系统很有吸引力，但更重要的是，强调开发人员要构建这些特性。ZooKeeper只提供一个原始的K/V值存储，并要求开发人员构建他们自己的系统来提供服务发现功能。相反的是，Consul提供了一个坚固的框架，这不仅仅是为了提供服务发现功能，也是为了减少推测工作和开发工作量。客户端只需简单地完成服务注册工作，然后使用一个DNS接口或者HTTP接口就可以执行工作了，而其他系统则需要你定制自己的解决方案。 一个令人信服的服务发现框架必须包含健康检测功能，并且考虑失败的可能性。要是节点失败或者服务故障了，即使开发人员知道节点A提供Foo服务也是没用的。Navie系统利用的是心跳、周期性更新和TTLs，这些系统不仅需要工作量与节点数量成线性关系，并且对服务器的固定数量提出了要求。此外，故障检测窗口的存活时间至少要和TTL一样长。 ZooKeeper提供了临时节点，这些临时节点就是K/V条目，当客户端断开连接时，这些条目会被删除。虽然这些临时节点比一个心跳系统更高级，但仍存在固有的扩展性问题，并且会增加客户端的复杂性。与ZooKeeper服务器端连接时，客户端必须保持活跃，并且去做持续性连接。此外，ZooKeeper还需要胖客户端，而胖客户端是很难编写，并且胖客户端会经常导致调试质询。 Consul使用一个完全不同的架构进行健康检测。Consul客户端可以运行在集群中的每一个节点上，而不是拥有服务器节点，这些Consul客户端属于一个gossip pool，gossip pool提供了一些功能，包括分布式健康检测。gossip协议提供了一个高效的故障检测工具，这个故障检测工具可以应用到任意规模的集群，而不仅仅是作用于特定的服务器组。同时，这个故障检测工具也支持在本地进行多种健康检测。与此相反，ZooKeeper的临时节点只是一个非常原始的活跃度检测。因为有了Consul，客户端可以检测web服务器是否正在返回200状态码，内存利用率是否达到临界点，是否有足够的数据存储盘等。此外，ZooKeeper会暴露系统的复杂性给客户端，为了避免ZooKeeper出现的这种情况，Consul只提供一个简单HTTP接口。 Consul为服务发现、健康检测、K/V存储和多数据中心提供了一流的支持。为了支持任意存储，而不仅仅是简单的K/V存储，其他系统都要求工具和lib库要率先建立。然而，通过使用客户端节点，Consul提供了一个简单的API，这个API的开发只需要瘦客户端就可以了， 而且，通过使用配置文件和DNS接口，开发人员可以建立完整的服务发现解决方案，最终，达到避免开发API的目的。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"枚举真的比静态常量更占空间吗？","slug":"枚举真的比静态常量更占空间吗？","date":"2019-12-30T02:21:00.000Z","updated":"2020-01-01T02:30:26.540Z","comments":true,"path":"2019/12/30/枚举真的比静态常量更占空间吗？/","link":"","permalink":"http://www.lida1024.top/2019/12/30/%E6%9E%9A%E4%B8%BE%E7%9C%9F%E7%9A%84%E6%AF%94%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E6%9B%B4%E5%8D%A0%E7%A9%BA%E9%97%B4%E5%90%97%EF%BC%9F/","excerpt":"","text":"前两天在网上看到一条信息：枚举比静态常量更占用空间。这是真的吗？ 前言枚举枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。 枚举实现原理在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自java.lang.Enum类。 枚举新建一个枚举类 123456789101112131415161718192021222324252627282930package com.example.demo;&#x2F;** * @Author: 少年闰土 * @Date: 2019&#x2F;12&#x2F;27 0027 上午 9:23 * @Description: *&#x2F;public enum Season &#123; SPRING(&quot;春天&quot;, &quot;趁春踏青&quot;), SUMMER(&quot;夏天&quot;, &quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;, &quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;, &quot;围炉赏雪&quot;); private final String name; private final String desc; Season(String name, String desc) &#123; this.name &#x3D; name; this.desc &#x3D; desc; &#125; public String getName() &#123; return name; &#125; public String getDesc() &#123; return desc; &#125;&#125; 接下来使用javac命令进行编译：生成class文件，然后再通过javap反编译 123456789101112131415public final class com.example.demo.Season extends java.lang.Enum&lt;com.example.demo.Season&gt; &#123; public static final com.example.demo.Season SPRING; public static final com.example.demo.Season SUMMER; public static final com.example.demo.Season AUTUMN; public static final com.example.demo.Season WINTER; &#x2F;&#x2F;编译器为我们添加的静态的values()方法 public static com.example.demo.Season[] values(); &#x2F;&#x2F;编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法 public static com.example.demo.Season valueOf(java.lang.String); &#x2F;&#x2F;构造方法 public java.lang.String getName(); public java.lang.String getDesc(); static &#123;&#125;;&#125; 静态常量123456789101112131415package com.example.demo;&#x2F;** * @Author: 少年闰土 * @Date: 2019&#x2F;12&#x2F;27 0027 上午 10:49 * @Description: *&#x2F;public class Season &#123; public static final String SPRING &#x3D;&quot;春天&quot;; public static final String SUMMER &#x3D;&quot;夏天&quot;; public static final String AUTUMN &#x3D;&quot;秋天&quot;; public static final String WINTER &#x3D;&quot;冬天&quot;;&#125; javap反编译后： 1234567public class com.example.demo.Season &#123; public static final java.lang.String SPRING; public static final java.lang.String SUMMER; public static final java.lang.String AUTUMN; public static final java.lang.String WINTER; public com.example.demo.Season();&#125; 对比枚举 静态常量 编译后的枚举class文件大小为1471字节，静态常量class文件大小为400字节。 用Chkdsk查看簇大小 经过对比枚举类型文件大小更大一些。 枚举的实现原理就是定义一个类，然后实例化几个由final修饰的这个类的对象，每个实例都带有自己的元信息。而常量相比之下，没有这一层封装，只占用最基本的内存，包括引用，和它的值本身，要简单轻巧很多。如果值可以使用基本类型而不是包装类型，那更不用说了。 不过话又说回来，通常情况下我们没必要在意这种区别。如果用枚举可读性、可扩展性更好，用就是了，枚举占那点内存，沧海一粟。在性能与代码维护性之间，除个别情况，优先选后者。高级编程语言的诞生本身就是硬件提升的背景下，牺牲某些性能来降低开发门槛，提高开发效率的，相对于微小的性能损耗，人力成本更值钱","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"enum","slug":"enum","permalink":"http://www.lida1024.top/tags/enum/"}]},{"title":"JWT简介","slug":"JWT简介","date":"2019-12-21T00:43:00.000Z","updated":"2019-12-21T07:09:31.125Z","comments":true,"path":"2019/12/21/JWT简介/","link":"","permalink":"http://www.lida1024.top/2019/12/21/JWT%E7%AE%80%E4%BB%8B/","excerpt":"","text":"前言JSON Web Token（JWT）是目前最流行的跨域身份验证解决方案。微服务常见的认证方案 一、跨域认证的问题互联网服务离不开用户认证。一般流程是下面这样。 1、用户向服务器发送用户名和密码。 2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 3、服务器向用户返回一个 session_id，写入用户的 Cookie。 4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。 一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。 什么是JWT：一句话概括就是（通过客户端保存数据，而服务器根本不保存会话数据，每个请求都被发送回服务器。） 二、JWTJSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。 一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。 1、JWT的原则JWT的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下所示。 123456789&#123; &quot;UserName&quot;: &quot;少年闰土&quot;, &quot;Role&quot;: &quot;Admin&quot;, &quot;Expire&quot;: &quot;2019-12-21 09:15:56&quot;&#125; 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 2、JWT的数据结构样例： 1eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1NTc5MDU4MDIsImV4cCI6MTU1NzkwNjgwMiwicm9sZXMiOiJhZG1pbiJ9.AS5Y2fNCwUzQQxXh_QQWMpaB75YqfuK-2P7VZiCXEJI 他是一个长字符串，中间用.进行分割，代表JWT的三个组成部分，如下： Header（头部） Payload（负载） Signature（签名） 2.1、头部（Header）头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;} 这个json中的typ属性，用来标识整个token字符串是一个JWT字符串；它的alg属性，用来说明这个JWT签发的时候所使用的签名和摘要算法。typ跟alg属性的全称其实是type跟algorithm，分别是类型跟算法的意思。之所以都用三个字母来表示，也是基于JWT最终字串大小的考虑，同时也是跟JWT这个名称保持一致，这样就都是三个字符了…typ跟alg是JWT中标准中规定的属性名称 在头部指明了签名算法是HS256算法。 我们进行BASE64编码http://base64.xpcha.com/，编码后的字符串如下：eyJhbGciOiJIUzI1NiJ9 2.2、载荷（Playload）Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 1234567iss: jwt签发者sub: jwt所面向的用户aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token。 除了官方字段，你还可以在这个部分定义私有字段样例：{&quot;sub&quot;:&quot;1234567890&quot;,&quot;name&quot;:&quot;John Doe&quot;,&quot;admin&quot;:true}然后将其进行base64加密，得到Jwt的第二部分。eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 2.3、签名（Signature）Signature 部分是对前两部分的签名，防止数据篡改。这个签证信息由三部分组成： header (base64后的) payload (base64后的)secret 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 3、Base64URL前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 4、JWT 的使用方式客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。Authorization: Bearer &lt;token&gt; 下图显示了如何获取JWT并将其用于访问API或资源： 三、JWT使用1、添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;&#x2F;groupId&gt; &lt;artifactId&gt;java-jwt&lt;&#x2F;artifactId&gt; &lt;version&gt;3.2.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 2、工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.example.demo.utils;import com.auth0.jwt.JWT;import com.auth0.jwt.JWTVerifier;import com.auth0.jwt.algorithms.Algorithm;import com.auth0.jwt.exceptions.JWTDecodeException;import com.auth0.jwt.interfaces.DecodedJWT;import org.springframework.stereotype.Component;import java.util.Date;import java.util.HashMap;import java.util.Map;&#x2F;** * @Author: 少年闰土 * @Date: 2019&#x2F;12&#x2F;11 * @Time: 下午 4:12 * @Version: v1.0 * jwt工具类 *&#x2F;@Componentpublic class JwtUtils &#123; &#x2F;** * 解析token * * @param token token * @return 用户名 *&#x2F; public static String getUserName(String token) &#123; try &#123; DecodedJWT jwt &#x3D; JWT.decode(token); return jwt.getClaim(&quot;userName&quot;).asString(); &#125; catch (JWTDecodeException e) &#123; e.printStackTrace(); return null; &#125; &#125; &#x2F;** * 签发token * * @param userName 用户名 * @return token *&#x2F; public static String sign(String userName,String secret) &#123; try &#123; &#x2F;&#x2F;token过期时间 Date date &#x3D; new Date(System.currentTimeMillis() + (60 * 60 * 1000)); Algorithm algorithm &#x3D; Algorithm.HMAC256(secret); &#x2F;&#x2F; 附带username信息 return JWT.create() .withClaim(&quot;userName&quot;, userName) .withExpiresAt(date) .sign(algorithm); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; &#x2F;** * 检验token是否过期 * * @param token * @return *&#x2F; public static Map verify(String token,String userName, String secret) &#123; Map result &#x3D; new HashMap&lt;String, Object&gt;(2); try &#123; Algorithm algorithm &#x3D; Algorithm.HMAC256(secret); JWTVerifier verifier &#x3D; JWT.require(algorithm) .withClaim(&quot;userName&quot;, userName) .build(); DecodedJWT jwt &#x3D; verifier.verify(token); result.put(&quot;isSuccess&quot;, true); result.put(&quot;exception&quot;, null); &#125; catch (Exception exception) &#123; result.put(&quot;isSuccess&quot;, false); result.put(&quot;exception&quot;, exception); &#125; return result; &#125;&#125; 3、使用12345678910111213141516@ApiOperation(value &#x3D; &quot;浏览器点击登录&quot;)@ApiImplicitParam(name &#x3D; &quot;user&quot;, value &#x3D; &quot;用户实体&quot;, required &#x3D; true, paramType &#x3D; &quot;User&quot;)@PostMapping(&quot;&#x2F;login&quot;)public R login(@RequestBody User user) &#123; log.debug(&quot;------浏览器点击登录------&quot;); String userName &#x3D; user.getUsername(); String passWord &#x3D; user.getPassword(); User u &#x3D; this.userService.getUser(userName); String passWordSalt &#x3D; MD5.md5Salt(passWord, userName); if (u !&#x3D; null &amp;&amp; u.getPassword().equals(passWordSalt)) &#123; String token &#x3D; JwtUtils.sign(userName, passWordSalt); return R.ok(R.SUCCESS, R.MSG_SUCCESS, token); &#125; else &#123; return R.error(R.MSG_LOGIN_ERROR); &#125;&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://www.lida1024.top/tags/JWT/"}]},{"title":"Spring Boot 两种部署到服务器的方式","slug":"Spring-Boot-两种部署到服务器的方式","date":"2019-11-19T00:46:00.000Z","updated":"2020-01-07T09:27:02.159Z","comments":true,"path":"2019/11/19/Spring-Boot-两种部署到服务器的方式/","link":"","permalink":"http://www.lida1024.top/2019/11/19/Spring-Boot-%E4%B8%A4%E7%A7%8D%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"jar包(官方推荐)jar包方式启动，也就是使用spring boot内置的tomcat运行。服务器上面只要你配置了jdk1.8及以上，就ok。不需要外置tomcat 1.打成jar包2.将jar包放到任意目录执行下面的命令 123$ nohup java -jar test.jar &gt;temp.txt &amp;&#x2F;&#x2F;这种方法会把日志文件输入到你指定的文件中，没有则会自动创建。进程会在后台运行。 3.放开端口阿里云服务器需要放开对应的端口添加安全组：我的项目中配置的启动端口是18080，故这里需要放开18080端口，才能访问 war包传统的部署方式：将项目打成war包，放入tomcat 的webapps目录下面，启动tomcat，即可访问。 开发环境：jdk1.8 + IDEA 下面搭建一个demo演示如何打war包部署并且如何访问：spring boot + maven 1.新建项目这里我们默认打成jar包，不用修改。 2.修改启动Application文件项目新建完成后，修改启动Application文件继承SpringBootServletInitializer,实现configure方法 1234567891011121314151617181920@SpringBootApplication@RestControllerpublic class Demo1Application extends SpringBootServletInitializer &#123; &#x2F;&#x2F; 用来测试访问 @RequestMapping(&quot;&#x2F;&quot;) public String home() &#123; return &quot;hello 朋友&quot;; &#125; public static void main(String[] args) &#123; SpringApplication.run(Demo1Application.class, args); &#125; &#x2F;&#x2F; 继承SpringBootServletInitializer 实现configure 方便打war 外部服务器部署。 @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(Demo1Application.class); &#125;&#125; 3.修改pom.xml1&lt;packaging&gt;war&lt;&#x2F;packaging&gt; 完整pom.xml代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.example&lt;&#x2F;groupId&gt; &lt;artifactId&gt;demo1&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;!-- 这里打成war包 若打jar，需将war改为jar --&gt; &lt;packaging&gt;war&lt;&#x2F;packaging&gt; &lt;name&gt;demo1&lt;&#x2F;name&gt; &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;&#x2F;properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;finalName&gt;demo1&lt;&#x2F;finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 4.打包这里可以直接到项目根目录下面：运行 maven package命令，打包。 我这里直接使用idea打包，如下图：5.将war放入外部tomcat的webapps目录下6.启动tomcat 小结1.对比两种打包方式jar更加简单，方便。具体使用哪种方式，应视应用场景而定。 2.注意再说一次，将项目打成war包，部署到外部的tomcat中，这个时候，不能直接访问spring boot 项目中配置文件配置的端口。application.yml中配置的server.port配置的是spring boot内置的tomcat的端口号, 打成war包部署在独立的tomcat上之后, 你配置的server.port是不起作用的。一定要注意这一点！！其实我们从tomcat的启动界面，已经可以看出，是启动的哪个端口：很明显，日志告诉我们，我们应该访问8080端口。下图是使用spring boot 内置tomcat启动日志，可以看出配置的server.port是生效了的！","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.lida1024.top/categories/SpringBoot/"}],"tags":[{"name":"打包部署","slug":"打包部署","permalink":"http://www.lida1024.top/tags/%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2/"}]},{"title":"Consul学习","slug":"Consul学习","date":"2019-11-19T00:43:00.000Z","updated":"2019-12-21T07:09:44.496Z","comments":true,"path":"2019/11/19/Consul学习/","link":"","permalink":"http://www.lida1024.top/2019/11/19/Consul%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"服务注册与服务发现是在分布式服务架构中常常会涉及到的东西，业界常用的服务注册与服务发现工具有 ZooKeeper、etcd、Consul 和 Eureka。Consul 的主要功能有服务发现、健康检查、KV存储、安全服务沟通和多数据中心。Consul 与其他几个工具的区别可以在这里查看 Consul vs. Other Software。##为什么需要有服务注册与服务发现？假设在分布式系统中有两个服务 Service-A （下文以“S-A”代称）和 Service-B（下文以“S-B”代称），当 S-A 想调用 S-B 时，我们首先想到的时直接在 S-A 中请求 S-B 所在服务器的 IP 地址和监听的端口，这在服务规模很小的情况下是没有任何问题的，但是在服务规模很大每个服务不止部署一个实例的情况下是存在一些问题的，比如 S-B 部署了三个实例 S-B-1、S-B-2 和 S-B-3，这时候 S-A 想调用 S-B 该请求哪一个服务实例的 IP 呢？还是将3个服务实例的 IP 都写在 S-A 的代码里，每次调用 S-B 时选择其中一个 IP？这样做显得很不灵活，这时我们想到了 Nginx 刚好就能很好的解决这个问题，引入 Nginx 后现在的架构变成了如下图这样： 引入 Nginx 后就解决了 S-B 部署多个实例的问题，还做了 S-B 实例间的负载均衡。但现在的架构又面临了新的问题，分布式系统往往要保证高可用以及能做到动态伸缩，在引入 Nginx 的架构中，假如当 S-B-1 服务实例不可用时，Nginx 仍然会向 S-B-1 分配请求，这样服务就不可用，我们想要的是 S-B-1 挂掉后 Nginx 就不再向其分配请求，以及当我们新部署了 S-B-4 和 S-B-5 后，Nginx 也能将请求分配到 S-B-4 和 S-B-5，Nginx 要做到这样就要在每次有服务实例变动时去更新配置文件再重启 Nginx。这样看似乎用了 Nginx 也很不舒服以及还需要人工去观察哪些服务有没有挂掉，Nginx 要是有对服务的健康检查以及能够动态变更服务配置就是我们想要的工具，这就是服务注册与服务发现工具的用处。下面是引入服务注册与服务发现工具后的架构图： 在这个架构中： 首先 S-B 的实例启动后将自身的服务信息（主要是服务所在的 IP 地址和端口号）注册到注册工具中。不同注册工具服务的注册方式各不相同，后文会讲 Consul 的具体注册方式。 服务将服务信息注册到注册工具后，注册工具就可以对服务做健康检查，以此来确定哪些服务实例可用哪些不可用。 S-A 启动后就可以通过服务注册和服务发现工具获取到所有健康的 S-B 实例的 IP 和端口，并将这些信息放入自己的内存中，S-A 就可用通过这些信息来调用 S-B。 S-A 可以通过监听（Watch）注册工具来更新存入内存中的 S-B 的服务信息。比如 S-B-1 挂了，健康检查机制就会将其标为不可用，这样的信息变动就被 S-A 监听到了，S-A 就更新自己内存中 S-B-1 的服务信息。 所以务注册与服务发现工具除了服务本身的服务注册和发现功能外至少还需要有健康检查和状态变更通知的功能。 Consul内部原理Consul 作为一种分布式服务工具，为了避免单点故障常常以集群的方式进行部署，在 Consul 集群的节点中分为 Server 和 Client 两种节点（所有的节点也被称为Agent），Server 节点保存数据，Client 节点负责健康检查及转发数据请求到 Server；Server 节点有一个 Leader 节点和多个 Follower 节点，Leader 节点会将数据同步到 Follower 节点，在 Leader 节点挂掉的时候会启动选举机制产生一个新的 Leader。 Client 节点很轻量且无状态，它以 RPC 的方式向 Server 节点做读写请求的转发，此外也可以直接向 Server 节点发送读写请求。下面是 Consul 的架构图： 首先Consul支持多数据中心，在上图中有两个DataCenter，他们通过Internet互联，同时请注意为了提高通信效率，只有Server节点才加入跨数据中心的通信。 在单个数据中心中，Consul分为Client和Server两种节点（所有的节点也被称为Agent），Server节点保存数据，Client负责健康检查及转发数据请求到Server；Server节点有一个Leader和多个Follower，Leader节点会将数据同步到Follower，Server的数量推荐是3个或者5个，在Leader挂掉的时候会启动选举机制产生一个新的Leader。 集群内的Consul节点通过gossip协议（流言协议）维护成员关系，也就是说某个节点了解集群内现在还有哪些节点，这些节点是Client还是Server。单个数据中心的流言协议同时使用TCP和UDP通信，并且都使用8301端口。跨数据中心的流言协议也同时使用TCP和UDP通信，端口使用8302。 集群内数据的读写请求既可以直接发到Server，也可以通过Client使用RPC转发到Server，请求最终会到达Leader节点，在允许数据轻微陈旧的情况下，读请求也可以在普通的Server节点完成，集群内数据的读写和复制都是通过TCP的8300端口完成。 Consul 的主要特点Service Discovery : 服务注册与发现，Consul 的客户端可以做为一个服务注册到 Consul，也可以通过 Consul 来查找特定的服务提供者，并且根据提供的信息进行调用。 Health Checking: Consul 客户端会定期发送一些健康检查数据和服务端进行通讯，判断客户端的状态、内存使用情况是否正常，用来监控整个集群的状态，防止服务转发到故障的服务上面。 KV Store: Consul 还提供了一个容易使用的键值存储。这可以用来保持动态配置，协助服务协调、建立 Leader 选举，以及开发者想构造的其它一些事务。 Secure Service Communication: Consul 可以为服务生成分布式的 TLS 证书，以建立相互的 TLS 连接。 可以使用 intentions 定义允许哪些服务进行通信。 可以使用 intentions 轻松管理服务隔离，而不是使用复杂的网络拓扑和静态防火墙规则。 Multi Datacenter: Consul 支持开箱即用的多数据中心，这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域。 Consul 角色 Server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其它数据中心通讯。 每个数据中心的 Server 数量推荐为 3 个或是 5 个。 Client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群。 Consul 旨在对 DevOps 社区和应用程序开发人员友好，使其成为现代、弹性基础架构的理想选择。 Consul 的调用过程 1、当 Producer 启动的时候，会向 Consul 发送一个 post 请求，告诉 Consul 自己的 IP 和 Port； 2、Consul 接收到 Producer 的注册后，每隔 10s（默认）会向 Producer 发送一个健康检查的请求，检验 Producer 是否健康； 3、当 Consumer 发送 GET 方式请求 /api/address 到 Producer 时，会先从 Consul 中拿到一个存储服务 IP 和 Port 的临时表，从表中拿到 Producer 的 IP 和 Port 后再发送 GET 方式请求 /api/address； 4、该临时表每隔 10s 会更新，只包含有通过了健康检查的 Producer。 Consul 和 eureka的对比 Consul服务发现原理 首先需要有一个正常的Consul集群，有Server，有Leader。这里在服务器Server1、Server2、Server3上分别部署了Consul Server，假设他们选举了Server2上的Consul Server节点为Leader。这些服务器上最好只部署Consul程序，以尽量维护Consul Server的稳定。 然后在服务器Server4和Server5上通过Consul Client分别注册Service A、B、C，这里每个Service分别部署在了两个服务器上，这样可以避免Service的单点问题。服务注册到Consul可以通过HTTP API（8500端口）的方式，也可以通过Consul配置文件的方式。Consul Client可以认为是无状态的，它将注册信息通过RPC转发到Consul Server，服务信息保存在Server的各个节点中，并且通过Raft实现了强一致性。 最后在服务器Server6中Program D需要访问Service B，这时候Program D首先访问本机Consul Client提供的HTTP API，本机Client会将请求转发到Consul Server，Consul Server查询到Service B当前的信息返回，最终Program D拿到了Service B的所有部署的IP和端口，然后就可以选择Service B的其中一个部署并向其发起请求了。如果服务发现采用的是DNS方式，则Program D中直接使用Service B的服务发现域名，域名解析请求首先到达本机DNS代理，然后转发到本机Consul Client，本机Client会将请求转发到Consul Server，Consul Server查询到Service B当前的信息返回，最终Program D拿到了Service B的某个部署的IP和端口。","categories":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"Consul","slug":"Consul","permalink":"http://www.lida1024.top/tags/Consul/"}]},{"title":"微服务常见的认证方案","slug":"微服务常见的认证方案","date":"2019-11-19T00:40:00.000Z","updated":"2020-01-01T03:14:03.700Z","comments":true,"path":"2019/11/19/微服务常见的认证方案/","link":"","permalink":"http://www.lida1024.top/2019/11/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88/","excerpt":"","text":"分布式Session传统的单体应用的session，在Spring cloud微服务架构下，可以采用分布式session机制，可以将用户的认证信息存储在共享存储（如redis）中，用户会话作为key实现简单的分布式哈希映射，当用户访问微服务时，用户数据可以从共享存储中获取。Spring Session对分布式Session提供了支持，也与Spring Boot/Cloud无缝集成。 API Tokens随着 Restful API、微服务的兴起，基于 Token 的认证现在已经相当普遍了。 Token一般会包含用户的相关信息，其它微服务可以从Token里提取出用户、权限等信息完成鉴权。 基于Token认证的典型流程： 用户使用包含用户名和密码的credential从客户端发起资源请求。 后端接受请求，通过授权中心，生产有效token字符串，返回给客户端。 客户端获得token后，再次发出资源请求。 后端接受带token的请求，通过授权中心，获取相关资源，返回给客户端。 优点： 服务端无状态：服务端不需要存储Session，因为Token已携带用户的相关信息 性能好：校验Token不需要访问远程服务或数据库 支持移动端 支持跨程序、跨域调用 缺点： 每次用户请求需要携带有效token，与Auth服务进行交互验证 Auth服务可能需要处理大量的生产token的操作，可能存在性能问题 基于Token的认证方案，业界推荐使用 JSON Web Tokens（JWT），它足够简单且支持程度也比较好","categories":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"token","slug":"token","permalink":"http://www.lida1024.top/tags/token/"}]},{"title":"Spring Cloud Feign使用详解","slug":"Spring-Cloud-Feign使用详解","date":"2019-11-19T00:35:00.000Z","updated":"2020-01-01T02:31:43.687Z","comments":true,"path":"2019/11/19/Spring-Cloud-Feign使用详解/","link":"","permalink":"http://www.lida1024.top/2019/11/19/Spring-Cloud-Feign%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"背景Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数、格式、地址等信息。而Feign则会完全代理HTTP请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理。Feign整合了Ribbon和Hystrix(关于Hystrix我们后面再讲)，可以让我们不再需要显式地使用这两个组件。 特点总起来说，Feign具有如下特性： 可插拔的注解支持，包括Feign注解和JAX-RS注解; 支持可插拔的HTTP编码器和解码器; 支持Hystrix和它的Fallback; 支持Ribbon的负载均衡; 支持HTTP请求和响应的压缩。 FeignClient注解的一些属性 快速开始1.引入Feign1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 2.@FeignClient注解SpringbootApplication启动类加上@FeignClient注解 12345678910111213141516import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class ServiceFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceFeignApplication.class, args); &#125;&#125;&#x2F;&#x2F;@EnableDiscoveryClient 和@EnableEurekaClient是等效的 3.yaml配置123456789eureka: client: serviceUrl: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;server: port: 8765spring: application: name: service-feign 4.Feign的使用feign接口 123456@FeignClient(value &#x3D; &quot;service-hi&quot;)public interface SchedualServiceHi &#123; @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;, method &#x3D; RequestMethod.GET) String sayHiFromClientOne(@RequestParam(&quot;name&quot;) String name);&#125; 访问接口 123456789101112@RestControllerpublic class HiController &#123; @Autowired SchedualServiceHi schedualServiceHi; @GetMapping(value &#x3D; &quot;&#x2F;hi&quot;) public String sayHi(@RequestParam String name)&#123; return schedualServiceHi.sayHiFromClientOne(name); &#125;&#125; 实战1.创建项目创建一个Maven项目feign，新建2个module service-hi和service-feign 2.service-hi pom 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; yml 1234567891011server: port: 8763spring: application: name: service-hieureka: client: serviceUrl: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F; ServiceHiApplication 12345678910111213141516171819@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient@RestControllerpublic class ServiceHiApplication &#123; public static void main(String[] args) &#123; SpringApplication.run( ServiceHiApplication.class, args ); &#125; @Value(&quot;$&#123;server.port&#125;&quot;) String port; @RequestMapping(&quot;&#x2F;hi&quot;) public String home(@RequestParam(value &#x3D; &quot;name&quot;, defaultValue &#x3D; &quot;forezp&quot;) String name) &#123; return &quot;hi &quot; + name + &quot; ,i am from port:&quot; + port; &#125;&#125; 3.service-feignpom 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; yml 123456789eureka: client: serviceUrl: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;server: port: 8765spring: application: name: service-feign ServiceFeignApplication 1234567891011@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient@EnableFeignClientspublic class ServiceFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceFeignApplication.class, args); &#125;&#125; SchedualServiceHi 123456@FeignClient(value &#x3D; &quot;service-hi&quot;)public interface SchedualServiceHi &#123; @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;, method &#x3D; RequestMethod.GET) String sayHiFromClientOne(@RequestParam(&quot;name&quot;) String name);&#125; HiController 123456789101112@RestControllerpublic class HiController &#123; @Autowired SchedualServiceHi schedualServiceHi; @GetMapping(value &#x3D; &quot;&#x2F;hi&quot;) public String sayHi(@RequestParam String name)&#123; return schedualServiceHi.sayHiFromClientOne(name); &#125;&#125; 测试启动eureka访问http://localhost:8761/启动service-hi刷新http://localhost:8761/访问service-hihttp://localhost:8763/hi?name=kobe启动service-feign刷新http://localhost:8761/同过feign访问接口http://localhost:8765/hi?name=KG可以看到去到了service-hi服务，端口8763","categories":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.lida1024.top/tags/SpringCloud/"}]},{"title":"java线程创建全家桶","slug":"Java线程创建全家桶","date":"2019-09-16T05:52:00.000Z","updated":"2020-01-01T02:31:03.845Z","comments":true,"path":"2019/09/16/Java线程创建全家桶/","link":"","permalink":"http://www.lida1024.top/2019/09/16/Java%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%85%A8%E5%AE%B6%E6%A1%B6/","excerpt":"","text":"继承Thread类12345678910111213141516171819&#x2F;&#x2F;继承Threadpublic class ExtendThread extends Thread&#123; &#x2F;&#x2F;线程执行体 @Override public void run() &#123; &#x2F;&#x2F;do something System.out.println(&quot;继承Thread创建线程&quot;); &#x2F;&#x2F;无返回值 &#125;&#125;public class ThreadCreateDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建一个线程 ExtendThread extendThread &#x3D; new ExtendThread(); &#x2F;&#x2F;调用start方法启动线程 extendThread.start(); &#x2F;&#x2F;没有返回值 &#125;&#125; 使用继承Thread类的方法来创建线程类时候，多个线程之间是无法共享线程类的实例变量的。 实现Runnable接口覆写Runnable接口实现多线程可以避免单继承局限， 当子类实现Runnable接口，此时子类和Thread的代理模式（子类负责真实业务的操作，thread负责资源调度与线程创建辅助真实业务）。 123456789101112131415161718&#x2F;&#x2F;实现Runnable接口public class ImplRunnable implements Runnable &#123; &#x2F;&#x2F;线程实行体 @Override public void run() &#123; &#x2F;&#x2F;do something System.out.println(&quot;实现Runnable创建线程&quot;); &#x2F;&#x2F;没有返回值 &#125;&#125;public class ThreadCreateDemo &#123; public static void main(String[] args) &#123; ImplRunnable implRunnable &#x3D; new ImplRunnable(); Thread thread &#x3D; new Thread(implRunnable); &#x2F;&#x2F;启动线程 thread.start(); &#125;&#125; Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run方法仅仅作为线程的执行体，而实际的线程对象依旧是Thread实例，只是该Thread线程负责执行器target的方法。 覆写Callable接口1234567891011121314151617181920&#x2F;&#x2F;实现Callable返回值类型为Integer类型public class ImplCallable implements Callable&lt;Integer&gt; &#123; &#x2F;&#x2F;该call()方法将作为线程执行体，并且有返回值 @Override public Integer call() throws Exception &#123; &#x2F;&#x2F;do something System.out.println(&quot;实现Callable接口创建线程，返回类型为Integer类型&quot;); return 999; &#125;&#125;public class ThreadCreateDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; Callable&lt;Integer&gt; callable &#x3D; new ImplCallable(); FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(callable); Thread thread &#x3D; new Thread(futureTask); thread.start(); &#x2F;&#x2F;获取返回值futureTask.get() System.out.println(futureTask.get()); &#125;&#125; Callable接口有泛型限制，Callable接口里的泛型形参类型与call方法返回值类型相同，而且Callable接口是函数式接口，因此可以使用Lambda表达式创建Callable对象。 三种方式的对比通过继承Thread类或者实现Runnable接口、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callabl接口里定义的方法返回值，可以声明抛出异常而已。因此将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。 采用实现Runnable、Callable接口的方式创建线程的优缺点优点线程类只是实现了Runnable或者Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想。缺点编程稍微复杂一些，如果需要访问当前线程，则必须使用Thread.currentThread()方法 采用继承Thread类的方式创建线程的优缺点缺点因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。 优点编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获取当前线程","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"http://www.lida1024.top/tags/Thread/"}]},{"title":"Java下载文件的几种方式 ","slug":"Java下载文件的几种方式","date":"2019-09-12T01:54:00.000Z","updated":"2019-12-21T07:11:51.658Z","comments":true,"path":"2019/09/12/Java下载文件的几种方式/","link":"","permalink":"http://www.lida1024.top/2019/09/12/Java%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"以流的方式下载1234567891011121314151617181920212223242526272829public HttpServletResponse download(String path, HttpServletResponse response) &#123; try &#123; &#x2F;&#x2F; path是指欲下载的文件的路径。 File file &#x3D; new File(path); &#x2F;&#x2F; 取得文件名。 String filename &#x3D; file.getName(); &#x2F;&#x2F; 取得文件的后缀名。 String ext &#x3D; filename.substring(filename.lastIndexOf(&quot;.&quot;) + 1).toUpperCase(); &#x2F;&#x2F; 以流的形式下载文件。 InputStream fis &#x3D; new BufferedInputStream(new FileInputStream(path)); byte[] buffer &#x3D; new byte[fis.available()]; fis.read(buffer); fis.close(); &#x2F;&#x2F; 清空response response.reset(); &#x2F;&#x2F; 设置response的Header response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename&#x3D;&quot; + new String(filename.getBytes())); response.addHeader(&quot;Content-Length&quot;, &quot;&quot; + file.length()); OutputStream toClient &#x3D; new BufferedOutputStream(response.getOutputStream()); response.setContentType(&quot;application&#x2F;octet-stream&quot;); toClient.write(buffer); toClient.flush(); toClient.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return response; &#125; 下载本地文件1234567891011121314151617181920public void downloadLocal(HttpServletResponse response) throws FileNotFoundException &#123; &#x2F;&#x2F; 下载本地文件 String fileName &#x3D; &quot;Operator.doc&quot;.toString(); &#x2F;&#x2F; 文件的默认保存名 &#x2F;&#x2F; 读到流中 InputStream inStream &#x3D; new FileInputStream(&quot;c:&#x2F;Operator.doc&quot;);&#x2F;&#x2F; 文件的存放路径 &#x2F;&#x2F; 设置输出的格式 response.reset(); response.setContentType(&quot;bin&quot;); response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;\\&quot;&quot; + fileName + &quot;\\&quot;&quot;); &#x2F;&#x2F; 循环取出流中的数据 byte[] b &#x3D; new byte[100]; int len; try &#123; while ((len &#x3D; inStream.read(b)) &gt; 0) response.getOutputStream().write(b, 0, len); inStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 下载网络文件12345678910111213141516171819202122232425public void downloadNet(HttpServletResponse response) throws MalformedURLException &#123; &#x2F;&#x2F; 下载网络文件 int bytesum &#x3D; 0; int byteread &#x3D; 0; URL url &#x3D; new URL(&quot;windine.blogdriver.com&#x2F;logo.gif&quot;); try &#123; URLConnection conn &#x3D; url.openConnection(); InputStream inStream &#x3D; conn.getInputStream(); FileOutputStream fs &#x3D; new FileOutputStream(&quot;c:&#x2F;abc.gif&quot;); byte[] buffer &#x3D; new byte[1204]; int length; while ((byteread &#x3D; inStream.read(buffer)) !&#x3D; -1) &#123; bytesum +&#x3D; byteread; System.out.println(bytesum); fs.write(buffer, 0, byteread); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 支持在线打开的方式1234567891011121314151617181920212223242526public void downLoad(String filePath, HttpServletResponse response, boolean isOnLine) throws Exception &#123; File f &#x3D; new File(filePath); if (!f.exists()) &#123; response.sendError(404, &quot;File not found!&quot;); return; &#125; BufferedInputStream br &#x3D; new BufferedInputStream(new FileInputStream(f)); byte[] buf &#x3D; new byte[1024]; int len &#x3D; 0; response.reset(); &#x2F;&#x2F; 非常重要 if (isOnLine) &#123; &#x2F;&#x2F; 在线打开方式 URL u &#x3D; new URL(&quot;file:&#x2F;&#x2F;&#x2F;&quot; + filePath); response.setContentType(u.openConnection().getContentType()); response.setHeader(&quot;Content-Disposition&quot;, &quot;inline; filename&#x3D;&quot; + f.getName()); &#x2F;&#x2F; 文件名应该编码成UTF-8 &#125; else &#123; &#x2F;&#x2F; 纯下载方式 response.setContentType(&quot;application&#x2F;x-msdownload&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;&quot; + f.getName()); &#125; OutputStream out &#x3D; response.getOutputStream(); while ((len &#x3D; br.read(buf)) &gt; 0) out.write(buf, 0, len); br.close(); out.close(); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"file","slug":"file","permalink":"http://www.lida1024.top/tags/file/"}]},{"title":"SpringMVC请求参数获取的几种方法","slug":"SpringMVC请求参数获取的几种方法","date":"2019-08-15T03:08:00.000Z","updated":"2020-01-01T03:51:31.244Z","comments":true,"path":"2019/08/15/SpringMVC请求参数获取的几种方法/","link":"","permalink":"http://www.lida1024.top/2019/08/15/SpringMVC%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"SpringMVC请求参数获取的几种方法 通过@PathVariabl获取路径中的参数12345678@RequestMapping(value&#x3D;&quot;user&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&quot;,method&#x3D;RequestMethod.GET)public String printMessage1(@PathVariable String id,@PathVariable String name, ModelMap model) &#123; System.out.println(id); System.out.println(name); model.addAttribute(&quot;message&quot;, &quot;111111&quot;); return &quot;users&quot;;&#125; 例如，访问user/123/lei路径时，执行以上方法，其中，参数id=123，name=lei @ModelAttribute获取POST请求的FORM表单数据表单如下 12345&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;hao.do&quot;&gt; a: &lt;input id&#x3D;&quot;a&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;a&quot;&#x2F;&gt; b: &lt;input id&#x3D;&quot;b&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;b&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot; &#x2F;&gt;&lt;&#x2F;form&gt; Java Pojo如下 1234public class Pojo&#123; private String a; private int b;&#125; Java Controller如下 12345@RequestMapping(method &#x3D; RequestMethod.POST) public String processSubmit(@ModelAttribute(&quot;pojo&quot;) Pojo pojo) &#123; return &quot;helloWorld&quot;; &#125; @RequestBody获取POST请求的FORM表单数据@RequestBody接收的是一个Json对象的字符串，而不是一个Json对象。然而在ajax请求往往传的都是Json对象，后来发现用 JSON.stringify(data)的方式就能将对象变成字符串。同时ajax请求的时候也要指定dataType: &quot;json&quot;,contentType:&quot;application/json&quot;这样就可以轻易的将一个对象或者List传到Java端，使用@RequestBody即可绑定对象或者List. js代码 123456789101112131415161718&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; $(document).ready(function()&#123; var saveDataAry&#x3D;[]; var data1&#x3D;&#123;&quot;userName&quot;:&quot;test&quot;,&quot;address&quot;:&quot;gz&quot;&#125;; var data2&#x3D;&#123;&quot;userName&quot;:&quot;ququ&quot;,&quot;address&quot;:&quot;gr&quot;&#125;; saveDataAry.push(data1); saveDataAry.push(data2); $.ajax(&#123; type:&quot;POST&quot;, url:&quot;user&#x2F;saveUser&quot;, dataType:&quot;json&quot;, contentType:&quot;application&#x2F;json&quot;, data:JSON.stringify(saveData), success:function(data)&#123; &#125; &#125;); &#125;); java代码 12345@RequestMapping(value &#x3D; &quot;saveUser&quot;, method &#x3D; &#123;RequestMethod.POST &#125;&#125;) @ResponseBody public void saveUser(@RequestBody List&lt;User&gt; users) &#123; userService.batchSave(users); &#125; @ModelAttribute和@RequestBody注解不同之处在于@ModelAttribute注解可以在前端直接获取返回值 123456789@Controllerpublic class Hello2ModelController extends BaseController &#123; @RequestMapping(value &#x3D; &quot;&#x2F;helloWorld2&quot;) public String helloWorld(@ModelAttribute(&quot;myUser&quot;) User user) &#123; user.setName(&quot;老王&quot;); return &quot;helloWorld&quot;; &#125; &#125; model中key为myUser ,前台可以直接通过${myUser.xx}获取user相应属性 直接用HttpServletRequest获取12345@RequestMapping(method &#x3D; RequestMethod.GET) public String get(HttpServletRequest request, HttpServletResponse response) &#123; System.out.println(request.getParameter(&quot;a&quot;)); return &quot;helloWorld&quot;; &#125; 用注解@RequestParam绑定请求参数用注解@RequestParam绑定请求参数a到变量a 当请求参数a不存在时会有异常发生,可以通过设置属性required=false解决, 例如: @RequestParam(value=&quot;a&quot;, required=false) Controller如下 12345@RequestMapping(value &#x3D; &quot;&#x2F;requestParam&quot;, method &#x3D; RequestMethod.GET) public String setupForm(@RequestParam(&quot;a&quot;) String a, ModelMap model) &#123; System.out.println(a); return &quot;helloWorld&quot;;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.lida1024.top/tags/Spring/"}],"author":"Monday"},{"title":"SpringBoot使用Undertow代替tomcat","slug":"SpringBoot使用Undertow代替tomcat","date":"2019-08-14T07:56:00.000Z","updated":"2020-01-01T02:31:35.451Z","comments":true,"path":"2019/08/14/SpringBoot使用Undertow代替tomcat/","link":"","permalink":"http://www.lida1024.top/2019/08/14/SpringBoot%E4%BD%BF%E7%94%A8Undertow%E4%BB%A3%E6%9B%BFtomcat/","excerpt":"","text":"Undertow 是基于java nio的web服务器，应用比较广泛，内置提供的PathResourceManager，可以用来直接访问文件系统；如果你有文件需要对外提供访问，除了ftp,nginx等，undertow 也是一个不错的选择，作为java开发，服务搭建非常简便 Undertow使用依赖spring boot内嵌容器默认为tomcat，想要换成undertow，非常容易，只需修改spring-boot-starter-web依赖，移除tomcat的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt; &lt;&#x2F;dependency&gt; 然后，添加undertow依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 这样即可，使用默认参数启动undertow服务器。如果需要修改undertow参数，继续往下看。 undertow的参数设置：12345678910server: port: 8084 http2: enabled: true undertow: io-threads: 16 worker-threads: 256 buffer-size: 1024 buffers-per-region: 1024 direct-buffers: true io-threads：IO线程数, 它主要执行非阻塞的任务，它们会负责多个连接，默认设置每个CPU核心一个线程，不可设置过大，否则启动项目会报错：打开文件数过多。 worker-threads：阻塞任务线程池，当执行类似servlet请求阻塞IO操作，undertow会从这个线程池中取得线程。它的值取决于系统线程执行任务的阻塞系数，默认值是 io-threads*8 以下配置会影响buffer，这些buffer会用于服务器连接的IO操作，有点类似netty的池化内存管理。 buffer-size：每块buffer的空间大小，越小的空间被利用越充分，不要设置太大，以免影响其他应用，合适即可 buffers-per-region：每个区分配的buffer数量，所以pool的大小是buffer-size * buffers-per-region direct-buffers：是否分配的直接内存(NIO直接分配的堆外内存) File Server12345678910111213141516import java.io.File;import io.undertow.Handlers;import io.undertow.Undertow;import io.undertow.server.handlers.resource.PathResourceManager;public class FileServer &#123; public static void main(String[] args) &#123; File file &#x3D; new File(&quot;&#x2F;&quot;); Undertow server &#x3D; Undertow.builder().addHttpListener(8080, &quot;localhost&quot;) .setHandler(Handlers.resource(new PathResourceManager(file.toPath(), 100)) .setDirectoryListingEnabled(true)) .build(); server.start(); &#125;&#125; 好了！运行main函数，打开浏览器访问 http://localhost:8080","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.lida1024.top/tags/SpringBoot/"}]},{"title":"Spring Boot - Undertow容器启动","slug":"Spring-Boot-Undertow容器启动","date":"2019-08-14T07:00:00.000Z","updated":"2020-01-01T02:31:19.307Z","comments":true,"path":"2019/08/14/Spring-Boot-Undertow容器启动/","link":"","permalink":"http://www.lida1024.top/2019/08/14/Spring-Boot-Undertow%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8/","excerpt":"","text":"Undertow简介 Undertow 是红帽公司开发的一款基于 NIO 的高性能 Web 嵌入式服务器 Untertow 的特点：轻量级：它是一个 Web 服务器，但不像传统的 Web 服务器有容器概念，它由两个核心 Jar 包组成，加载一个 Web 应 用可以小于 10MB 内存 Servlet3.1 支持：它提供了对 Servlet3.1 的支持 WebSocket 支持：对 Web Socket 完全支持，用以满足 Web 应用巨大数量的客户端 嵌套性：它不需要容器，只需通过 API 即可快速搭建 Web 服务器 默认情况下 Spring Cloud 使用 Tomcat 作为内嵌 Servlet 容器，可启动一个 Tomcat 的 Spring Boot 程序与一个 Undertow 的 Spring Boot 程序，通过 VisualVM 工具进行比较，可看到 Undertow 性能优于 Tomcat 使用 Undertow添加依赖1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 支持 HTTP21234567891011&#x2F;&#x2F; 在@Configuration的类中添加@bean@BeanUndertowEmbeddedServletContainerFactory embeddedServletContainerFactory() &#123; UndertowEmbeddedServletContainerFactory factory &#x3D; new UndertowEmbeddedServletContainerFactory(); &#x2F;&#x2F; 这里也可以做其他配置 factory.addBuilderCustomizers(builder -&gt; builder.setServerOption(UndertowOptions.ENABLE_HTTP2, true)); return factory;&#125; 配置 Undertow1234567891011121314151617181920212223# Undertow 日志存放目录server.undertow.accesslog.dir# 是否启动日志server.undertow.accesslog.enabled&#x3D;false # 日志格式server.undertow.accesslog.pattern&#x3D;common# 日志文件名前缀server.undertow.accesslog.prefix&#x3D;access_log# 日志文件名后缀server.undertow.accesslog.suffix&#x3D;log# HTTP POST请求最大的大小server.undertow.max-http-post-size&#x3D;0 # 设置IO线程数, 它主要执行非阻塞的任务,它们会负责多个连接, 默认设置每个CPU核心一个线程server.undertow.io-threads&#x3D;4# 阻塞任务线程池, 当执行类似servlet请求阻塞操作, undertow会从这个线程池中取得线程,它的值设置取决于系统的负载server.undertow.worker-threads&#x3D;20# 以下的配置会影响buffer,这些buffer会用于服务器连接的IO操作,有点类似netty的池化内存管理# 每块buffer的空间大小,越小的空间被利用越充分server.undertow.buffer-size&#x3D;1024# 每个区分配的buffer数量 , 所以pool的大小是buffer-size * buffers-per-regionserver.undertow.buffers-per-region&#x3D;1024# 是否分配的直接内存server.undertow.direct-buffers&#x3D;true","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.lida1024.top/tags/SpringBoot/"}]},{"title":"前后端分离后的优雅部署","slug":"后端分离后的优雅部署","date":"2019-08-12T01:34:00.000Z","updated":"2020-01-01T03:53:44.158Z","comments":true,"path":"2019/08/12/后端分离后的优雅部署/","link":"","permalink":"http://www.lida1024.top/2019/08/12/%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%90%8E%E7%9A%84%E4%BC%98%E9%9B%85%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Web项目部署容器的选取目前常用的部署Web项目的容器用Tomcat、Apache、Nginx等，那我们前后端分离后的前端Html静态项目到底部署在那个应用容器呢？我们先看看这几个应用容器的区别。 Nginx,Apache,Tomcat的区别： Nginx常用做静态内容服务和代理服务器，直接外来请求转发给后面的应用服务器（如tomcat）,而tomcat更多用来做一个应用容器。 Apache和nginx应该叫做HTTP Server，而tomcat是一个Application Server是一个Servlet/JSO应用的容器。 HTTP Server访问服务器上存储的资源（HTML文件，图片文件等），HTTP Server是中只是把服务器上的文件如实通过HTTP协议传输给客户端。 Application Server（应用服务器）往往是运行在HTTP Server的背后并执行应用，将动态的内容转化为静态的内容之后，通过HTTP Server分发到客户端。 Apache是同步多进程模型，一个连接对应一个进程，而nginx是一步的，多个连接（万级别）可以对应一个进程。nginx轻量级，抗并发，处理静态文件好。 根据对比，我们不难发现Nginx是较好的选择，它是由俄罗斯人（伊戈尔·赛索耶夫）开发的一款高性能的HTTP和反向代理web服务器。本身是轻量级、抗并发、能实现万级的连接等。同时它也是一个反向代理服务器。因此，我们不仅可以用它部署静态的html应用，还可以实现域名及访问地址的代理。 Nginx部署前端Web项目Nginx的安装这里不做介绍，只说配置及部署相关内容。首先进入linux系统中Nginx的安装录的conf目录下，找到nginx.config配置文件，vim nginx.config进入编辑模式，在http下的server对应的同级编辑或添加如下代码，然后在root对应的目录下上传对应的html今天项目文件。注意：这里上传的如果是压缩包就需要解压，目录下要有index.html。 12345678server &#123; listen 80; server_name www.xxxx.com; location &#x2F; &#123; root html&#x2F;; #html访问路径 index index.html; &#125;&#125; 但我们的实际项目中，经常有多个Web端需要部署，如前面图中的例子，Web端有PC商城和Web后台系统，甚至可能更多，这些多个Web静态项目我们都放在nginx的html目录下的不同文件夹里，然后通过域名或ip+port代理到对应目录。下面就是多个Web项目在Nginx里的配置。 123456789101112131415161718##商城Html页面server &#123; listen 80; server_name www.xxxx.com; location &#x2F; &#123; root html&#x2F;pc&#x2F;; #html访问路径 index index.html; &#125;&#125;##后台系统Html页面server &#123; listen 80; server_name admin.xxxx.com; location &#x2F; &#123; root html&#x2F;admin&#x2F;; #html访问路径 index index.html; &#125;&#125; 编辑完成后保存，并重启nginx服务 service nginx restart。注：server_name 这里可配置域名或ip+端口号。 后端项目的部署大家应该都知道，SpringBoot里集成了Tomcat容器，所有Springboot的项目部署，很是容易，根本不需要你还安装什么Tomcat、JBoss等应用。我们只需打成jar文件，上传到服务器，然后通过执行java -jar xxx.jar &amp;命令即可。但有没有人遇到过，你通过java -jar xxx.jar &amp;刚刚部署的服务，在你断开linux服务器的shell连接后服务就没了。大家有知道这是什么原因吗？这里给大家说说部署java jar文件命令的那点事。 java -jar xxx.jar &amp; 此命令可直接启动jar文件，是在当前会话进程中开启一个子进程来运行程序，这个子进程会随着会话进程的结束而结束。也就是说在你端口Shell连接回话结束，服务就跟着结束了。这种情况适合短时间测试用。 nohup java -jar xxx.jar &amp; 这里在说这个命令前先说两个名词，即：hangup (挂断)，终端退出时会发送 hangup 信号来通知关闭所有子进程。nohup(不挂断，忽略挂断信号) nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上”&amp;”来将命令同时放入后台运行，也可用”&gt;filename2&gt;&amp;1”来更改缺省的重定向文件名。这种情况适合在生产环境长时间运行。 在生产环境如果你只用简单的jar部署，那一定得用nohup java 命令启动应用。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://www.lida1024.top/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"springboot逆向工程","slug":"springboot逆向工程","date":"2019-07-27T01:45:00.000Z","updated":"2020-01-01T02:31:27.845Z","comments":true,"path":"2019/07/27/springboot逆向工程/","link":"","permalink":"http://www.lida1024.top/2019/07/27/springboot%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"通过逆向工程少写很多代码 generatorConfig.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--mysql 连接数据库jar 这里选择自己本地位置--&gt; &lt;classPathEntry location&#x3D;&quot;C:\\Users\\Administrator\\.m2\\repository\\mysql\\mysql-connector-java\\5.1.21\\mysql-connector-java-5.1.21.jar&quot; &#x2F;&gt; &lt;context id&#x3D;&quot;testTables&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name&#x3D;&quot;suppressAllComments&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass&#x3D;&quot;com.mysql.jdbc.Driver&quot; connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;oa&quot; userId&#x3D;&quot;root&quot; password&#x3D;&quot;&quot;&gt; &lt;&#x2F;jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage&#x3D;&quot;com.yj.oa.project.po&quot; targetProject&#x3D;&quot;src&#x2F;test&#x2F;java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 如果maven工程只是单独的一个工程，targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot; 若果maven工程是分模块的工程，targetProject&#x3D;&quot;所属模块的名称&quot;，例如： targetProject&#x3D;&quot;ecps-manager-mapper&quot;，下同--&gt; &lt;sqlMapGenerator targetPackage&#x3D;&quot;mapper&quot; targetProject&#x3D;&quot;src&#x2F;test&#x2F;java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot; targetPackage&#x3D;&quot;com.yj.oa.project.mapper&quot; targetProject&#x3D;&quot;src&#x2F;test&#x2F;java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName&#x3D;&quot;t_overtimeform&quot; domainObjectName&#x3D;&quot;OvertimeForm&quot; enableCountByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot; enableSelectByExample&#x3D;&quot;false&quot; selectByExampleQueryId&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt; &lt;&#x2F;context&gt;&lt;&#x2F;generatorConfiguration&gt; pom.xml12345678910111213141516171819202122232425&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.2&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml&lt;&#x2F;configurationFile&gt; &lt;verbose&gt;true&lt;&#x2F;verbose&gt; &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt; &lt;&#x2F;configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;&#x2F;id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;&#x2F;goal&gt; &lt;&#x2F;goals&gt; &lt;&#x2F;execution&gt; &lt;&#x2F;executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;plugin&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.lida1024.top/tags/SpringBoot/"}]},{"title":"自己实现一个简单版的HashMap","slug":"自己实现一个简单版的HashMap","date":"2019-07-26T03:54:00.000Z","updated":"2020-01-01T02:32:02.681Z","comments":true,"path":"2019/07/26/自己实现一个简单版的HashMap/","link":"","permalink":"http://www.lida1024.top/2019/07/26/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%89%88%E7%9A%84HashMap/","excerpt":"","text":"HashMap简介HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 简单版，只实现put和get12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MyHashMap&lt;K, V&gt; &#123; private static int default_length &#x3D; 16; private MyEntry&lt;K, V&gt;[] entries; public MyHashMap() &#123; super(); entries &#x3D; new MyEntry[default_length]; &#125; public V put(K key, V value) &#123; int index &#x3D; key.hashCode() % default_length;&#x2F;&#x2F; hascode值除map大小取余 MyEntry&lt;K, V&gt; prevoius &#x3D; entries[index]; for (MyEntry&lt;K, V&gt; entry &#x3D; entries[index]; entry !&#x3D; null; entry &#x3D; entry.next) &#123; if (entry.getKey().equals(key)) &#123; V oldValue &#x3D; (V) entry.getValue(); entry.setValue(value); return oldValue; &#125; &#125; MyEntry&lt;K, V&gt; entry &#x3D; new MyEntry&lt;&gt;(key, value); entry.next &#x3D; prevoius; entries[index] &#x3D; entry; return null; &#125; public K get(K key)&#123; int index&#x3D; key.hashCode()%default_length; for (MyEntry&lt;K,V&gt; entry&#x3D; entries[index];entry!&#x3D;null;entry&#x3D;entry.next)&#123; if(entry.getKey().equals(key))&#123; return (K)entry.getValue(); &#125; &#125; return null; &#125; private final class MyEntry&lt;K, V&gt; &#123; private K key; private V value; private MyEntry next; public MyEntry() &#123; super(); &#125; public MyEntry(K key, V value) &#123; super(); this.key &#x3D; key; this.value &#x3D; value; &#125; public MyEntry(K key, V value, MyEntry next) &#123; super(); this.key &#x3D; key; this.value &#x3D; value; this.next &#x3D; next; &#125; public K getKey() &#123; return key; &#125; public void setKey(K key) &#123; this.key &#x3D; key; &#125; public V getValue() &#123; return value; &#125; public void setValue(V value) &#123; this.value &#x3D; value; &#125; public MyEntry getNext() &#123; return next; &#125; public void setNext(MyEntry next) &#123; this.next &#x3D; next; &#125; &#125;&#125; 复杂版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178public class MyHashMap &#123; &#x2F;&#x2F;默认初始化大小 16 private static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16; &#x2F;&#x2F;默认负载因子 0.75 private static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f; &#x2F;&#x2F;临界值 private int threshold; &#x2F;&#x2F;元素个数 private int size; &#x2F;&#x2F;扩容次数 private int resize; private MyEntry[] table; public MyHashMap() &#123; table &#x3D; new MyEntry[DEFAULT_INITIAL_CAPACITY]; threshold &#x3D; (int) (DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); size &#x3D; 0; &#125; private int index(Object key) &#123; &#x2F;&#x2F;根据key的hashcode和entry长度取模计算key在entry中的位置 return key.hashCode() % table.length; &#125; public void put(Object key, Object value) &#123; &#x2F;&#x2F;key为null时需要特殊处理，为简化实现忽略null值 if (key &#x3D;&#x3D; null) return; int index &#x3D; index(key); &#x2F;&#x2F;遍历index位置的entry，若找到重复key则更新对应entry的值，然后返回 MyEntry entry &#x3D; table[index]; while (entry !&#x3D; null) &#123; if (entry.getKey().hashCode() &#x3D;&#x3D; key.hashCode() &amp;&amp; (entry.getKey() &#x3D;&#x3D; key || entry.getKey().equals(key))) &#123; entry.setValue(value); return; &#125; entry &#x3D; entry.getNext(); &#125; &#x2F;&#x2F;若index位置没有entry或者未找到重复的key，则将新key添加到table的index位置 add(index, key, value); &#125; private void add(int index, Object key, Object value) &#123; &#x2F;&#x2F;将新的entry放到table的index位置第一个，若原来有值则以链表形式存放 MyEntry entry &#x3D; new MyEntry(key, value, table[index]); table[index] &#x3D; entry; &#x2F;&#x2F;判断size是否达到临界值，若已达到则进行扩容，将table的capacicy翻倍 if (size++ &gt;&#x3D; threshold) &#123; resize(table.length * 2); &#125; &#125; private void resize(int capacity) &#123; if (capacity &lt;&#x3D; table.length) return; MyEntry[] newTable &#x3D; new MyEntry[capacity]; &#x2F;&#x2F;遍历原table，将每个entry都重新计算hash放入newTable中 for (int i &#x3D; 0; i &lt; table.length; i++) &#123; MyEntry old &#x3D; table[i]; while (old!&#x3D;null)&#123; MyEntry next &#x3D; old.getNext(); int index &#x3D; index(old.getKey()); old.setNext(newTable[index]); newTable[index] &#x3D; old; old&#x3D;next; &#125; &#125; &#x2F;&#x2F;用newTable替table table &#x3D; newTable; &#x2F;&#x2F;修改临界值 threshold &#x3D; (int) (table.length * DEFAULT_LOAD_FACTOR); resize++; &#125; public Object get(Object key)&#123; &#x2F;&#x2F;这里简化处理，忽略null值 if (key &#x3D;&#x3D; null) return null; MyEntry entry&#x3D; getEntry(key); return entry &#x3D;&#x3D; null ? null : entry.getValue(); &#125; public MyEntry getEntry(Object key)&#123; MyEntry entry &#x3D;table[index(key)]; while (entry!&#x3D;null)&#123; if (entry.getKey().hashCode()&#x3D;&#x3D;key.hashCode()&amp;&amp;(entry.getKey()&#x3D;&#x3D;key||entry.getKey().equals(key)))&#123; return entry; &#125; entry &#x3D; entry.getNext(); &#125; return entry; &#125; public void remove(Object key) &#123; if (key &#x3D;&#x3D; null) return; int index &#x3D; index(key); MyEntry pre &#x3D; null; MyEntry entry &#x3D; table[index]; while (entry !&#x3D; null) &#123; if (entry.getKey().hashCode() &#x3D;&#x3D; key.hashCode() &amp;&amp; (entry.getKey() &#x3D;&#x3D; key || entry.getKey().equals(key))) &#123; if (pre &#x3D;&#x3D; null) table[index] &#x3D; entry.getNext(); else pre.setNext(entry.getNext()); &#x2F;&#x2F;如果成功找到并删除，修改size size--; return; &#125; pre &#x3D; entry; entry &#x3D; entry.getNext(); &#125; &#125; public boolean containsKey(Object key) &#123; if (key &#x3D;&#x3D; null) return false; return getEntry(key) !&#x3D; null; &#125; public int size() &#123; return this.size; &#125; public void clear() &#123; for (int i &#x3D; 0; i &lt; table.length; i++) &#123; table[i] &#x3D; null; &#125; this.size &#x3D; 0; &#125; @Override public String toString() &#123; StringBuilder sb &#x3D; new StringBuilder(); sb.append(String.format(&quot;size:%s capacity:%s resize:%s\\n\\n&quot;, size, table.length, resize)); for (MyEntry entry : table) &#123; while (entry !&#x3D; null) &#123; sb.append(entry.getKey() + &quot;:&quot; + entry.getValue() + &quot;\\n&quot;); entry &#x3D; entry.getNext(); &#125; &#125; return sb.toString(); &#125;&#125; final class MyEntry &#123; private Object key; private Object value; private MyEntry next; public MyEntry(Object key, Object value, MyEntry next) &#123; this.key &#x3D; key; this.value &#x3D; value; this.next &#x3D; next; &#125; public Object getKey() &#123; return key; &#125; public void setKey(Object key) &#123; this.key &#x3D; key; &#125; public Object getValue() &#123; return value; &#125; public void setValue(Object value) &#123; this.value &#x3D; value; &#125; public MyEntry getNext() &#123; return next; &#125; public void setNext(MyEntry next) &#123; this.next &#x3D; next; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://www.lida1024.top/tags/HashMap/"}]},{"title":"GSON搞定任何JSON数据","slug":"GSON搞定任何JSON数据","date":"2019-07-26T03:41:00.000Z","updated":"2019-12-21T07:11:31.577Z","comments":true,"path":"2019/07/26/GSON搞定任何JSON数据/","link":"","permalink":"http://www.lida1024.top/2019/07/26/GSON%E6%90%9E%E5%AE%9A%E4%BB%BB%E4%BD%95JSON%E6%95%B0%E6%8D%AE/","excerpt":"","text":"一、Gson介绍GSON是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个Json字符转成一个Java对象，或者将一个Java转化为Json字符串。 特点: 快速、高效 代码量少、简洁 面向对象 数据传递和解析 二、Gson的pom依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;&#x2F;groupId&gt; &lt;artifactId&gt;gson&lt;&#x2F;artifactId&gt; &lt;version&gt;2.8.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 三、Gson的创建方式 Gson gson = new gson(); 通过GsonBuilder()，可以配置多种配置。 1234567Gson gson &#x3D; new GsonBuilder() .setLenient()&#x2F;&#x2F; json宽松 .enableComplexMapKeySerialization()&#x2F;&#x2F;支持Map的key为复杂对象的形式 .serializeNulls() &#x2F;&#x2F;智能null .setPrettyPrinting()&#x2F;&#x2F; 调教格式 .disableHtmlEscaping() &#x2F;&#x2F;默认是GSON把HTML 转义的 .create(); 四、Gson的基本用法之前写过一个获取天气参数的API,就需要去解析返回的json数据，就以此为例。 12String url &#x3D; &quot;http:&#x2F;&#x2F;t.weather.sojson.com&#x2F;api&#x2F;weather&#x2F;city&#x2F;101010100&quot;;String resultStr &#x3D; HttpClientUtil.sendGetRequest(url, &quot;UTF-8&quot;); 五、进行解析123Gson gson &#x3D;new Gson();Map m&#x3D; gson.fromJson(resultStr,Map.class);System.out.println(m.get(&quot;data&quot;)); 结果 123456789101112131415&#123;shidu&#x3D;15%, pm25&#x3D;15.0, pm10&#x3D;35.0, quality&#x3D;优, wendu&#x3D;3, ganmao&#x3D;各类人群可自由活动, yesterday&#x3D;&#123;date&#x3D;06, sunrise&#x3D;07:36, high&#x3D;高温 3.0℃, low&#x3D;低温 -7.0℃, sunset&#x3D;17:03, aqi&#x3D;58.0, ymd&#x3D;2019-01-06, week&#x3D;星期日, fx&#x3D;西南风, fl&#x3D;&lt;3级, type&#x3D;晴, notice&#x3D;愿你拥有比阳光明媚的心情&#125;, forecast&#x3D;[&#123;date&#x3D;07, sunrise&#x3D;07:36, high&#x3D;高温 2.0℃, low&#x3D;低温 -7.0℃, sunset&#x3D;17:04, aqi&#x3D;48.0, ymd&#x3D;2019-01-07, week&#x3D;星期一, fx&#x3D;北风, fl&#x3D;3-4级, type&#x3D;多云, notice&#x3D;阴晴之间，谨防紫外线侵扰&#125;, &#123;date&#x3D;08, sunrise&#x3D;07:36, high&#x3D;高温 1.0℃, low&#x3D;低温 -9.0℃, sunset&#x3D;17:05, aqi&#x3D;28.0, ymd&#x3D;2019-01-08, week&#x3D;星期二, fx&#x3D;北风, fl&#x3D;3-4级, type&#x3D;晴, notice&#x3D;愿你拥有比阳光明媚的心情&#125;, &#123;date&#x3D;09, sunrise&#x3D;07:36, high&#x3D;高温 2.0℃, low&#x3D;低温 -8.0℃, sunset&#x3D;17:06, aqi&#x3D;83.0, ymd&#x3D;2019-01-09, week&#x3D;星期三, fx&#x3D;西南风, fl&#x3D;&lt;3级, type&#x3D;多云, notice&#x3D;阴晴之间，谨防紫外线侵扰&#125;, &#123;date&#x3D;10, sunrise&#x3D;07:36, high&#x3D;高温 4.0℃, low&#x3D;低温 -7.0℃, sunset&#x3D;17:07, aqi&#x3D;128.0, ymd&#x3D;2019-01-10, week&#x3D;星期四, fx&#x3D;西南风, fl&#x3D;&lt;3级, type&#x3D;晴, notice&#x3D;愿你拥有比阳光明媚的心情&#125;, &#123;date&#x3D;11, sunrise&#x3D;07:36, high&#x3D;高温 5.0℃, low&#x3D;低温 -6.0℃, sunset&#x3D;17:08, aqi&#x3D;238.0, ymd&#x3D;2019-01-11, week&#x3D;星期五, fx&#x3D;西南风, fl&#x3D;&lt;3级, type&#x3D;多云, notice&#x3D;阴晴之间，谨防紫外线侵扰&#125;]&#125;可以新建一个天气的Bean，将返回的json数据转换成对象 六、GSON直接解析成对象1ResultBean resultBean &#x3D; new Gson().fromJson(resultStr,ResultBean.class); 七、解析简单的json1234567891011data:&#123; shidu &#x3D; 15 % , pm25 &#x3D; 15.0, pm10 &#x3D; 35.0, quality &#x3D; 优, wendu &#x3D; 3, ganmao &#x3D; 各类人群可自由活动, &#125;JsonObject jsonObject &#x3D;(JsonObject) new JsonParser().parse(resultStr);Int wendu &#x3D; jsonObject.get(&quot;data&quot;).getAsJsonObject().get(&quot;wendu&quot;).getAsInt();String quality&#x3D; jsonObject.get(&quot;data&quot;).getAsJsonObject().get(&quot;quality&quot;).getAsString(); 八、解析多层对象1234567891011121314151617181920212223242526 data:&#123; shidu &#x3D; 15 % , pm25 &#x3D; 15.0, pm10 &#x3D; 35.0, quality &#x3D; 优, wendu &#x3D; 3, ganmao &#x3D; 各类人群可自由活动, yesterday :&#123; date &#x3D; 06, sunrise &#x3D; 07: 36, high &#x3D; 高温 3.0℃, low &#x3D; 低温 - 7.0℃, sunset &#x3D; 17: 03, aqi &#x3D; 58.0, ymd &#x3D; 2019 - 01 - 06, week &#x3D; 星期日, fx &#x3D; 西南风, fl &#x3D; &lt; 3 级, type &#x3D; 晴, notice &#x3D; 愿你拥有比阳光明媚的心情 &#125; &#125;JsonObject jsonObject &#x3D; (JsonObject) new JsonParser().parse(resultStr);JsonObject yesterday &#x3D; jsonObject.get(&quot;data&quot;).getAsJsonObject().get(&quot;yesterday &quot;).getAsJsonObject();String type &#x3D; yesterday.get(&quot;type&quot;).getAsString(); 九、解析带数组的json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&#123;shidu &#x3D; 15 % , pm25 &#x3D; 15.0, pm10 &#x3D; 35.0, quality &#x3D; 优, wendu &#x3D; 3, ganmao &#x3D; 各类人群可自由活动, yesterday &#x3D; &#123; date &#x3D; 06, sunrise &#x3D; 07: 36, high &#x3D; 高温 3.0℃, low &#x3D; 低温 - 7.0℃, sunset &#x3D; 17: 03, aqi &#x3D; 58.0, ymd &#x3D; 2019 - 01 - 06, week &#x3D; 星期日, fx &#x3D; 西南风, fl &#x3D; &lt; 3 级, type &#x3D; 晴, notice &#x3D; 愿你拥有比阳光明媚的心情 &#125;, forecast &#x3D; [&#123; date &#x3D; 07, sunrise &#x3D; 07: 36, high &#x3D; 高温 2.0℃, low &#x3D; 低温 - 7.0℃, sunset &#x3D; 17: 04, aqi &#x3D; 48.0, ymd &#x3D; 2019 - 01 - 07, week &#x3D; 星期一, fx &#x3D; 北风, fl &#x3D; 3 - 4 级, type &#x3D; 多云, notice &#x3D; 阴晴之间， 谨防紫外线侵扰 &#125;, &#123; date &#x3D; 08, sunrise &#x3D; 07: 36, high &#x3D; 高温 1.0℃, low &#x3D; 低温 - 9.0℃, sunset &#x3D; 17: 05, aqi &#x3D; 28.0, ymd &#x3D; 2019 - 01 - 08, week &#x3D; 星期二, fx &#x3D; 北风, fl &#x3D; 3 - 4 级, type &#x3D; 晴, notice &#x3D; 愿你拥有比阳光明媚的心情 &#125;, &#123; date &#x3D; 09, sunrise &#x3D; 07: 36, high &#x3D; 高温 2.0℃, low &#x3D; 低温 - 8.0℃, sunset &#x3D; 17: 06, aqi &#x3D; 83.0, ymd &#x3D; 2019 - 01 - 09, week &#x3D; 星期三, fx &#x3D; 西南风, fl &#x3D; &lt; 3 级, type &#x3D; 多云, notice &#x3D; 阴晴之间， 谨防紫外线侵扰 &#125;, &#123; date &#x3D; 10, sunrise &#x3D; 07: 36, high &#x3D; 高温 4.0℃, low &#x3D; 低温 - 7.0℃, sunset &#x3D; 17: 07, aqi &#x3D; 128.0, ymd &#x3D; 2019 - 01 - 10, week &#x3D; 星期四, fx &#x3D; 西南风, fl &#x3D; &lt; 3 级, type &#x3D; 晴, notice &#x3D; 愿你拥有比阳光明媚的心情 &#125;, &#123; date &#x3D; 11, sunrise &#x3D; 07: 36, high &#x3D; 高温 5.0℃, low &#x3D; 低温 - 6.0℃, sunset &#x3D; 17: 08, aqi &#x3D; 238.0, ymd &#x3D; 2019 - 01 - 11, week &#x3D; 星期五, fx &#x3D; 西南风, fl &#x3D; &lt; 3 级, type &#x3D; 多云, notice &#x3D; 阴晴之间， 谨防紫外线侵扰 &#125;]&#125;JsonObject jsonObject &#x3D;(JsonObject) new JsonParser().parse(resultStr);&#x2F;&#x2F;获取dataJsonObject data &#x3D; jsonObject.get(&quot;data&quot;).getAsJsonObject();&#x2F;&#x2F;获取数组JsonArray forecast &#x3D; data.getAsJsonObject().get(&quot;forecast&quot;).getAsJsonArray();String type &#x3D; forecast.get(0).getAsJsonObject().get(&quot;type&quot;).getAsString();","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"json","slug":"json","permalink":"http://www.lida1024.top/tags/json/"}]},{"title":"开发中常用的 25 个JavaScript 单行代码","slug":"开发中常用的-25-个JavaScript-单行代码","date":"2019-07-26T03:34:00.000Z","updated":"2020-01-01T03:56:28.870Z","comments":true,"path":"2019/07/26/开发中常用的-25-个JavaScript-单行代码/","link":"","permalink":"http://www.lida1024.top/2019/07/26/%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84-25-%E4%B8%AAJavaScript-%E5%8D%95%E8%A1%8C%E4%BB%A3%E7%A0%81/","excerpt":"","text":"1.强制布尔值要将变量强制转换为布尔值而不更改其值： 1const myBoolean &#x3D; !! myVariable;!!null &#x2F;&#x2F; false !!undefined &#x2F;&#x2F; false !!false &#x2F;&#x2F; false !!ture &#x2F;&#x2F; ture !!&quot;&quot; &#x2F;&#x2F; false !!&quot;string&quot; &#x2F;&#x2F; true !!0 &#x2F;&#x2F; false !!1 &#x2F;&#x2F; true !!&#123;&#125; &#x2F;&#x2F; true !![] &#x2F;&#x2F; true 2.基于某个条件为对象设置属性要使用spread运算符有条件地在对象上设置属性： 123456const myObject &#x3D; &#123;... myProperty &amp;&amp; &#123;propName：myPoperty&#125;&#125;;let myProperty &#x3D; &#39;Jhon&#39; const myObject &#x3D; &#123;...myProperty &amp;&amp; &#123;propName: myProperty&#125;&#125;; &#x2F;&#x2F; &#123;propName: &quot;Jhon&quot;&#125; let myProperty &#x3D; &#39;&#39; const myObject &#x3D; &#123;...myProperty &amp;&amp; &#123;propName: myProperty&#125;&#125;; &#x2F;&#x2F; &#123;&#125; 如果myProperty结果为false，则 &amp;&amp; 失败并且不设置新属性; 否则，如果不为空，&amp;&amp; 将设置新属性并覆盖原来的值。 3.合并对象12345const mergedObject &#x3D; &#123; ...objectOne, ...objectTwo &#125;; const mergedObject &#x3D; &#123; ...&#123;name: &#39;Jhon&#39;, age: &#39;18&#39;&#125;, ...&#123;name1: &#39;jhon1&#39;, age1: &#39;12&#39;&#125;&#125;; &#x2F;&#x2F; &#123;name: &quot;Jhon&quot;, age: &quot;18&quot;, name1: &quot;jhon1&quot;, age1: &quot;12&quot;&#125; const mergedObject &#x3D; &#123; ...&#123;name: &#39;Jhon&#39;, age: &#39;18&#39;&#125;, ...&#123;name: &#39;jhon1&#39;, age:&#39;12&#39;&#125;&#125;; &#x2F;&#x2F; &#123;name: &quot;jhon1&quot;, age: &quot;12&quot;&#125; 支持无限制合并，但如果对象之间存在相同属性，则后面属性会覆盖前面属性。*请注意，这仅适用于浅层合并。 4.交换变量要在不使用中间变量的情况下交换两个变量的值 123[varA，varB] &#x3D; [varB，varA]; let a &#x3D; 1; let b &#x3D; 2; [a, b] &#x3D; [b, a] &#x2F;&#x2F; a &#x3D; 2 b &#x3D; 1 5.删除Boolean 为 false 值12const clean &#x3D; dirty.filter(Boolean); const clean &#x3D; [0, false, true, undefined, null, &#39;&#39;, 12, 15].filter(Boolean); &#x2F;&#x2F; [true, 12, 15] 这将删除值等于：null，undefined，false，0 和空字符串(‘’)。 6.转换元素类型要将Number元素转换为String元素： 12const stringArray &#x3D; numberArray.map(String); const stringArray &#x3D; [1, 2, 3].map(String); [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] 如果数组包含字符串，字符串原样保留。 这也可以用于将String元素转换为Number类型： 12const numberArray &#x3D; stringArray.map(Number); const stringArray &#x3D; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(String); &#x2F;&#x2F; [1, 2, 3] 7.格式化对象为JSON代码要以可读的格式显示JSON代码： 123const formatted &#x3D; JSON.stringify(myObj, null, 4); const formatted &#x3D; JSON.stringify(&#123;name: &#39;Jhon&#39;, age: 18, address: &#39;sz&#39;&#125;, null, 4); &#x2F;* &#123; &quot;name&quot;: &quot;Jhon&quot;, &quot;age&quot;: 18, &quot;address&quot;: &quot;sz&quot; &#125; *&#x2F; 该字符串化命令有三个参数。第一个是Javascript对象。第二个是可选函数，可用于在JSON进行字符串化时对其执行操作。最后一个参数指示要添加多少空格作为缩进以格式化JSON。省略最后一个参数，JSON将返回一个长行。如果myObj中存在循环引用，则会格式失败。 8.快速创建数字数组要创建一个数组并用数字填充它，索引为零： 12const numArray &#x3D; Array.from(new Array(10), (x, i)&#x3D;&gt; i); &#x2F;&#x2F; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 9.随机生成六位数字验证码12const code &#x3D; Math.floor(Math.random() * 1000000).toString().padStart(6, &quot;0&quot;); &#x2F;&#x2F; 942377 10.身份证正则1234const IDReg&#x3D; &#x2F;(^[1-9]d&#123;5&#125;(18|19| ([23]d))d&#123;2&#125;((0[1-9])| (10|11|12))(([0-2][1-9])|10|20|30|31)d&#123;3&#125;[0-9Xx]$)| (^[1-9]d&#123;5&#125;d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)d&#123;2&#125;[0-9Xx]$)&#x2F;; 11.window.location.search 转 JS 对象有时候我们会对url的查询参数即从问号 (?)后 开始的 URL（查询部分）进行转换 1234567891011const searchObj &#x3D; search &#x3D;&gt; JSON.parse( &#96;&#123;&quot;$&#123;decodeURIComponent(search .substring(1)) .replace(&#x2F;&quot;&#x2F;g, &#39;\\&quot;&#39;) .replace(&#x2F;&amp;&#x2F;g,&#39;&quot;,&quot;&#39;) .replace(&#x2F;&#x3D;&#x2F;g, &#39;&quot;:&quot;&#39;) &#125;&quot;&#125;&#96; ); &#x2F;&#x2F; 假如请求url为 &#x2F;&#x2F; &#39;https:&#x2F;&#x2F;www.baidu.com?ie&#x3D;utf-8&amp;f&#x3D;8&amp;rsv_bp&#x3D;1&amp;rsv_idx&#x3D;1&amp;tn&#x3D;baidu&amp;wd&#x3D;js&amp;rsv_pq&#x3D;a86b5e5f0007bceb&amp;rsv_t&#x3D;1e1fAVan%2BVlnkhJHFB0BIGLdLM2slszYMJBTTfFkmyyBUzBpw0ggeuVDE50&amp;rqlang&#x3D;cn&amp;rsv_enter&#x3D;0&amp;inputT&#x3D;1287&amp;rsv_sug3&#x3D;5&amp;rsv_sug1&#x3D;3&amp;rsv_sug7&#x3D;101&amp;rsv_sug2&#x3D;0&amp;rsv_sug4&#x3D;1907&#39; &#x2F;&#x2F; 那么 window.location.search 就为： let search &#x3D; &#39;?ie&#x3D;utf-8&amp;f&#x3D;8&amp;rsv_bp&#x3D;1&amp;rsv_idx&#x3D;1&amp;tn&#x3D;baidu&amp;wd&#x3D;js&amp;rsv_pq&#x3D;a86b5e5f0007bceb&amp;rsv_t&#x3D;1e1fAVan%2BVlnkhJHFB0BIGLdLM2slszYMJBTTfFkmyyBUzBpw0ggeuVDE50&amp;rqlang&#x3D;cn&amp;rsv_enter&#x3D;0&amp;inputT&#x3D;1287&amp;rsv_sug3&#x3D;5&amp;rsv_sug1&#x3D;3&amp;rsv_sug7&#x3D;101&amp;rsv_sug2&#x3D;0&amp;rsv_sug4&#x3D;1907&#39; searchObj(search) 12.JS 对象转 url 查询字符串123456const objectToQueryString &#x3D; (obj) &#x3D;&gt; Object.keys(obj).map((key) &#x3D;&gt;&#96;$&#123;encodeURIComponent(key)&#125; &#x3D;$&#123;encodeURIComponent(obj[key])&#125;&#96;).join(&#39;&amp;&#39;); objectToQueryString(&#123;name: &#39;Jhon&#39;, age: 18, address: &#39;beijing&#39;&#125;) &#x2F;&#x2F; name&#x3D;Jhon&amp;age&#x3D;18&amp;address&#x3D;beijing 13.获取数组交集123const similarity &#x3D; (arr, values) &#x3D;&gt; arr.filter(v &#x3D;&gt; values.includes(v)); similarity([1, 2, 3], [1, 2, 4]); &#x2F;&#x2F; [1,2] 14.检测设备类型使用正则表达式来检测 navigator.userAgent 属性判断设备是在移动设备还是在台式机/笔记本电脑打开。 123const detectDeviceType &#x3D; () &#x3D;&gt;&#x2F;Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile| OperaMini&#x2F;i.test(navigator.userAgent) ? &#39;Mobile&#39; : &#39;Desktop&#39;; 15.将数字转化为千分位格式123const toDecimalMark &#x3D; num &#x3D;&gt; num.toLocaleString(&#39;en-US&#39;); toDecimalMark(12305030388.9087); &#x2F;&#x2F; &quot;12,305,030,388.909&quot; 16.多维数组转一维数组12345const deepFlatten &#x3D; arr &#x3D;&gt; [].concat( ...arr.map( v &#x3D;&gt; (Array.isArray(v) ? deepFlatten(v) : v))); deepFlatten([1, [2], [[3], 4], 5]); &#x2F;&#x2F; [1,2,3,4,5] 17.过滤对象数组123456789const reducedFilter &#x3D; (data, keys, fn) &#x3D;&gt;data.filter(fn) .map( el &#x3D;&gt;keys.reduce( (acc, key) &#x3D;&gt; &#123;acc[key] &#x3D;el[key];return acc;&#125;, &#123;&#125;) );const data &#x3D; [ &#123; id: 1, name: &#39;john&#39;, age: 24 &#125;, &#123; id: 2, name: &#39;mike&#39;, age: 50 &#125; ]; let a &#x3D; reducedFilter(data, [&#39;id&#39;, &#39;name&#39;], item &#x3D;&gt; item.age &gt; 24); &#x2F;&#x2F; [&#123; id: 2, name: &#39;mike&#39;&#125;] 18.驼峰字字符串格式化转换驼峰拼写的字符串为特定格式。 使用 String.replace() 去除下划线，连字符和空格，并将驼峰拼写格式的单词转换为全小写。省略第二个参数 separator ，默认使用 _ 分隔符。 123456const fromCamelCase &#x3D; (str, separator &#x3D; &#39;_&#39;) &#x3D;&gt;str.replace(&#x2F;([a-zd])([A-Z])&#x2F;g, &#39;$1&#39; + separator + &#39;$2&#39;).replace(&#x2F;([A-Z]+)([A-Z][a-zd]+)&#x2F;g, &#39;$1&#39; + separator + &#39;$2&#39;).toLowerCase();fromCamelCase(&#39;someDatabaseFieldName&#39;, &#39; &#39;);&#x2F;&#x2F; &#39;some database field name&#39; fromCamelCase(&#39;someLabelThatNeedsToBeCamelized&#39;, &#39;-&#39;); &#x2F;&#x2F; &#39;some-label-that-needs-to-be-camelized&#39; fromCamelCase(&#39;someJavascriptProperty&#39;, &#39;_&#39;);&#x2F;&#x2F; &#39;some_javascript_property&#39; 19.是否为绝对地址1234const isAbsoluteURL &#x3D; str &#x3D;&gt; &#x2F;^[a-z][a-z0-9+.-]*:&#x2F;.test(str); isAbsoluteURL(&#39;https:&#x2F;&#x2F;google.com&#39;); &#x2F;&#x2F; true isAbsoluteURL(&#39;ftp:&#x2F;&#x2F;www.myserver.net&#39;);&#x2F;&#x2F; true isAbsoluteURL(&#39;&#x2F;foo&#x2F;bar&#39;); &#x2F;&#x2F; false 20.获取两个日期相差天数123const getDaysDiffBetweenDates &#x3D; (dateInitial, dateFinal) &#x3D;&gt; (dateFinal - dateInitial) &#x2F; (1000 * 3600 * 24); getDaysDiffBetweenDates(new Date(&#39;2017-12-13&#39;), new Date(&#39;2017-12-22&#39;)); &#x2F;&#x2F; 9 21.数组去重12const deDupe &#x3D; (myArray) &#x3D;&gt; [... new Set(myArray)]; deDupe([1, 1, 2, 1, 3, 3, 4]) &#x2F;&#x2F; [1, 2, 3, 4] 22.数组对象去重1234567891011const uniqueElementsBy &#x3D; (arr, fn) &#x3D;&gt;arr.reduce((acc, v) &#x3D;&gt; &#123; if (!acc.some(x &#x3D;&gt; fn(v, x))) acc.push(v); return acc; &#125;, []); uniqueElementsBy([&#123;id: 1, name: &#39;Jhon&#39;&#125;, &#123;id: 2, name: &#39;sss&#39;&#125;, &#123;id: 1, name: &#39;Jhon&#39;&#125;], (a, b) &#x3D;&gt; a.id &#x3D;&#x3D; b.id) &#x2F;&#x2F; [&#123;id: 1, name: &#39;Jhon&#39;&#125;, &#123;id: 2, name: &#39;sss&#39;&#125;] 23.RGB 颜色转 16进制颜色123const RGBToHex &#x3D; (r, g, b) &#x3D;&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, &#39;0&#39;); RGBToHex(255, 165, 1); &#x2F;&#x2F; &#39;ffa501&#39; 24.常用密码组合正则12const passwordReg &#x3D; &#x2F;(?!^(d+|[a-zA-Z]+|[~!@#$%^&amp;*?]+)$)^[w~!@#$%^&amp;*?]&#123;8,20&#125;$&#x2F;; &#x2F;&#x2F; -长度8~20位字符，支持大小写字母、数字、符号三种字符中任意两种字符的组合 25.判断dom元素是否具有某个className12const hasClass &#x3D; (el, className) &#x3D;&gt; new RegExp(&#96;(^|\\s)$&#123;className&#125;(\\s|$)&#96;).test(el.className);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.lida1024.top/categories/JavaScript/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://www.lida1024.top/tags/javaScript/"}]},{"title":"shiro 加密登录 密码加盐处理","slug":"shiro-加密登录-密码加盐处理","date":"2019-07-26T03:25:00.000Z","updated":"2020-01-01T02:31:11.429Z","comments":true,"path":"2019/07/26/shiro-加密登录-密码加盐处理/","link":"","permalink":"http://www.lida1024.top/2019/07/26/shiro-%E5%8A%A0%E5%AF%86%E7%99%BB%E5%BD%95-%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90%E5%A4%84%E7%90%86/","excerpt":"","text":"密码加密登录是为了提高系统安全性，即使是管理员查看数据库也得不到密码使用shiro可以很轻松的完成加密及登录操作 1.加密工具此工具用于注册时对密码进行加密 123456789101112public static final String md5(String password, String salt)&#123; &#x2F;&#x2F;加密方式 String hashAlgorithmName &#x3D; &quot;MD5&quot;; &#x2F;&#x2F;盐：为了即使相同的密码不同的盐加密后的结果也不同 ByteSource byteSalt &#x3D; ByteSource.Util.bytes(salt); &#x2F;&#x2F;密码 Object source &#x3D; password; &#x2F;&#x2F;加密次数 int hashIterations &#x3D; 1024; SimpleHash result &#x3D; new SimpleHash(hashAlgorithmName, source, byteSalt, hashIterations); return result.toString();&#125; 测试一下 123456public static void main(String[] args) &#123; String password &#x3D; md5(&quot;123456&quot;, &quot;WHLH&quot;); System.out.println(password); &#x2F;&#x2F;加密后的结果 &#x2F;&#x2F;3bcbb857c763d1429a24959cb8de2593&#125; 2.使用shiro登录Realm类 12345678910@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) &#123; UsernamePasswordToken token&#x3D;(UsernamePasswordToken) authenticationToken; String username &#x3D; token.getUsername(); &#x2F;&#x2F;查询用户信息 User user&#x3D;userService.findByUsername(username); &#x2F;&#x2F;取出盐并编码 ByteSource salt &#x3D; ByteSource.Util.bytes(user.getSalt()); return new SimpleAuthenticationInfo(username, user.getPassword(),salt, getName());&#125; 3.修改自定义realm配置加密算法和加密次数要和加密工具参数保持一致 12345678910&lt;bean id&#x3D;&quot;myRealm&quot; class&#x3D;&quot;cn.jaffreyen.web.shiro.MyRealm&quot;&gt; &lt;property name&#x3D;&quot;credentialsMatcher&quot;&gt; &lt;bean class&#x3D;&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;!-- 加密算法 --&gt; &lt;property name&#x3D;&quot;hashAlgorithmName&quot; value&#x3D;&quot;MD5&quot;&gt;&lt;&#x2F;property&gt; &lt;!-- 加密次数 --&gt; &lt;property name&#x3D;&quot;hashIterations&quot; value&#x3D;&quot;1024&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"http://www.lida1024.top/tags/shiro/"}]},{"title":"记一次jsoup的使用","slug":"记一次jsoup的使用","date":"2019-07-06T07:46:00.000Z","updated":"2020-01-01T02:31:53.515Z","comments":true,"path":"2019/07/06/记一次jsoup的使用/","link":"","permalink":"http://www.lida1024.top/2019/07/06/%E8%AE%B0%E4%B8%80%E6%AC%A1jsoup%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Jsoup是用于解析HTML，就类似XML解析器用于解析XML。 Jsoup它解析HTML成为真实世界的HTML。 它与jquery选择器的语法非常相似，并且非常灵活容易使用以获得所需的结果。 安装依赖123456&lt;dependency&gt; &lt;!-- jsoup HTML parser library @ http:&#x2F;&#x2F;jsoup.org&#x2F; --&gt; &lt;groupId&gt;org.jsoup&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsoup&lt;&#x2F;artifactId&gt; &lt;version&gt;1.10.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 应用从URL获取HTML来解析12Document doc &#x3D; Jsoup.connect(&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;).get();String title &#x3D; doc.title(); connect(String url) 方法创建一个新的 Connection, 和 get() 取得和解析一个HTML文件。如果从该URL获取HTML时发生错误，便会抛出 IOException，应适当处理。Connection 接口还提供一个方法链来解决特殊请求，具体如下 123456Document doc &#x3D; Jsoup.connect(&quot;http:&#x2F;&#x2F;example.com&quot;;).data(&quot;query&quot;, &quot;Java&quot;).userAgent(&quot;Mozilla&quot;).cookie(&quot;auth&quot;, &quot;token&quot;).timeout(3000).post(); 查看元素123456getElementById(String id);getElementsByTag(String tag);getElementsByClass(String className);getElementsByAttribute(String key) (and related methods);Element siblings: siblingElements(), firstElementSibling(), lastElementSibling(); nextElementSibling(), previousElementSibling();Graph: parent(), children(), child(int index); 元素数据12345678attr(String key)获取属性attr(String key, String value)设置属性attributes()获取所有属性id(), className() and classNames()text()获取文本内容text(String value) 设置文本内容html()获取元素内HTMLhtml(String value)设置元素内的HTML内容outerHtml()获取元素外HTML内容data()获取数据内容（例如：script和style标签)tag() and tagName() 操作HTML和文本1234append(String html), prepend(String html)appendText(String text), prependText(String text)appendElement(String tagName), prependElement(String tagName)html(String value) 通过类似于css或jQuery的选择器来查找元素1234567891011Elements trs &#x3D; doc.select(&quot;.kuang&quot;).select(&quot;tbody&quot;).get(5).select(&quot;tr&quot;); StringBuilder controlTarget &#x3D; new StringBuilder(); for (int i &#x3D; 0; i &lt; trs.size(); i++) &#123; if (i &gt;&#x3D; 1 &amp;&amp; i &lt; trs.size() - 1) &#123; Elements tds &#x3D; trs.get(i).select(&quot;td&quot;); res.setCropRange(tds.get(0).text()); res.setDosage(tds.get(2).text()); res.setMethod(tds.get(3).text()); controlTarget.append(tds.get(1).text()).append(&quot; &quot;); &#125; &#125; Selector选择器概述12345678910tagname: 通过标签查找元素，比如：a;ns|tag: 通过标签在命名空间查找元素，比如：可以用 fb|name 语法来查找 &lt;fb:name&gt; 元素;&#39;#id&#39;: 通过ID查找元素，比如：#logo;.class: 通过class名称查找元素，比如：.masthead;[attribute]: 利用属性查找元素，比如：[href];[^attr]: 利用属性名前缀来查找元素，比如：可以用[^data-] 来查找带有HTML5 Dataset属性的元素;[attr&#x3D;value]: 利用属性值来查找元素，比如：[width&#x3D;500];[attr^&#x3D;value], [attr$&#x3D;value], [attr*&#x3D;value]: 利用匹配属性值开头、结尾或包含属性值来查找元素，比如：[href*&#x3D;&#x2F;path&#x2F;];[attr~&#x3D;regex]: 利用属性值匹配正则表达式来查找元素，比如： img[src~&#x3D;(?i)\\.(png|jpe?g)];*: 这个符号将匹配所有元素; Selector选择器组合使用123456789el#id: 元素+ID，比如： div#logo;el.class: 元素+class，比如： div.masthead;el[attr]: 元素+class，比如： a[href];任意组合，比如：a[href].highlight;ancestor child: 查找某个元素下子元素，比如：可以用.body p 查找在&quot;body&quot;元素下的所有 p元素;parent &gt; child: 查找某个父元素下的直接子元素，比如：可以用div.content &gt; p 查找 p 元素，也可以用body &gt; * 查找body标签下所有直接子元素;siblingA + siblingB: 查找在A元素之前第一个同级元素B，比如：div.head + div;siblingA ~ siblingX: 查找A元素之前的同级X元素，比如：h1 ~ p;el, el, el:多个选择器组合，查找匹配任一选择器的唯一元素，例如：div.masthead, div.logo; 伪选择器selectors123456789:lt(n): 查找哪些元素的同级索引值（它的位置在DOM树中是相对于它的父节点）小于n，比如：td:lt(3) 表示小 于三列的元素 :gt(n):查找哪些元素的同级索引值大于n，比如： div p:gt(2)表示哪些div中有包含2个以上的p元素 :eq(n): 查找哪些元素的同级索引值与n相等，比如：form input:eq(1)表示包含一个input标签的Form元素 :has(seletor): 查找匹配选择器包含元素的元素，比如：div:has(p)表示哪些div包含了p元素 :not(selector): 查找与选择器不匹配的元素，比如： div:not(.logo) 表示不包含 class&#x3D;&quot;logo&quot; 元素的所有 div 列表 :contains(text): 查找包含给定文本的元素，搜索不区分大不写，比如： p:contains(jsoup) :containsOwn(text): 查找直接包含给定文本的元素 :matches(regex): 查找哪些元素的文本匹配指定的正则表达式，比如：div:matches((?i)login) :matchesOwn(regex): 查找自身包含文本匹配指定正则表达式的元素 提取给定URL中的链接123456Document doc &#x3D; Jsoup.connect(&quot;http:&#x2F;&#x2F;www.yiibai.com&quot;).get(); Elements links &#x3D; doc.select(&quot;a[href]&quot;); for (Element link : links) &#123; System.out.println(&quot;\\nlink : &quot; + link.attr(&quot;href&quot;)); System.out.println(&quot;text : &quot; + link.text()); &#125; 提取URL中的元数据12345Document doc &#x3D; Jsoup.connect(&quot;http:&#x2F;&#x2F;www.yiibai.com&quot;).get(); String keywords &#x3D; doc.select(&quot;meta[name&#x3D;keywords]&quot;).first().attr(&quot;content&quot;); System.out.println(&quot;Meta keyword : &quot; + keywords); String description &#x3D; doc.select(&quot;meta[name&#x3D;description]&quot;).get(0).attr(&quot;content&quot;); System.out.println(&quot;Meta description : &quot; + description); 提取URL中的图像12345678Document doc &#x3D; Jsoup.connect(&quot;http:&#x2F;&#x2F;www.yiibai.com&quot;).get(); Elements images &#x3D; doc.select(&quot;img[src~&#x3D;(?i)\\\\.(png|jpe?g|gif)]&quot;); for (Element image : images) &#123; System.out.println(&quot;src : &quot; + image.attr(&quot;src&quot;)); System.out.println(&quot;height : &quot; + image.attr(&quot;height&quot;)); System.out.println(&quot;width : &quot; + image.attr(&quot;width&quot;)); System.out.println(&quot;alt : &quot; + image.attr(&quot;alt&quot;)); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.lida1024.top/categories/Java/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.lida1024.top/tags/%E7%88%AC%E8%99%AB/"}]}]}