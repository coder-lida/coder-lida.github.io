{"meta":{"title":"一觉睡到小时候","subtitle":"","description":"三级代码，一级Bug！","author":"少年闰土","url":"http://www.lida1024.top","root":"/"},"pages":[{"title":"关于","date":"2019-12-13T00:21:43.222Z","updated":"2019-12-13T00:21:43.222Z","comments":true,"path":"about/index.html","permalink":"http://www.lida1024.top/about/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-12-13T00:22:50.140Z","updated":"2019-12-13T00:22:50.140Z","comments":true,"path":"tags/index.html","permalink":"http://www.lida1024.top/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-12-13T00:22:27.336Z","updated":"2019-12-13T00:22:27.336Z","comments":true,"path":"categories/index.html","permalink":"http://www.lida1024.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-12-13T00:23:48.029Z","updated":"2019-12-13T00:23:48.029Z","comments":true,"path":"mylist/index.html","permalink":"http://www.lida1024.top/mylist/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-02-28T06:02:54.499Z","updated":"2020-02-28T06:02:54.499Z","comments":true,"path":"links/index.html","permalink":"http://www.lida1024.top/links/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： 一觉睡到小时候头像： https://s2.ax1x.com/2019/12/13/QcW5TI.png网址： https://lida1024.top/标签： Java 前端"},{"title":"电影","date":"2020-03-07T09:54:45.104Z","updated":"2020-03-07T09:54:45.104Z","comments":true,"path":"film/index.html","permalink":"http://www.lida1024.top/film/index.html","excerpt":"","text":""},{"title":"厨房","date":"2020-03-11T13:55:24.928Z","updated":"2020-03-11T13:51:44.980Z","comments":true,"path":"meal/index.html","permalink":"http://www.lida1024.top/meal/index.html","excerpt":"","text":"油焖虾 香菇油菜 麻辣香锅 地三鲜 媳妇牌饺子"}],"posts":[{"title":"JDK中的timer正确的打开与关闭","slug":"JDK中的timer正确的打开与关闭","date":"2020-04-29T02:59:00.000Z","updated":"2020-04-29T03:01:21.965Z","comments":true,"path":"2020/04/29/JDK中的timer正确的打开与关闭/","link":"","permalink":"http://www.lida1024.top/2020/04/29/JDK%E4%B8%AD%E7%9A%84timer%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD/","excerpt":"","text":"Timer和TimerTaskTimer是jdk中提供的一个定时器工具，使用的时候会在主线程之外起一个单独的线程执行指定的计划任务，可以指定执行一次或者反复执行多次。 TimerTask是一个实现了Runnable接口的抽象类，代表一个可以被Timer执行的任务。 Timer的调度123456789101112131415161718192021222324import java.util.Timer;import java.util.TimerTask;public class TestTimer &#123; public static void main(String args[])&#123; new Reminder(3); &#125; public static class Reminder&#123; Timer timer; public Reminder(int sec)&#123; timer &#x3D; new Timer(); timer.schedule(new TimerTask()&#123; public void run()&#123; System.out.println(&quot;Time&#39;s up!&quot;); timer.cancel(); System.out.println(&quot;Time&#39;s shutdown!&quot;); &#125; &#125;, sec*1000); &#125; &#125; &#125; 控制台输出 12Time&#39;s up!Time&#39;s shutdown! 从这个例子可以看出一个典型的利用timer执行计划任务的过程如下： new一个TimerTask的子类，重写run方法来指定具体的任务，在这个例子里，我用匿名内部类的方式来实现了一个TimerTask的子类 new一个Timer类，Timer的构造函数里会起一个单独的线程来执行计划任务。 jdk的实现代码如下： 12345678public Timer() &#123; this(&quot;Timer-&quot; + serialNumber()); &#125; public Timer(String name) &#123; thread.setName(name); thread.start(); &#125; Timer的关闭在JDK1.5以后，文档中有这么一句话：对 Timer 对象最后的引用完成后，并且 所有未处理的任务都已执行完成后，计时器的任务执行线程会正常终止（并且成为垃圾回收的对象）。但是这可能要很长时间后才发生。 System.gc()系统默认当Timer运行结束后，如果没有手动终止，那么则只有当系统的垃圾收集被调用的时候才会对其进行回收终止。因此，可以手动System.gc();但是Sytem.gc()在一个项目中是不能随便调用的。因为一个tomcat只启动一个进程，而JVM的垃圾处理器也只有一个，所以在一个工程里运行System.gc也会影响到其他工程。 cancle()首先看cancle方法的源码 1234567public void cancel() &#123; synchronized(queue) &#123; thread.newTasksMayBeScheduled &#x3D; false; queue.clear(); queue.notify(); &#x2F;&#x2F; In case queue was already empty. &#125; &#125; 没有显式的线程stop方法，而是调用了queue的clear方法和queue的notify方法，clear是个自定义方法，notify是Objec自带的方法，很明显是去唤醒wait方法的。 clear方法 12345678910 &#x2F;** * Removes all elements from the priority queue. *&#x2F;void clear() &#123; &#x2F;&#x2F; Null out task references to prevent memory leak for (int i&#x3D;1; i&lt;&#x3D;size; i++) queue[i] &#x3D; null; size &#x3D; 0; &#125; clear方法很简单，就是去清空queue，queue是一个TimerTask的数组，然后把queue的size重置成0，变成empty.还是没有看到显式的停止线程方法，回到最开始new Timer的时候，看看new Timer代码： 1234567891011121314151617public Timer() &#123; this(&quot;Timer-&quot; + serialNumber()); &#125; &#x2F;** * Creates a new timer whose associated thread has the specified name. * The associated thread does &lt;i&gt;not&lt;&#x2F;i&gt; * &#123;@linkplain Thread#setDaemon run as a daemon&#125;. * * @param name the name of the associated thread * @throws NullPointerException if &#123;@code name&#125; is null * @since 1.5 *&#x2F; public Timer(String name) &#123; thread.setName(name); thread.start(); &#125; 看看这个内部变量thread: 1234&#x2F;** * The timer thread.*&#x2F;private TimerThread thread &#x3D; new TimerThread(queue); 不是原生的Thread,是自定义的类TimerThread.这个类实现了Thread类，重写了run方法，如下： 1234567891011public void run() &#123; try &#123; mainLoop(); &#125; finally &#123; &#x2F;&#x2F; Someone killed this Thread, behave as if Timer cancelled synchronized(queue) &#123; newTasksMayBeScheduled &#x3D; false; queue.clear(); &#x2F;&#x2F; Eliminate obsolete references &#125; &#125; &#125; 最后是这个mainLoop方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 &#x2F;** * The main timer loop. (See class comment.) *&#x2F; private void mainLoop() &#123; while (true) &#123; try &#123; TimerTask task; boolean taskFired; synchronized(queue) &#123; &#x2F;&#x2F; Wait for queue to become non-empty while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled) queue.wait(); if (queue.isEmpty()) break; &#x2F;&#x2F; Queue is empty and will forever remain; die &#x2F;&#x2F; Queue nonempty; look at first evt and do the right thing long currentTime, executionTime; task &#x3D; queue.getMin(); synchronized(task.lock) &#123; if (task.state &#x3D;&#x3D; TimerTask.CANCELLED) &#123; queue.removeMin(); continue; &#x2F;&#x2F; No action required, poll queue again &#125; currentTime &#x3D; System.currentTimeMillis(); executionTime &#x3D; task.nextExecutionTime; if (taskFired &#x3D; (executionTime&lt;&#x3D;currentTime)) &#123; if (task.period &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; Non-repeating, remove queue.removeMin(); task.state &#x3D; TimerTask.EXECUTED; &#125; else &#123; &#x2F;&#x2F; Repeating task, reschedule queue.rescheduleMin( task.period&lt;0 ? currentTime - task.period : executionTime + task.period); &#125; &#125; &#125; if (!taskFired) &#x2F;&#x2F; Task hasn&#39;t yet fired; wait queue.wait(executionTime - currentTime); &#125; if (taskFired) &#x2F;&#x2F; Task fired; run it, holding no locks task.run(); &#125; catch(InterruptedException e) &#123; &#125; &#125; &#125;&#125; 可以看到wait方法，之前的notify就是通知到这个wait，然后clear方法在notify之前做了清空数组的操作，所以会break，线程执行结束，退出。 Listener中的Timer很多业务中需要Timer一直执行，不会执行一次后就关闭，上面的例子中，timer调用cancel方法后，该timer就被关闭了。 监听器的实现方式有多种，这里我们说一下实现ServletContextListener接口。该接口中有2个方法 12345public interface ServletContextListener extends EventListener &#123; void contextInitialized(ServletContextEvent var1); void contextDestroyed(ServletContextEvent var1);&#125; 即上下文的初始化和销毁。 我们来看一个实例Listener 1234567891011121314public class MyListener implements ServletContextListener &#123; private Log log &#x3D; LogFactory.getLog(MyListener.class); @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; Timer timer &#x3D; new Timer(); timer.schedule(new MyTask(),5000,5000); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; &#125;&#125; Task 1234567public class MyTask extends TimerTask &#123; @Override public void run() &#123; System.out.println(&quot;timer 正在执行&quot;); &#125;&#125; 这样当程序启动的时候，在监听器的初始化中，timer会梅5秒执行一次 1234timer 正在执行timer 正在执行timer 正在执行timer 正在执行 此次程序中我们没有去调用timer的cancel方法，这样会存在一个问题，就是产生的timer一直不会被关闭，就像上面说的只有当系统的垃圾收集被调用的时候才会对其进行回收终止。 同时tomcat日志会打印错误 1234528-Apr-2020 14:23:24.892 警告 [http-nio-8080-exec-23] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads Web应用程序[nyzft]似乎启动了一个名为[Timer-3]的线程，但未能停止它。这很可能会造成内存泄漏。线程的堆栈跟踪：[ java.lang.Object.wait(Native Method) java.lang.Object.wait(Object.java:502) java.util.TimerThread.mainLoop(Timer.java:526) java.util.TimerThread.run(Timer.java:505)] 问题的原因就是我们没有手动去关闭timer，但是如果去调用cancel方法，真实的场景timer只会被执行一次，不符合业务要求。因此可以通过listener的contextDestroyed去关闭timer 12345678910111213141516171819public class MyListener implements ServletContextListener &#123; private Log log &#x3D; LogFactory.getLog(MyListener.class); private Timer timer; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; timer &#x3D; new Timer(); timer.schedule(new MyTask(),5000,5000); System.out.println(&quot;执行&quot;); &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; timer.cancel(); System.out.println(&quot;关闭&quot;); &#125;&#125; 启动程序，过几秒钟后再关闭程序，查看控制台输出 123456789101112131415161718192021执行timer 正在执行timer 正在执行[2020-04-29 09:44:19,609] Artifact ssm-nyzft:war exploded: Artifact is deployed successfully[2020-04-29 09:44:19,609] Artifact ssm-nyzft:war exploded: Deploy took 38,550 millisecondstimer 正在执行timer 正在执行timer 正在执行timer 正在执行E:\\Kit\\Tomcat\\tomcat8\\apache-tomcat-8.5.39\\bin\\catalina.bat stopDisconnected from the target VM, address: &#39;127.0.0.1:52706&#39;, transport: &#39;socket&#39;Using CATALINA_BASE: &quot;C:\\Users\\Administrator\\.IntelliJIdea2019.1\\system\\tomcat\\Unnamed_ssm-nyzft_2&quot;Using CATALINA_HOME: &quot;E:\\Kit\\Tomcat\\tomcat8\\apache-tomcat-8.5.39&quot;Using CATALINA_TMPDIR: &quot;E:\\Kit\\Tomcat\\tomcat8\\apache-tomcat-8.5.39\\temp&quot;Using JRE_HOME: &quot;E:\\Kit\\JDK\\JDK&quot;Using CLASSPATH: &quot;E:\\Kit\\Tomcat\\tomcat8\\apache-tomcat-8.5.39\\bin\\bootstrap.jar;E:\\Kit\\Tomcat\\tomcat8\\apache-tomcat-8.5.39\\bin\\tomcat-juli.jar&quot;29-Apr-2020 09:44:40.511 淇℃伅 [main] org.apache.catalina.core.StandardServer.await A valid shutdown command was received via the shutdown port. Stopping the Server instance.29-Apr-2020 09:44:40.512 淇℃伅 [main] org.apache.coyote.AbstractProtocol.pause Pausing ProtocolHandler [&quot;http-nio-8081&quot;]29-Apr-2020 09:44:40.638 淇℃伅 [main] org.apache.coyote.AbstractProtocol.pause Pausing ProtocolHandler [&quot;ajp-nio-8009&quot;]29-Apr-2020 09:44:40.750 淇℃伅 [main] org.apache.catalina.core.StandardService.stopInternal Stopping service [Catalina]关闭","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"Timer","slug":"Timer","permalink":"http://www.lida1024.top/tags/Timer/"}]},{"title":"Java并发编程图谱","slug":"Java并发编程图谱","date":"2020-04-20T02:20:00.000Z","updated":"2020-04-29T03:04:52.867Z","comments":true,"path":"2020/04/20/Java并发编程图谱/","link":"","permalink":"http://www.lida1024.top/2020/04/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9B%BE%E8%B0%B1/","excerpt":"","text":"","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.lida1024.top/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"Java并发编程(一)CAS","slug":"Java并发编程-一-CAS","date":"2020-04-20T00:06:00.000Z","updated":"2020-04-29T03:05:14.120Z","comments":true,"path":"2020/04/20/Java并发编程-一-CAS/","link":"","permalink":"http://www.lida1024.top/2020/04/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%80-CAS/","excerpt":"","text":"CAS 是什么CAS 的全称 Compare-And-Swap，它是一条 CPU 并发。 它的功能是判断内存某一个位置的值是否为预期，如果是则更改这个值，这个过程就是原子的。 CAS 并发原体现在 JAVA 语言中就是 sun.misc.Unsafe 类中的各个方法。调用 UnSafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令。这是一种完全依赖硬件的功能，通过它实现了原子操作。由于 CAS 是一种系统源语，源语属于操作系统用语范畴，是由若干条指令组成，用于完成某一个功能的过程，并且原语的执行必须是连续的，在执行的过程中不允许被中断，也就是说 CAS 是一条原子指令，不会造成所谓的数据不一致的问题。 比较并交换CAS的意思就是比较并交换。上面说到，这个比较过程是原子的。我们新建一个测试类。 123456789101112131415public class CASDemo &#123; public static void main(String[] args) &#123; checkCAS(); &#125; public static void checkCAS()&#123; AtomicInteger atomicInteger &#x3D; new AtomicInteger(5); System.out.println(atomicInteger.compareAndSet(5, 2019) + &quot;\\t current data is &quot; + atomicInteger.get()); System.out.println(atomicInteger.compareAndSet(5, 2020) + &quot;\\t current data is &quot; + atomicInteger.get()); &#125; atomicInteger.getAndIncrement(); System.out.println(&quot;current data is &quot; + atomicInteger.get());&#125; 查看返回结果 123true current data is 2019false current data is 2019current data is 2020 原子整型类的初始值是5，当第一次调用compareAndSet的时候期望值是5，更新值是2019，此时的期望值和atomicInteger 值相等，则替换为更新值，输出为2019；第二次调用compareAndSet的时候期望值还是5，此时atomicInteger的值已经更新为2019，期望值和原始值不想等，不做更新操作，所以此时的atomicInteger值还是2019。 compareAndSet是AtomicInteger的一个方法 123456789101112&#x2F;** * Atomically sets the value to the given updated value * if the current value &#123;@code &#x3D;&#x3D;&#125; the expected value. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that * the actual value was not equal to the expected value. *&#x2F; public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; 他调用的是unsafe类的compareAndSwapInt方法，this表示当前值对象，valueOffset是当前对象在内存中的偏移量，expect为期望值，update为更新值。 原子性需要说到 atomicInteger.getAndIncrement();这个方法，类似于i++。 12345678&#x2F;** * Atomically increments by one the current value. * * @return the previous value *&#x2F;public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 也是调用的unsafe类的方法。来看一下getAndAddInt： 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 &#x3D; this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; var1为当前对象，var2为当前对象在内存中的偏移量，var4为1，var5为getIntVolatile(var1, var2)的返回值，getIntVolatile方法的意思是当前对象var1且内存偏移量为var2时的值是多少。 在while循环中，同样调用了compareAndSwapInt方法，此时的var5为期望值，var5+var4为更新值。直到比较成功。 Unsafe类unsafe类是CAS的核心类，由于java无法直接访问底层系统，需要通过本地（native）方法来访问，基于unsafe类可直接操作特定内存的数据unsafe类存在于sun.mics包中，其内部方法可以像c的指针一样直接操作内存。因为 Java 中 CAS 操作执行依赖于 Unsafe 类。 变量 vauleOffset，表示该变量值在内存中的偏移量，因为 Unsafe 就是根据内存偏移量来获取数据的。 变量 value 用 volatile 修饰，保证了多线程之间的内存可见性。 123456789101112131415161718public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID &#x3D; 6214790243416807050L; &#x2F;&#x2F; setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; &#x2F;&#x2F; 获取下面 value 的地址偏移量 valueOffset &#x3D; unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; &#x2F;&#x2F; ...&#125; CAS 的缺点 循环时间长开销很大 如果 CAS 失败，会一直尝试，如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销（比如线程数很多，每次比较都是失败，就会一直循环），所以希望是线程数比较小的场景。 只能保证一个共享变量的原子操作 对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性。 引出 ABA 问题 ABA 问题原子引用123456789101112131415161718public class AtomicRefrenceDemo &#123; public static void main(String[] args) &#123; User z3 &#x3D; new User(&quot;张三&quot;, 22); User l4 &#x3D; new User(&quot;李四&quot;, 23); AtomicReference&lt;User&gt; atomicReference &#x3D; new AtomicReference&lt;&gt;(); atomicReference.set(z3); System.out.println(atomicReference.compareAndSet(z3, l4) + &quot;\\t&quot; + atomicReference.get().toString()); System.out.println(atomicReference.compareAndSet(z3, l4) + &quot;\\t&quot; + atomicReference.get().toString()); &#125;&#125;@Getter@ToString@AllArgsConstructorclass User &#123; String userName; int age;&#125; ABA 问题是怎么产生的123456789101112131415161718192021public class ABADemo &#123; private static AtomicReference&lt;Integer&gt; atomicReference &#x3D; new AtomicReference&lt;&gt;(100); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; atomicReference.compareAndSet(100, 101); atomicReference.compareAndSet(101, 100); &#125;).start(); new Thread(() -&gt; &#123; &#x2F;&#x2F; 保证上面线程先执行 try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; atomicReference.compareAndSet(100, 2019); System.out.println(atomicReference.get()); &#x2F;&#x2F; 2019 &#125;).start(); &#125;&#125; 当有一个值从 A 改为 B 又改为 A，这就是 ABA 问题。 ABA 问题解决时间戳原子引用 123456789101112131415161718192021222324252627282930public class ABADemo2 &#123; private static AtomicStampedReference&lt;Integer&gt; atomicStampedReference &#x3D; new AtomicStampedReference&lt;&gt;(100, 1); public static void main(String[] args) &#123; new Thread(() -&gt; &#123; int stamp &#x3D; atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName() + &quot; 的版本号为：&quot; + stamp); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1 ); atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1 ); &#125;).start(); new Thread(() -&gt; &#123; int stamp &#x3D; atomicStampedReference.getStamp(); System.out.println(Thread.currentThread().getName() + &quot; 的版本号为：&quot; + stamp); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; boolean b &#x3D; atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1); System.out.println(b); &#x2F;&#x2F; false System.out.println(atomicStampedReference.getReference()); &#x2F;&#x2F; 100 &#125;).start(); &#125;&#125; 输出结果 1234Thread-0 的版本号为：1Thread-1 的版本号为：1false100","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.lida1024.top/tags/%E5%B9%B6%E5%8F%91/"},{"name":"CAS","slug":"CAS","permalink":"http://www.lida1024.top/tags/CAS/"}]},{"title":"JVM&GC(一)java引用","slug":"JVM-GC-一-java引用","date":"2020-04-16T09:39:00.000Z","updated":"2020-04-16T09:44:17.660Z","comments":true,"path":"2020/04/16/JVM-GC-一-java引用/","link":"","permalink":"http://www.lida1024.top/2020/04/16/JVM-GC-%E4%B8%80-java%E5%BC%95%E7%94%A8/","excerpt":"","text":"前言Java中的引用有点像C++中的指针，通过引用可以对堆中的对象进行操作。在Java程序中最常见的引用类型是强引用，也是默认的引用类型。当在Java语言中使用New操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。 Jva中的引用Java中提供了四个级别的引用，强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。 强引用在一个线程内，无需引用直接可以使用的对象，除非引用不存在了，否则强引用不会被GC清理。JVM即使抛出OOM异常，也不会回收强引用所指向的对象。强引用可能导致内存泄漏问。 123String str &#x3D; &quot;hello&quot;;String str1 &#x3D; str;System.out.println(str&#x3D;&#x3D;str1); str变量将被分配到栈内，而“hello”对象则被分配在java堆中。局部变量str指向“hello”实例所在的堆空间，通过str可以操作该实例。此时str就是该实例的引用。str1 = str此时，str所指向的对象也被str1所指向，同时会在局部栈空间上分配空间存放str1变量。对引用使用==比较的是两个引用所指向的堆空间的地址是否相同。 软引用软引用是除了强引用外，最强的引用类型。用来描述一些还有用但是并非必须的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。 12345Object obj &#x3D; new Object();SoftReference&lt;Object&gt; sf &#x3D; new SoftReference&lt;Object&gt;(obj);obj &#x3D; null;sf.get();&#x2F;&#x2F;有时候会返回null&#x2F;&#x2F;sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当这个对象被标记为需要回收的对象时，则返回null； SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。一旦垃圾线程回收该Java对象之后，get()方法将返回null。 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。使用软引用能防止内存泄露，增强程序的健壮性。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。当调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。在任何时候，都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，可以检查哪个SoftReference所软引用的对象已经被回收，于是可以把这些失去所软引用的对象的SoftReference对象清除掉。 Java虚拟机会尽量让软引用存活的时间长一些，迫不得以才清理。 1234567891011import java.lang.ref.SoftReference; public class TestRef &#123; public static void main(String args[]) &#123; SoftReference&lt;String&gt; str &#x3D; new SoftReference&lt;String&gt;(new String(&quot;abc&quot;)); System.out.println(str.get()); &#x2F;&#x2F;通知JVM进行内存回收 System.gc(); System.out.println(str.get()); &#125;&#125; 弱引用在java中，可以用java.lang.ref.WeakReference实例来保存对一个Java对象的弱引用。 12345Object obj &#x3D; new Object();WeakReference&lt;Object&gt; wf &#x3D; new WeakReference&lt;Object&gt;(obj);obj &#x3D; null;wf.get();&#x2F;&#x2F;有时候会返回nullwf.isEnQueued();&#x2F;&#x2F;返回是否被垃圾回收器标记为即将回收的垃圾 当GC进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易，更快的被GC回收。弱引用对象尝尝用于Map结构中，引用数据量比较大的对象，一旦该对象的强引用为null时，GC能够快速的回收该对象空间。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。 1234567891011import java.lang.ref.WeakReference; public class TestRef &#123; public static void main(String args[]) &#123; WeakReference&lt;String&gt; str &#x3D; new WeakReference&lt;String&gt;(new String(&quot;abc&quot;)); System.out.println(str.get()); &#x2F;&#x2F;通知JVM进行内存回收 System.gc(); System.out.println(str.get()); &#125;&#125; 虚引用又称为幽灵引用，主要目的是在一个对象所占的内存被实际回收之前的到通知，从而可以进行一些相关的清理工作。幽灵引用在创建是必须提供一个引用队列作为参数，它的作用在于检测对象是否已经从内存中删除，跟踪垃圾回收过程。其次幽灵引用对象的get方法总是返回null，因此无法通过幽灵引用来获取被引用的对象。 12345Object obj &#x3D; new Object();PhantomReference&lt;Object&gt; pf &#x3D; new PhantomReference&lt;Object&gt;(obj);obj&#x3D;null;pf.get();&#x2F;&#x2F;永远返回nullpf.isEnQueued();&#x2F;&#x2F;返回是否从内存中已经删除 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 1234567891011import java.lang.ref.PhantomReference;import java.lang.ref.ReferenceQueue; public class TestRef &#123; public static void main(String args[]) &#123; ReferenceQueue&lt;String&gt; queue &#x3D; new ReferenceQueue&lt;&gt;(); PhantomReference&lt;String&gt; str &#x3D; new PhantomReference&lt;String&gt;(&quot;abc&quot;, queue); System.out.println(str.get()); &#125;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.lida1024.top/tags/JVM/"}]},{"title":"Nginx实现负载均衡","slug":"Nginx实现负载均衡","date":"2020-04-11T05:47:00.000Z","updated":"2020-04-11T06:06:36.931Z","comments":true,"path":"2020/04/11/Nginx实现负载均衡/","link":"","permalink":"http://www.lida1024.top/2020/04/11/Nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"负载均衡即是代理服务器将接收的请求均衡的分发到各服务器中。 负载均衡的优势在访问量少或并发小的时候可能并不明显，且不说淘宝双11、铁道部抢票这种级别的访问量、高并发，就是一般网站的抢购活动时，也会给服务器造成很大压力，可能会造成服务器崩溃。而负载均衡可以很明显的减少甚至消除这种情况的出现，下面我们说说实现方法。 准备工作 首先下载安装Nginx。 下载完成解压到本地盘符。解压后是这样的 注意：nginx.exe是启动的程序，为了方便我们可以手写两个bat文件： 我将nginx解压到了我本地的E盘 reload.bat 123E:cd kit\\nginx-1.14.0\\nginx -s reload stop.bat 123E:cd kit\\nginx-1.14.0\\nginx -s stop 我们双击nginx.exe就可以启动nginx，我们启动一下，打开任务 管理器看到 就说明启动成功。 接下来配置两个tomcat来进行测试，下面是我本地的tomcat，存放在E盘中。 拷贝一份放到我的D盘中，并修改端口号，默认 为8080，我们将D盘中的tomcat端口号修改为8082，将E盘中的tomcat端口号修改为8081。 端口号的修改： 找到conf 修改 修改如下： 12345678910111213141516171819202122232425262728293031323334&lt;Server port&#x3D;&quot;8006&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt; &lt;Listener className&#x3D;&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine&#x3D;&quot;on&quot; &#x2F;&gt; &lt;Listener className&#x3D;&quot;org.apache.catalina.core.JasperListener&quot; &#x2F;&gt; &lt;Listener className&#x3D;&quot;org.apache.catalina.mbeans.ServerLifecycleListener&quot; &#x2F;&gt; &lt;Listener className&#x3D;&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; &#x2F;&gt; &lt;GlobalNamingResources&gt; &lt;Resource name&#x3D;&quot;UserDatabase&quot; auth&#x3D;&quot;Container&quot; type&#x3D;&quot;org.apache.catalina.UserDatabase&quot; description&#x3D;&quot;User database that can be updated and saved&quot; factory&#x3D;&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot; pathname&#x3D;&quot;conf&#x2F;tomcat-users.xml&quot; &#x2F;&gt; &lt;&#x2F;GlobalNamingResources&gt; &lt;Service name&#x3D;&quot;Catalina&quot;&gt; &lt;Connector port&#x3D;&quot;8082&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; connectionTimeout&#x3D;&quot;20000&quot; redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt; &lt;Connector port&#x3D;&quot;8010&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt; &lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt; &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.UserDatabaseRealm&quot; resourceName&#x3D;&quot;UserDatabase&quot;&#x2F;&gt; &lt;Host name&#x3D;&quot;localhost&quot; appBase&#x3D;&quot;webapps&quot; unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot; xmlValidation&#x3D;&quot;false&quot; xmlNamespaceAware&#x3D;&quot;false&quot;&gt; &lt;&#x2F;Host&gt; &lt;&#x2F;Engine&gt; &lt;&#x2F;Service&gt;&lt;&#x2F;Server&gt; 将E盘中的tomcat端口号修改为8081；只需修改默认文件中的一点 1234&lt;Connector port&#x3D;&quot;8081&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; connectionTimeout&#x3D;&quot;20000&quot; redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt; 配置nginx的配置文件： 找到文件中的server节点，然后再上面添加 1234upstream local_tomcat_test &#123; server localhost:8082 weight&#x3D;8 max_fails&#x3D;3 fail_timeout&#x3D;30s; server localhost:8081 weight&#x3D;2 max_fails&#x3D;3 fail_timeout&#x3D;30s; &#125; 然后修改server: 123456789101112upstream local_tomcat_test &#123; server localhost:8082 weight&#x3D;8 max_fails&#x3D;3 fail_timeout&#x3D;30s; server localhost:8081 weight&#x3D;2 max_fails&#x3D;3 fail_timeout&#x3D;30s; &#125; server &#123; listen 80; server_name localhost; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;local_tomcat_test; #root html; #index index.html index.htm &#125; 配置完成后，启动两个tomcat，为了区分是哪个tomcat，我把tomcat的默认访问页进行了修改。 然后我们再地址栏输入localhost,试试效果： 访问了tomcat-8082,刷新一下： 可以看到访问了tomcat-8081 各参数的含义： 123456789worker_processes：工作进程个数，可配置多个worker_connections:单个进程最大连接数server:每一个server相当于一个代理服务器lister:监听端口，默认80server_name:当前服务的域名，可以有多个，用空格分隔(我们是本地所以是localhost)location：表示匹配的路径，这时配置了&#x2F;表示所有请求都被匹配到这里index：当没有指定主页时，默认会选择这个指定的文件，可多个，空格分隔proxy_pass：请求转向自定义的服务器列表upstream name&#123; &#125;:服务器集群名称 小结 nginx作为一个反向代理服务器，能缓存我们项目的静态文件，并实现反向代理与均衡负载，可以有效减少服务器压力，即使项目不大，也可以使用。 大家另外应该都还发现了个问题，虽然这样请求能分别请求到两个tomcat上，如果是一般不需身份校检的或什么认证的方法尚可，但如果出现这类情况： 我们在tomcat1上进行了登录，这时用户session当然是存在tomcat1上的，而这时进入个人中心的请求请求到tomcat2上了，这时就会出现问题了。tomcat2会告诉你还未登录，这显然不是我们想看到的。 这就涉及到session共享了，如何让两个服务器上的session共用。我这里放到下次再说，可能要过个好几天。 感谢大家支持。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Tools","slug":"Dev/Tools","permalink":"http://www.lida1024.top/categories/Dev/Tools/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://www.lida1024.top/tags/Nginx/"}],"author":"少年闰土"},{"title":"MySql中InnoDB表为什么要建议用自增列做主键","slug":"MySql中InnoDB表为什么要建议用自增列做主键","date":"2020-04-10T05:55:00.000Z","updated":"2020-04-11T09:10:44.173Z","comments":true,"path":"2020/04/10/MySql中InnoDB表为什么要建议用自增列做主键/","link":"","permalink":"http://www.lida1024.top/2020/04/10/MySql%E4%B8%ADInnoDB%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BB%BA%E8%AE%AE%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E5%81%9A%E4%B8%BB%E9%94%AE/","excerpt":"","text":"InnoDB引擎表的特点1、InnoDB引擎表是基于B+树的索引组织表(IOT)关于B+树 B+ 树的特点: 所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的; 不可能在非叶子结点命中; 非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层; 2、主键(PRIMARY KEY)如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。 3、主索引数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点） 4、自增主键如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页 5、非自增主键如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。 总结如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的，也就是下面这几种情况的存取效率最高：1、使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致； 2、该表不指定自增列做主键，同时也没有可以被选为主键的唯一索引(上面的条件)，这时候InnoDB会选择内置的ROWID作为主键，写入顺序和ROWID增长顺序一致；除此以外，如果一个InnoDB表又没有显示主键，又有可以被选择为主键的唯一索引，但该唯一索引可能不是递增关系时(例如字符串、UUID、多字段联合唯一索引的情况)，该表的存取效率就会比较差。 《高性能MySQL》中的原话","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"DataBase","slug":"Dev/DataBase","permalink":"http://www.lida1024.top/categories/Dev/DataBase/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.lida1024.top/tags/Mysql/"}]},{"title":"Sentinel入门","slug":"Sentinel入门","date":"2020-04-01T07:39:00.000Z","updated":"2020-04-10T02:28:24.252Z","comments":true,"path":"2020/04/01/Sentinel入门/","link":"","permalink":"http://www.lida1024.top/2020/04/01/Sentinel%E5%85%A5%E9%97%A8/","excerpt":"","text":"前言Sentinel 是什么？随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 Sentinel 的历史 2012 年，Sentinel 诞生，主要功能为入口流量控制。 2013-2017 年，Sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。Sentinel 也因此积累了大量的流量归整场景以及生产实践。 2018 年，Sentinel 开源，并持续演进。 2019 年，Sentinel 朝着多语言扩展的方向不断探索，推出 C++ 原生版本，同时针对 Service Mesh 场景也推出了 Envoy 集群流量控制支持，以解决 Service Mesh 架构下多语言限流的问题。 2020 年，推出 Sentinel Go 版本，继续朝着云原生方向演进。 Sentinel 特征 丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。 完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。 广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。 完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。 Sentinel 的主要特性 Sentinel 的开源生态 Sentinel 分为两个部分 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。 快速开始1.添加pom依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;sentinel-core&lt;&#x2F;artifactId&gt; &lt;version&gt;1.7.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 注意: 从 Sentinel 1.5.0 开始仅支持 JDK 1.7 或者以上版本。Sentinel 1.5.0 之前的版本最低支持 JDK 1.6。 2.定义资源接下来，我们把需要控制流量的代码用 Sentinel API SphU.entry(“HelloWorld”) 和 entry.exit() 包围起来即可。 123456789101112131415161718192021public static void main(String[] args) &#123; &#x2F;&#x2F; 配置规则. initFlowRules(); while (true) &#123; Entry entry &#x3D; null; try &#123; entry &#x3D; SphU.entry(&quot;HelloWorld&quot;); &#x2F;*您的业务逻辑 - 开始*&#x2F; System.out.println(&quot;hello world&quot;); &#x2F;*您的业务逻辑 - 结束*&#x2F; &#125; catch (BlockException e1) &#123; &#x2F;*流控逻辑处理 - 开始*&#x2F; System.out.println(&quot;block!&quot;); &#x2F;*流控逻辑处理 - 结束*&#x2F; &#125; finally &#123; if (entry !&#x3D; null) &#123; entry.exit(); &#125; &#125; &#125;&#125; 3.定义规则接下来，通过规则来指定允许该资源通过的请求次数，例如下面的代码定义了资源 HelloWorld 每秒最多只能通过 20 个请求。 12345678910private static void initFlowRules()&#123; List&lt;FlowRule&gt; rules &#x3D; new ArrayList&lt;&gt;(); FlowRule rule &#x3D; new FlowRule(); rule.setResource(&quot;HelloWorld&quot;); rule.setGrade(RuleConstant.FLOW_GRADE_QPS); &#x2F;&#x2F; Set limit QPS to 20. rule.setCount(20); rules.add(rule); FlowRuleManager.loadRules(rules);&#125; 注解支持Sentinel 提供了 @SentinelResource 注解用于定义资源，并提供了 AspectJ 的扩展用于自动定义资源、处理 BlockException 等。使用 Sentinel Annotation AspectJ Extension 的时候需要引入以下依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;sentinel-annotation-aspectj&lt;&#x2F;artifactId&gt; &lt;version&gt;x.y.z&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 将 SentinelResourceAspect 注册为一个 Spring Bean 12345678@Configurationpublic class SentinelAspectConfiguration &#123; @Bean public SentinelResourceAspect sentinelResourceAspect() &#123; return new SentinelResourceAspect(); &#125;&#125; 示例代码 1234567891011121314151617181920212223242526public class TestService &#123; &#x2F;&#x2F; 对应的 &#96;handleException&#96; 函数需要位于 &#96;ExceptionUtil&#96; 类中，并且必须为 static 函数. @SentinelResource(value &#x3D; &quot;test&quot;, blockHandler &#x3D; &quot;handleException&quot;, blockHandlerClass &#x3D; &#123;ExceptionUtil.class&#125;) public void test() &#123; System.out.println(&quot;Test&quot;); &#125; &#x2F;&#x2F; 原函数 @SentinelResource(value &#x3D; &quot;hello&quot;, blockHandler &#x3D; &quot;exceptionHandler&quot;, fallback &#x3D; &quot;helloFallback&quot;) public String hello(long s) &#123; return String.format(&quot;Hello at %d&quot;, s); &#125; &#x2F;&#x2F; Fallback 函数，函数签名与原函数一致或加一个 Throwable 类型的参数. public String helloFallback(long s) &#123; return String.format(&quot;Halooooo %d&quot;, s); &#125; &#x2F;&#x2F; Block 异常处理函数，参数最后多一个 BlockException，其余与原函数一致. public String exceptionHandler(long s, BlockException ex) &#123; &#x2F;&#x2F; Do some log here. ex.printStackTrace(); return &quot;Oops, error occurred at &quot; + s; &#125;&#125; 代码实战新建一个SpringBoot的项目 1.pom依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;groupId&gt;com.example.sentinel&lt;&#x2F;groupId&gt; &lt;artifactId&gt;sentinel-demo&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;name&gt;sentinel-demo&lt;&#x2F;name&gt; &lt;description&gt;sentinel demo&lt;&#x2F;description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;spring.boot.version&gt;2.2.1.RELEASE&lt;&#x2F;spring.boot.version&gt; &lt;sentinel.version&gt;1.7.0&lt;&#x2F;sentinel.version&gt; &lt;&#x2F;properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.boot.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.boot.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;spring.boot.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;sentinel-core&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;sentinel.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;sentinel-annotation-aspectj&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;sentinel.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;sentinel-transport-simple-http&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;sentinel.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 2.Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.example.sentinel.sentineldemo.controller;import com.alibaba.csp.sentinel.Entry;import com.alibaba.csp.sentinel.SphU;import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.example.sentinel.sentineldemo.service.TestSentinelService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;&#x2F;** * @Author: Monday * @Date: 2020&#x2F;4&#x2F;1 0001 上午 11:44 * @Description: *&#x2F;@Controller@RequestMapping(&quot;test&quot;)public class TestSentinelController &#123; private static final String KEY &#x3D; &quot;queryOne&quot;; @Autowired private TestSentinelService testSentinelService; &#x2F;** * 代码不加任何限流 熔断 * * @return *&#x2F; @RequestMapping(&quot;&#x2F;getValue_0&quot;) @ResponseBody @SentinelResource(&quot;queryZero&quot;) public String getValue_0(@RequestParam(&quot;key&quot;) String key) &#123; return testSentinelService.getValue_0(key); &#125; &#x2F;** * 限流实现方式一: 抛出异常的方式定义资源 * * @param key * @return *&#x2F; @RequestMapping(&quot;&#x2F;getValue_1&quot;) @ResponseBody public String getValue_1(@RequestParam(&quot;key&quot;) String key) &#123; Entry entry &#x3D; null; &#x2F;&#x2F; 资源名 String resourceName &#x3D; KEY; try &#123; &#x2F;&#x2F; entry可以理解成入口登记 entry &#x3D; SphU.entry(resourceName); &#x2F;&#x2F; 被保护的逻辑, 这里为查询接口 return testSentinelService.getValue_1(key); &#125; catch (BlockException blockException) &#123; &#x2F;&#x2F; 接口被限流的时候, 会进入到这里 return &quot;接口限流, 返回空&quot;; &#125; finally &#123; &#x2F;&#x2F; SphU.entry(xxx) 需要与 entry.exit() 成对出现,否则会导致调用链记录异常 if (entry !&#x3D; null) &#123; entry.exit(); &#125; &#125; &#125; &#x2F;** * 限流实现方式二: 注解定义资源 * * @param key * @return *&#x2F; @RequestMapping(&quot;&#x2F;getValue_2&quot;) @ResponseBody public String getValue_2(@RequestParam(&quot;key&quot;) String key) &#123; String res &#x3D; testSentinelService.getValue_2(key); return res; &#125;&#125; 3.Service123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.example.sentinel.sentineldemo.service;import com.alibaba.csp.sentinel.annotation.SentinelResource;import com.alibaba.csp.sentinel.slots.block.BlockException;import com.alibaba.csp.sentinel.slots.block.RuleConstant;import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule;import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRuleManager;import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;import com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import java.util.ArrayList;import java.util.List;&#x2F;** * @Author: Monday * @Date: 2020&#x2F;4&#x2F;1 0001 上午 11:45 * @Description: 商品查询接口 *&#x2F;@Component@Slf4jpublic class TestSentinelService &#123; private static final String KEY &#x3D; &quot;queryTwo&quot;; &#x2F;** * 代码不加任何限流 熔断 * * @param key * @return *&#x2F; public String getValue_0(String key) &#123; System.out.println(&quot;获取Value:&quot; + key); return &quot;return value :&quot; + key; &#125; &#x2F;** * 抛出异常的方式定义资源 * * @param key * @return *&#x2F; public String getValue_1(String key) &#123; System.out.println(&quot;获取Value:&quot; + key); return &quot;return value :&quot; + key; &#125; &#x2F;** * 注解定义资源 * * @param key * @return *&#x2F; @SentinelResource(value &#x3D; KEY, blockHandler &#x3D; &quot;blockHandlerMethod&quot;, fallback &#x3D; &quot;queryFallback&quot;) public String getValue_2(String key) &#123; &#x2F;&#x2F; 模拟调用服务出现异常 if (&quot;0&quot;.equals(key)) &#123; throw new RuntimeException(); &#125; return &quot;query value success, &quot; + key; &#125; public String blockHandlerMethod(String key, BlockException e) &#123; return &quot;queryValue error, blockHandlerMethod res: &quot; + key; &#125; public String queryFallback(String key, Throwable e) &#123; return &quot;queryValue error, return fallback res: &quot; + key; &#125; &#x2F;** * 初始化限流配置 *&#x2F; @PostConstruct public void initDegradeRule() &#123; List&lt;FlowRule&gt; rules &#x3D; new ArrayList&lt;FlowRule&gt;(); FlowRule rule1 &#x3D; new FlowRule(); rule1.setResource(KEY); &#x2F;&#x2F; QPS控制在2以内 rule1.setCount(2); &#x2F;&#x2F; QPS限流 rule1.setGrade(RuleConstant.FLOW_GRADE_QPS); rule1.setLimitApp(&quot;default&quot;); rules.add(rule1); FlowRuleManager.loadRules(rules); &#125;&#125; 4.控制台4.1下载从 release 页面 下载截止目前为止最新版本的控制台 jar 包 注意：启动 Sentinel 控制台需要 JDK 版本为 1.8 及以上版本 从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的 登录 功能，默认用户名和密码都是 sentinel 用户可以通过如下参数进行配置 -Dsentinel.dashboard.auth.username=sentinel 用于指定控制台的登录用户名为 sentinel -Dsentinel.dashboard.auth.password=123456 用于指定控制台的登录密码为 123456；如果省略这两个参数，默认用户和密码均为 sentinel -Dserver.servlet.session.timeout=7200 用于指定 Spring Boot 服务端 session 的过期时间，如 7200 表示 7200 秒；60m 表示 60 分钟，默认为 30 分钟 4.2启动1java -jar sentinel-dashboard-1.7.1.jar 访问http://localhost:8080 4.3登录可以看到当前控制台中没有任何的应用，因为还没有应用接入。 5.客户端接入启动了控制台模块后，控制台页面都是空的，需要接入客户端。 5.1导入与控制台通信的jar包12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt; &lt;artifactId&gt;sentinel-transport-simple-http&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;sentinel.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 5.2 配置应用启动参数引入了依赖之后，接着就是在我们的应用中配置 JVM 启动参数，如下所示： 1-Dproject.name&#x3D;xxx -Dcsp.sentinel.dashboard.server&#x3D;consoleIp:port 其中的consoleIp和port对应的就是我们部署的 sentinel dashboard 的ip和port，我这里对应的是 127.0.0.1 和 8080，按照实际情况来配置 dashboard 的ip和port就好了，如下图所示： 5.3 启动应用启动上边的springboot项目 5.4 测试效果本demo中http://localhost:8083/test/getValue_2?key=kobe接口执行多次，会触发限流操作，这时候再去看控制台： 详细说明请参考 官方 Sentinel Wiki","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Sentinel","slug":"Sentinel","permalink":"http://www.lida1024.top/tags/Sentinel/"}]},{"title":"基于CentOS安装Maven","slug":"基于CentOS安装Maven","date":"2020-03-28T07:05:00.000Z","updated":"2020-04-10T03:38:13.994Z","comments":true,"path":"2020/03/28/基于CentOS安装Maven/","link":"","permalink":"http://www.lida1024.top/2020/03/28/%E5%9F%BA%E4%BA%8ECentOS%E5%AE%89%E8%A3%85Maven/","excerpt":"","text":"下载1.通过官网下载Maven官网：http://maven.apache.org/ Maven下载地址：http://maven.apache.org/download.cgi 将下载好的包通过ftp上传到服务器。 2.wget下载这里使用了华中科技大学开源镜像站,网上有很多，自行选择。 1234567891011[root@localhost local]# wget http:&#x2F;&#x2F;mirrors.hust.edu.cn&#x2F;apache&#x2F;maven&#x2F;maven-3&#x2F;3.5.4&#x2F;binaries&#x2F;apache-maven-3.5.4-bin.tar.gz--2020-03-28 09:04:47-- http:&#x2F;&#x2F;mirrors.hust.edu.cn&#x2F;apache&#x2F;maven&#x2F;maven-3&#x2F;3.5.4&#x2F;binaries&#x2F;apache-maven-3.5.4-bin.tar.gz正在解析主机 mirrors.hust.edu.cn (mirrors.hust.edu.cn)... 202.114.18.160正在连接 mirrors.hust.edu.cn (mirrors.hust.edu.cn)|202.114.18.160|:80... 已连接。已发出 HTTP 请求，正在等待回应... 200 OK长度：8842660 (8.4M) [application&#x2F;octet-stream]正在保存至: “apache-maven-3.5.4-bin.tar.gz”100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 8,842,660 5.30MB&#x2F;s 用时 1.6s 2020-03-28 09:04:49 (5.30 MB&#x2F;s) - 已保存 “apache-maven-3.5.4-bin.tar.gz” [8842660&#x2F;8842660]) 解压1tar zxf apache-maven-3.5.4-bin.tar.gz 配置环境变量12345678910cd &#x2F;etcllvi profile#按i进入编辑状态#添加maven的环境变量export M2_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4export PATH&#x3D;$PATH:$M2_HOME&#x2F;bin#编辑完成按Esc退出编辑状态，然后按:wq保存退出。#保存退出后运行下面的命令使配置生效source &#x2F;etc&#x2F;profile 验证 123456[root@localhost etc]# mvn -vApache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)Maven home: &#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4Java version: 1.8.0_241, vendor: Oracle Corporation, runtime: &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_241&#x2F;jreDefault locale: zh_CN, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;3.10.0-957.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot; 配置成功！","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Tools","slug":"Dev/Tools","permalink":"http://www.lida1024.top/categories/Dev/Tools/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://www.lida1024.top/tags/Maven/"}]},{"title":"快速搭建 Git 服务器[Linux版]","slug":"快速搭建-Git-服务器-Linux版","date":"2020-03-27T07:25:00.000Z","updated":"2020-04-11T08:01:52.891Z","comments":true,"path":"2020/03/27/快速搭建-Git-服务器-Linux版/","link":"","permalink":"http://www.lida1024.top/2020/03/27/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA-Git-%E6%9C%8D%E5%8A%A1%E5%99%A8-Linux%E7%89%88/","excerpt":"","text":"下载如果未安装wget,则先安装wget 1yum install wget 安装完成 12345678910111213141516171819202122232425262728293031323334353637383940[root@localhost local]# yum install wget已加载插件：fastestmirrorLoading mirror speeds from cached hostfile * base: mirrors.aliyun.com * epel: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 wget.x86_64.0.1.14-18.el7_6.1 将被 安装--&gt; 解决依赖关系完成依赖关系解决&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Package 架构 版本 源 大小&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正在安装: wget x86_64 1.14-18.el7_6.1 base 547 k事务概要&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;安装 1 软件包总下载量：547 k安装大小：2.0 MIs this ok [y&#x2F;d&#x2F;N]: yDownloading packages:wget-1.14-18.el7_6.1.x86_64.rpm | 547 kB 00:00:00 Running transaction checkRunning transaction testTransaction test succeededRunning transaction 正在安装 : wget-1.14-18.el7_6.1.x86_64 1&#x2F;1 验证中 : wget-1.14-18.el7_6.1.x86_64 1&#x2F;1 已安装: wget.x86_64 0:1.14-18.el7_6.1 完毕！ 下载gitblit 1wget http:&#x2F;&#x2F;dl.bintray.com&#x2F;gitblit&#x2F;releases&#x2F;gitblit-1.8.0.tar.gz 下载完成 12345678910111213141516[root@localhost local]# wget http:&#x2F;&#x2F;dl.bintray.com&#x2F;gitblit&#x2F;releases&#x2F;gitblit-1.8.0.tar.gz--2020-03-27 11:59:22-- http:&#x2F;&#x2F;dl.bintray.com&#x2F;gitblit&#x2F;releases&#x2F;gitblit-1.8.0.tar.gz正在解析主机 dl.bintray.com (dl.bintray.com)... 52.41.180.114, 54.191.3.105正在连接 dl.bintray.com (dl.bintray.com)|52.41.180.114|:80... 已连接。已发出 HTTP 请求，正在等待回应... 302 位置：http:&#x2F;&#x2F;d29vzk4ow07wi7.cloudfront.net&#x2F;d23f30c1fe7d28648d682f387f9a16bfd05cd000da418489d00f04e10279776f?response-content-disposition&#x3D;attachment%3Bfilename%3D%22gitblit-1.8.0.tar.gz%22&amp;Policy&#x3D;eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvZDIzZjMwYzFmZTdkMjg2NDhkNjgyZjM4N2Y5YTE2YmZkMDVjZDAwMGRhNDE4NDg5ZDAwZjA0ZTEwMjc5Nzc2Zj9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmdpdGJsaXQtMS44LjAudGFyLmd6JTIyIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNTg1MjgyMjgzfSwiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjAuMC4wLjAvMCJ9fX1dfQ__&amp;Signature&#x3D;kLEsE2~0a-gSiDvvEPDNqjAuOO8ab7-aqqzuZjDm2sRBZGtPmrkGINTxHEJn~-2hGeQkxX61okj5uV2sq92xSnkPXxSuw9WKJvRPYB35HLdXUTEj2aMbNtKV8J-Dq3eSkQEnLWv7SBOAFn07nrHJE8PpuIy0lKC~ulCXnM1WBmOvr6AWjf3Nla0kLpdBV3HtpCTeTgPNwbCSZYHyqrFtaNI~CQCW8aHQVji-wOLYsy~wyrQ0jjywB8r~P-jSCCAzcyFH7OVqMbJuDsFl63Mw7lK4OVU9jHKKZly6M8GcZXIhqBKS-Ddz9CZ9jHhuoPo5kVhn8jxGsbKHkunv1Zs-Fw__&amp;Key-Pair-Id&#x3D;APKAIFKFWOMXM2UMTSFA [跟随至新的 URL]--2020-03-27 11:59:24-- http:&#x2F;&#x2F;d29vzk4ow07wi7.cloudfront.net&#x2F;d23f30c1fe7d28648d682f387f9a16bfd05cd000da418489d00f04e10279776f?response-content-disposition&#x3D;attachment%3Bfilename%3D%22gitblit-1.8.0.tar.gz%22&amp;Policy&#x3D;eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvZDIzZjMwYzFmZTdkMjg2NDhkNjgyZjM4N2Y5YTE2YmZkMDVjZDAwMGRhNDE4NDg5ZDAwZjA0ZTEwMjc5Nzc2Zj9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmdpdGJsaXQtMS44LjAudGFyLmd6JTIyIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNTg1MjgyMjgzfSwiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjAuMC4wLjAvMCJ9fX1dfQ__&amp;Signature&#x3D;kLEsE2~0a-gSiDvvEPDNqjAuOO8ab7-aqqzuZjDm2sRBZGtPmrkGINTxHEJn~-2hGeQkxX61okj5uV2sq92xSnkPXxSuw9WKJvRPYB35HLdXUTEj2aMbNtKV8J-Dq3eSkQEnLWv7SBOAFn07nrHJE8PpuIy0lKC~ulCXnM1WBmOvr6AWjf3Nla0kLpdBV3HtpCTeTgPNwbCSZYHyqrFtaNI~CQCW8aHQVji-wOLYsy~wyrQ0jjywB8r~P-jSCCAzcyFH7OVqMbJuDsFl63Mw7lK4OVU9jHKKZly6M8GcZXIhqBKS-Ddz9CZ9jHhuoPo5kVhn8jxGsbKHkunv1Zs-Fw__&amp;Key-Pair-Id&#x3D;APKAIFKFWOMXM2UMTSFA正在解析主机 d29vzk4ow07wi7.cloudfront.net (d29vzk4ow07wi7.cloudfront.net)... 13.35.127.69, 13.35.127.111, 13.35.127.37, ...正在连接 d29vzk4ow07wi7.cloudfront.net (d29vzk4ow07wi7.cloudfront.net)|13.35.127.69|:80... 已连接。已发出 HTTP 请求，正在等待回应... 200 OK长度：42063149 (40M) [application&#x2F;gzip]正在保存至: “gitblit-1.8.0.tar.gz”100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 42,063,149 3.57MB&#x2F;s 用时 13s 2020-03-27 11:59:38 (3.07 MB&#x2F;s) - 已保存 “gitblit-1.8.0.tar.gz” [42063149&#x2F;42063149]) 解压我的目录放在/usr/local/下 12cd usr&#x2F;localtar -xf gitblit-1.8.0.tar.gz 修改配置1.更改端口配置 cd gitblit-1.8.0llcd datavi defaults.properties设置修改编辑完成后按ESC 输入:wq 保存退出 123456789101112131415161718192021222324252627282930313233[root@localhost local]# cd gitblit-1.8.0[root@localhost gitblit-1.8.0]# ll总用量 3680-rwxr-xr-x. 1 root root 984 5月 15 2014 add-indexed-branch.sh-rwxr-xr-x. 1 root root 82 4月 20 2014 authority.shdrwxr-xr-x. 6 root root 153 3月 27 14:27 datadrwxr-xr-x. 5 root root 4096 3月 27 14:27 docsdrwxr-xr-x. 2 root root 4096 3月 27 14:27 ext-rw-r--r--. 1 root root 3685177 6月 23 2016 gitblit.jar-rwxr-xr-x. 1 root root 52 4月 20 2014 gitblit.sh-rwxr-xr-x. 1 root root 59 4月 20 2014 gitblit-stop.sh-rwxr-xr-x. 1 root root 87 4月 20 2014 install-service-centos.sh-rwxr-xr-x. 1 root root 1249 11月 23 2015 install-service-fedora.sh-rwxr-xr-x. 1 root root 92 4月 20 2014 install-service-ubuntu.sh-rwxr-xr-x. 1 root root 997 2月 26 2015 java-proxy-config.sh-rw-r--r--. 1 root root 11556 1月 18 2016 LICENSE-rwxr-xr-x. 1 root root 599 6月 17 2014 migrate-tickets.sh-rw-r--r--. 1 root root 12237 1月 18 2016 NOTICE-rwxr-xr-x. 1 root root 641 6月 17 2014 reindex-tickets.sh-rwxr-xr-x. 1 root root 1224 2月 26 2015 service-centos.sh-rwxr-xr-x. 1 root root 1512 5月 15 2014 service-ubuntu.sh[root@localhost gitblit-1.8.0]# cd data[root@localhost data]# ll总用量 88drwxr-xr-x. 2 root root 70 3月 27 14:27 certs-rw-r--r--. 1 root root 65818 6月 23 2016 defaults.propertiesdrwxr-xr-x. 2 root root 25 3月 27 14:27 git-rw-r--r--. 1 root root 535 6月 23 2016 gitblit.propertiesdrwxr-xr-x. 2 root root 4096 3月 27 14:27 gitignoredrwxr-xr-x. 2 root root 274 3月 27 14:27 groovy-rw-r--r--. 1 root root 87 6月 23 2016 projects.conf-rw-r--r--. 1 root root 74 6月 23 2016 users.conf[root@localhost data]# vi defaults.properties 找到server.httpPort，设定http协议的端口号 1234567# Standard http port to serve. &lt;&#x3D; 0 disables this connector.# On Unix&#x2F;Linux systems, ports &lt; 1024 require root permissions.# Recommended value: 80 or 8080## SINCE 0.5.0# RESTART REQUIREDserver.httpPort &#x3D; 7070 找到server.httpBindInterface，设定服务器的IP地址。这里就设定你的服务器IP。 12345678# Specify the interface for Jetty to bind the standard connector.# You may specify an ip or an empty value to bind to all interfaces.# Specifying localhost will result in Gitblit ONLY listening to requests to# localhost.## SINCE 0.5.0# RESTART REQUIREDserver.httpBindInterface &#x3D; 192.168.1.70 找到server.httpsBindInterface，设定为本机的ip 12345678# Specify the interface for Jetty to bind the secure connector.# You may specify an ip or an empty value to bind to all interfaces.# Specifying localhost will result in Gitblit ONLY listening to requests to# localhost.## SINCE 0.5.0# RESTART REQUIREDserver.httpsBindInterface &#x3D; 192.168.1.70 server.httpsPort = 8443 保持默认不用修改 2.改变路径配置 vi service-centos.sh设置修改编辑完成后按ESC 输入:wq 保存退出 12345GITBLIT_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;gitblit-1.8.0GITBLIT_BASE_FOLDER&#x3D;&#x2F;usr&#x2F;local&#x2F;gitblit-1.8.0&#x2F;dataGITBLIT_HTTP_PORT&#x3D;7070GITBLIT_HTTPS_PORT&#x3D;8443GITBLIT_LOG&#x3D;&#x2F;var&#x2F;log&#x2F;gitblit.log 启动1.jar包启动java -jar gitblit.jar 即可手动启动gitblit当按ctrl+c或者退出终端时则该进程会关闭，服务也会关闭，因此这里必须要将该jar程序放到后台运行，这里需要对gitblit.sh文件进行修改，vi gitblit.sh修改成如下 12#!&#x2F;bin&#x2F;bashjava -jar gitblit.jar --baseFolder data &gt;&#x2F;dev&#x2F;null &amp; 2.服务启动将gitblit添加为服务 12install-service-centos.shservice gitblit start 访问用户名：admin密码：admin 额外依赖库如果需要 123yum install -y gcc-c++ curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum install lsofyum install net-tools lsof -i:8888 - 查看端口kill -9 pid - 杀死服务 设置防火墙如果需要 1234firewall-cmd --zone&#x3D;public --add-port&#x3D;7070&#x2F;tcp --permanent 开启端口firewall-cmd --zone&#x3D;public --add-port&#x3D;7071&#x2F;tcp --permanent 开启端口firewall-cmd --zone&#x3D;public --add-port&#x3D;8443&#x2F;tcp --permanent 开启端口firewall-cmd --reload 重启防火墙后生效 也可以全部开启http和https端口 1234sudo firewall-cmd --permanent --zone&#x3D;public --add-service&#x3D;httpsudo firewall-cmd --permanent --zone&#x3D;public --add-service&#x3D;httpssudo firewall-cmd --reloadsudo systemctl restart firewalld.service","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Tools","slug":"Dev/Tools","permalink":"http://www.lida1024.top/categories/Dev/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.lida1024.top/tags/Git/"}]},{"title":"快速搭建 Git 服务器[Windows版]","slug":"快速搭建-Git-服务器-Windows版","date":"2020-03-25T05:57:00.000Z","updated":"2020-04-11T08:02:30.321Z","comments":true,"path":"2020/03/25/快速搭建-Git-服务器-Windows版/","link":"","permalink":"http://www.lida1024.top/2020/03/25/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA-Git-%E6%9C%8D%E5%8A%A1%E5%99%A8-Windows%E7%89%88/","excerpt":"","text":"服务器搭建下载 下载 JDK：https://www.oracle.com/technetwork/java/javase/downloads/ 下载 Gitblit：http://gitblit.com/ 解压解压缩下载的压缩包即可，无需安装。 创建本地存储文件夹 配置打开data文件夹下的gitblit.properties在第17行可以看到 1include &#x3D; defaults.properties 同文件夹下找到defaults.properties将上边配置的本地存储文件夹的路径复制过来 12#git.repositoriesFolder &#x3D; $&#123;baseFolder&#125;&#x2F;gitgit.repositoriesFolder &#x3D; E:\\GitBlit\\Repository 找到server.httpPort，设定http协议的端口号 1234567# Standard http port to serve. &lt;&#x3D; 0 disables this connector.# On Unix&#x2F;Linux systems, ports &lt; 1024 require root permissions.# Recommended value: 80 or 8080## SINCE 0.5.0# RESTART REQUIREDserver.httpPort &#x3D; 1024 找到server.httpBindInterface，设定服务器的IP地址。这里就设定你的服务器IP。 12345678# Specify the interface for Jetty to bind the standard connector.# You may specify an ip or an empty value to bind to all interfaces.# Specifying localhost will result in Gitblit ONLY listening to requests to# localhost.## SINCE 0.5.0# RESTART REQUIREDserver.httpBindInterface &#x3D; localhost 找到server.httpsBindInterface，设定为localhost 12345678# Specify the interface for Jetty to bind the secure connector.# You may specify an ip or an empty value to bind to all interfaces.# Specifying localhost will result in Gitblit ONLY listening to requests to# localhost.## SINCE 0.5.0# RESTART REQUIREDserver.httpsBindInterface &#x3D; localhost 运行运行gitblit.cmd如上图则运行成功在浏览器中打开,现在就可以使用GitBlit了。默认用户名密码都是 admin","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Tools","slug":"Dev/Tools","permalink":"http://www.lida1024.top/categories/Dev/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.lida1024.top/tags/Git/"}]},{"title":"MD5 到底是不是加密算法？","slug":"MD5-到底是不是加密算法？","date":"2020-03-21T06:01:00.000Z","updated":"2020-04-10T06:34:38.457Z","comments":true,"path":"2020/03/21/MD5-到底是不是加密算法？/","link":"","permalink":"http://www.lida1024.top/2020/03/21/MD5-%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F/","excerpt":"","text":"在回答这个问题之前，我们先分别来了解一下两个知识点： 什么是 MD5 算法？ 什么是加密算法？ 一、MD5算法MD5 即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一，主流编程语言普遍已有 MD5 实现。 将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5 的前身有 MD2 、MD3 和 MD4 。 MD5 是输入不定长度信息，输出固定长度 128-bits 的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个 128-bits 散列。 基本方式为，求余、取余、调整长度、与链接变量进行循环运算，得出结果。 MD5 计算广泛应用于错误检查。在一些 BitTorrent 下载中，软件通过计算 MD5 来检验下载到的碎片的完整性。 二、加密算法百度百科加密，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。 维基百科在密码学中，加密（英语：Encryption）是将明文信息改变为难以读取的密文内容，使之不可读的过程。只有拥有解密方法的对象，经由解密过程，才能将密文还原为正常可读的内容。 三、对比也就是说，MD5 算法和加密算法都可以将信息转换为另外一种内容。 但是，MD5 算法对比 加密算法 缺少了解密过程。 事实上，使用 加密算法 加密后的消息是完整的，并且基于解密算法后，可以恢复原始数据。 而 MD5 算法 得到的消息是不完整的，并且通过摘要的数据也无法得到原始数据。 所以，MD5 算法不是加密算法！","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"加密解密","slug":"加密解密","permalink":"http://www.lida1024.top/tags/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"}]},{"title":"几个Git仓库开源软件的比较","slug":"几个Git仓库开源软件的比较","date":"2020-03-20T06:59:00.000Z","updated":"2020-04-11T08:04:20.289Z","comments":true,"path":"2020/03/20/几个Git仓库开源软件的比较/","link":"","permalink":"http://www.lida1024.top/2020/03/20/%E5%87%A0%E4%B8%AAGit%E4%BB%93%E5%BA%93%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/","excerpt":"","text":"特性 gitlab gitblit gitbucket gogs gitolite 公开库 √ √ √ √ √ 私有库 √ √ √ √ √ 在线编辑 √ × √ × × wiki √ √ √ √ × issue √ √ √ √ × fork √ √ √ √ × pull request √ × √ √ × 支持ssh √ √ × √ ？ 邮件通知 √ ？ √ √ ？ 项目统计 √ × √ √ × 组织管理 √ √ √ √ × 中文支持 × √ × √ × 权限控制 √ √ × × √ 插件机制 √ √ √ √ × 系统资源要求 高 高 高 很低 低 方便安装 巨大不方便 单文件部署 单文件部署 单文件部署 未知 开发语言 ruby java scala go perl 项目历史（年） ？ 5 3 2 ？ 开发者数量 ？ 97 80 196 ？","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Tools","slug":"Dev/Tools","permalink":"http://www.lida1024.top/categories/Dev/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.lida1024.top/tags/Git/"}]},{"title":"什么是 开发环境、测试环境、生产环境、UAT环境、仿真环境","slug":"什么是-开发环境、测试环境、生产环境、UAT环境、仿真环境","date":"2020-03-19T07:00:00.000Z","updated":"2020-04-10T02:47:12.407Z","comments":true,"path":"2020/03/19/什么是-开发环境、测试环境、生产环境、UAT环境、仿真环境/","link":"","permalink":"http://www.lida1024.top/2020/03/19/%E4%BB%80%E4%B9%88%E6%98%AF-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%81%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E3%80%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E3%80%81UAT%E7%8E%AF%E5%A2%83%E3%80%81%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/","excerpt":"","text":"开发环境：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意， 为了开发调试方便，一般打开全部错误报告。 测试环境：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。 生产环境：是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。可以理解为包含所有的功能的环境，任何项目所使用的环境都以这个为基础，然后根据客户的个性化需求来做调整或者修改。 三个环境也可以说是系统开发的三个阶段：开发-&gt;测试-&gt;上线，其中生产环境也就是通常说的真实环境。 UAT环境：UAT，(User Acceptance Test),用户接受度测试 即验收测试，所以UAT环境主要是用来作为客户体验的环境。 仿真环境：顾名思义是和真正使用的环境一样的环境（即已经出售给客户的系统所在环境，也成为商用环境），所有的配置，页面展示等都应该和商家正在使用的一样，差别只在环境的性能方面。 系统内部集成测试(System Integration Testing) SIT用户验收测试(User Acceptance Testing) UATSIT在前，UAT在后，UAT测完才可以上线。 SIT是集成测试UAT是验收测试从时间上看，UAT要在SIT后面，UAT测试要在系统测试完成后才开始。从测试人员看，SIT由公司的测试员来测试，而UAT一般是由用户来测试。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://www.lida1024.top/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"Mybatis if标签判断数字大小","slug":"Mybatis if标签判断数字大小","date":"2020-03-18T06:01:00.000Z","updated":"2020-04-10T03:35:22.782Z","comments":true,"path":"2020/03/18/Mybatis if标签判断数字大小/","link":"","permalink":"http://www.lida1024.top/2020/03/18/Mybatis%20if%E6%A0%87%E7%AD%BE%E5%88%A4%E6%96%AD%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/","excerpt":"","text":"if标签语法123456&lt;select...&gt; SQL语句1 &lt;if test&#x3D;&quot;条件表达式&quot;&gt; SQL语句2 &lt;&#x2F;if&gt;&lt;&#x2F;select&gt; 条件表达式中大于号小于号用 gt,lt123&lt;if test&#x3D;&quot;num gt 0&quot;&gt;...&lt;&#x2F;if&gt;&lt;if test&#x3D;&quot;num lt 0&quot;&gt;...&lt;&#x2F;if&gt; mapper123List&lt;ZftjHalf&gt; selectByAreaIdAndYear(@Param(&quot;areaId&quot;) String areaId, @Param(&quot;year&quot;) String year, @Param(&quot;level&quot;) int level); ##xml 12345678910111213&lt;select id&#x3D;&quot;selectByAreaIdAndYear&quot; resultType&#x3D;&quot;com.zftdata.nyzft.entity.ZftjHalf&quot;&gt; select * from ZFTJ_HALF where FILLING_TIME LIKE CONCAT(#&#123;year&#125;,&#39;%&#39;) &lt;if test&#x3D;&quot;level lt 3&quot;&gt; and AREA_ID_PID &#x3D;#&#123;areaId&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;level gt 2&quot;&gt; and AREA_ID &#x3D;#&#123;areaId&#125; &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;level &#x3D;&#x3D; 4&quot;&gt; and AREA_ID &#x3D;#&#123;areaId&#125; &lt;&#x2F;if&gt;&lt;&#x2F;select&gt;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.lida1024.top/tags/MyBatis/"}]},{"title":"Java14新特性：Switch表达式","slug":"Java14新特性：Switch表达式","date":"2020-03-16T06:36:00.000Z","updated":"2020-04-11T00:51:41.132Z","comments":true,"path":"2020/03/16/Java14新特性：Switch表达式/","link":"","permalink":"http://www.lida1024.top/2020/03/16/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ASwitch%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"Java 14正式发布switch表达式特性。在之前的两个 Java 版本Java12，Java13，switch特性只是预览版。新的switch表达式有助于避免一些bug，因为它的表达和组合方式更容易编写。 switch新的表达式有两个特点： 支持箭头表达式返回。 支持yied和return返回值。Java 14之前switch语法123456789101112switch (season) &#123; case SPRING: case AUTUMN: System.out.println(&quot;温暖&quot;); break; case SUMMER: System.out.println(&quot;炎热&quot;); break; case WINTER: System.out.println(&quot;寒冷&quot;); break;&#125; Java 14 switch表达式12345switch (season) &#123; case SPRING, AUTUMN -&gt; System.out.println(&quot;温暖&quot;); case SUMMER -&gt; System.out.println(&quot;炎热&quot;); case WINTER -&gt; System.out.println(&quot;寒冷&quot;);&#125; Java 14的switch表达式使用箭头表达时，不需要我们在每一个case后都加上break，减少我们出错的机会。 Java14之前switch语法返回值123456789101112131415String temperature &#x3D;&quot;&quot;;switch (season) &#123; case SPRING: case AUTUMN: temperature &#x3D; &quot;温暖&quot;; break; case SUMMER: temperature &#x3D; &quot;炎热&quot;; break; case WINTER: temperature &#x3D; &quot;寒冷&quot;; break; default: temperature &#x3D; &quot;忽冷忽热&quot;;&#125; 它不支持返回值，需要通过一个中间变量来返回。 Java14 switch表达式返回值12345String temperature &#x3D; switch (season) &#123; case SPRING, AUTUMN -&gt; &quot;温暖&quot;; case SUMMER -&gt; &quot;炎热&quot;; case WINTER -&gt; &quot;寒冷&quot;;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"java14","slug":"java14","permalink":"http://www.lida1024.top/tags/java14/"}]},{"title":"Java14新特性：字符串块","slug":"Java14新特性：字符串块","date":"2020-03-15T06:04:00.000Z","updated":"2020-04-11T00:51:34.083Z","comments":true,"path":"2020/03/15/Java14新特性：字符串块/","link":"","permalink":"http://www.lida1024.top/2020/03/15/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9D%97/","excerpt":"","text":"java1之前写字符串拼接 1234567String str &#x3D; &quot;&lt;html&gt;&quot; + &quot;&lt;header&gt;&quot; + &quot;&lt;&#x2F;header&gt;&quot; + &quot;&lt;body&gt;&quot; + &quot;&lt;div&gt;body&lt;&#x2F;div&gt;&quot; + &quot;&lt;&#x2F;body&gt;&quot; + &quot;&lt;&#x2F;html&gt;&quot;; 内容短的时候还算可以，当需要拼接的内容很多的时候就会显得很乱 java14后，引进了三个引号作为字符串块，类似python中的字符串块 12345678910&#x2F;&#x2F; 注意 &quot;&quot;&quot; 之后必须换行String str &#x3D; &quot;&quot;&quot; &lt;html&gt; &lt;header&gt; &lt;&#x2F;header&gt; &lt;body&gt; &lt;div&gt;&quot;body&quot;&lt;&#x2F;div&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; &quot;&quot;&quot;;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"java14","slug":"java14","permalink":"http://www.lida1024.top/tags/java14/"}]},{"title":"Java14新特性：增强 instanceOf 类型推断","slug":"Java14新特性：增强-instanceOf-类型推断","date":"2020-03-14T00:17:00.000Z","updated":"2020-04-11T00:51:26.510Z","comments":true,"path":"2020/03/14/Java14新特性：增强-instanceOf-类型推断/","link":"","permalink":"http://www.lida1024.top/2020/03/14/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%A2%9E%E5%BC%BA-instanceOf-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/","excerpt":"","text":"Java中instanceof是用来判断对象的类型是否是目标类型。如果是返回true，不是返回false。 在Java 14之前，示例如下： 123456if (obj instanceof String) &#123; String str &#x3D; (String) obj; str.contains(&quot;A&quot;) ;&#125;else&#123; str &#x3D; &quot;&quot;;&#125; obj instanceof String已经为true，在后面的代码里，我们还是要清晰的定义一个新变量，并且要做类型强转换。 Java 14对instanceof引入了模式匹配，修改后的代码如下： 12345if (!(obj instanceof String str)) &#123; str.contains(&quot;A&quot;) ;&#125; else &#123; str &#x3D; &quot;&quot;;&#125; 定义了str，就可以在后续代码使用，不在需要显式做类型转换了。 还能继续加入判断条件 1234567if (obj instanceof String str &amp;&amp; str.contains(&quot;A&quot;)) &#123; System.out.println(str); &#125;if (obj instanceof String str || str.contains(&quot;A&quot;)) &#123; System.out.println(str); &#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"java14","slug":"java14","permalink":"http://www.lida1024.top/tags/java14/"}]},{"title":"Java14新特性：增强NPE NullPointerException 错误推断","slug":"Java14新特性：增强NPE-NullPointerException-错误推断","date":"2020-03-13T00:41:00.000Z","updated":"2020-04-11T00:51:17.418Z","comments":true,"path":"2020/03/13/Java14新特性：增强NPE-NullPointerException-错误推断/","link":"","permalink":"http://www.lida1024.top/2020/03/13/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%A2%9E%E5%BC%BANPE-NullPointerException-%E9%94%99%E8%AF%AF%E6%8E%A8%E6%96%AD/","excerpt":"","text":"改进 NullPointerExceptions，通过准确描述哪些变量为 null 来提高 JVM 生成的异常的可用性。该提案的作者希望为开发人员和支持人员提供有关程序为何异常终止的有用信息，并通过更清楚地将动态异常与静态程序代码相关联来提高对程序的理解。 1String name &#x3D; user.getLocation().getCity().getName(); 在Java 14之前，你可能会得到如下的错误： 1Exception in thread &quot;main&quot; java.lang.NullPointerExceptionat NullPointerExample.main(NullPointerExample.java:2) 不幸的是，如果在第2行是一个包含了多个方法调用的赋值语句（如getLocation()和getCity()），那么任何一个都可能会返回null。实际上，变量user也可能是null。因此，无法判断是谁导致了NullPointerException。 在Java 14中，新的JVM特性可以显示更详细的诊断信息： 12Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;Location.getCity()&quot; because the return value of &quot;User.getLocation()&quot; is null at NullPointerExample.main(NullPointerExample.java:2) 该消息包含两个明确的组成部分： 后果：Location.getCity()无法被调用 原因：User.getLocation()的返回值为null","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"java14","slug":"java14","permalink":"http://www.lida1024.top/tags/java14/"}]},{"title":"Java 中 IO 流","slug":"Java-中-IO-流","date":"2020-03-12T00:52:00.000Z","updated":"2020-04-11T00:50:34.436Z","comments":true,"path":"2020/03/12/Java-中-IO-流/","link":"","permalink":"http://www.lida1024.top/2020/03/12/Java-%E4%B8%AD-IO-%E6%B5%81/","excerpt":"","text":"Java 中 IO 流分为几种? 按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 按操作方式分类结构图： 按操作对象分类结构图： 既然有了字节流,为什么还要有字符流?字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。 BIO,NIO,AIO 有什么区别? BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。 NIO (New I/O): NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发 AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://www.lida1024.top/tags/IO/"}]},{"title":"java基础知识汇总(三)","slug":"java基础知识汇总-三","date":"2020-03-11T04:12:00.000Z","updated":"2020-04-11T00:50:51.900Z","comments":true,"path":"2020/03/11/java基础知识汇总-三/","link":"","permalink":"http://www.lida1024.top/2020/03/11/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-%E4%B8%89/","excerpt":"","text":"21.静态方法和实例方法有何不同 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。 22.对象的相等与指向他们的引用相等,两者有什么不同?对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。 23.在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?帮助子类做初始化工作。 24.== 与 equals(重要)== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。 equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 举个例子： 1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; a 为一个引用 String b &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; b为另一个引用,对象的内容一样 String aa &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 放在常量池中 String bb &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 从常量池中查找 if (aa &#x3D;&#x3D; bb) &#x2F;&#x2F; true System.out.println(&quot;aa&#x3D;&#x3D;bb&quot;); if (a &#x3D;&#x3D; b) &#x2F;&#x2F; false，非同一对象 System.out.println(&quot;a&#x3D;&#x3D;b&quot;); if (a.equals(b)) &#x2F;&#x2F; true System.out.println(&quot;aEQb&quot;); if (42 &#x3D;&#x3D; 42.0) &#123; &#x2F;&#x2F; true System.out.println(&quot;true&quot;); &#125; &#125;&#125; 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 25.hashCode 与 equals (重要)面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？” hashCode（）介绍hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其它情况下没用。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 hashCode（）与 equals（）的相关规定 如果两个对象相等，则 hashcode 一定也是相同的 两个对象相等,对两个对象分别调用 equals 方法都返回 true 两个对象有相同的 hashcode 值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 26.简述线程、程序、进程的基本概念。以及他们之间关系是什么?线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。 27.线程有哪些基本状态?Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）： 由上图可以看出： 线程创建之后它将处于 NEW（新建） 状态，调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 RUNNING（运行） 状态。 操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：HowToDoInJava：Java Thread Life Cycle and Thread States），所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。 当线程执行 wait()方法之后，线程进入 WAITING（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。 28.关于 final 关键字的一些总结final 关键字主要用在三个地方：变量、方法、类。 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。 使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。 29.Java 中的异常处理Java 异常类层次结构图在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。 Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由 Java 虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。 注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。 Throwable 类常用方法 public string getMessage():返回异常发生时的简要描述 public string toString():返回异常发生时的详细信息 public string getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同 public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息 异常处理总结 try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 catch 块： 用于处理 try 捕获到的异常。 finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。 在以下 4 种特殊情况下，finally 块不会被执行： 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行 程序所在的线程死亡。 关闭 CPU。 下面这部分内容来自 issue:https://github.com/Snailclimb/JavaGuide/issues/190。 注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下： 123456789public static int f(int value) &#123; try &#123; return value * value; &#125; finally &#123; if (value &#x3D;&#x3D; 2) &#123; return 0; &#125; &#125;&#125; 如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。 30.java 序列化中如果有些字段不想进行序列化，怎么办？对于不想进行序列化的变量，使用 transient 关键字修饰。 transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.lida1024.top/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"java基础知识汇总(二)","slug":"java基础知识汇总-二","date":"2020-03-10T03:44:00.000Z","updated":"2020-04-11T00:51:09.764Z","comments":true,"path":"2020/03/10/java基础知识汇总-二/","link":"","permalink":"http://www.lida1024.top/2020/03/10/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-%E4%BA%8C/","excerpt":"","text":"11.自动装箱与拆箱 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； 12.在一个静态方法内调用一个非静态成员为什么是非法的?由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。 13.在 Java 中定义一个不做事且没有参数的构造方法的作用Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 14.import java 和 javax 有什么区别？刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。 所以，实际上 java 和 javax 没有区别。这都是一个名字。 15.接口和抽象类的区别是什么？ 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 备注： 在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:https://github.com/Snailclimb/JavaGuide/issues/146。 jdk9 的接口被允许定义私有方法 。 总结一下 jdk7~jdk9 Java 中接口概念的变化（相关阅读）： 在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。 jdk8 的时候接口可以有默认方法和静态方法功能。 Jdk 9 在接口中引入了私有方法和私有静态方法。 16.成员变量与局部变量的区别有哪些？ 从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。 从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。 17.创建一个对象用什么运算符?对象实体与对象引用有何不同?new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。 18.什么是方法的返回值?返回值在类的方法里的作用是什么?方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！ 19.一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。 20.构造方法有哪些特性？ 名字与类名相同。 没有返回值，但不能用 void 声明构造函数。 生成类的对象时自动执行，无需调用。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.lida1024.top/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"java基础知识汇总(一)","slug":"java基础知识汇总-一","date":"2020-03-09T03:43:00.000Z","updated":"2020-04-11T00:51:00.668Z","comments":true,"path":"2020/03/09/java基础知识汇总-一/","link":"","permalink":"http://www.lida1024.top/2020/03/09/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-%E4%B8%80/","excerpt":"","text":"1. 面向对象和面向过程的区别 面向过程 ：面向过程性能比面向对象高。 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，面向过程没有面向对象易维护、易复用、易扩展。 面向对象 ：面向对象易维护、易复用、易扩展。 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，面向对象性能比面向过程低。 2. 关于 JVM JDK 和 JRE 最详细通俗的解答JVMJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。 什么是字节码?采用字节码的好处是什么?在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。 Java 程序从源代码到运行一般有下面 3 步：我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 总结：Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。 JDK 和 JREJDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。 JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。 如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。 3.Oracle JDK 和 OpenJDK 的对比对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案： 问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。 总结： Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence。 OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题； 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能； Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。 4.什么是 Java 程序的主类 应用程序和小程序的主类有何不同?一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。 5.Java 应用程序与小程序之间有哪些差别?简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有 main() 方法，主要是嵌在浏览器页面上运行(调用init()或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。 6.字符型常量和字符串常量的区别? 形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符 含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节)7.构造器 Constructor 是否可被 override?Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。 8.重载和重写的区别重载发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。 下面是《Java 核心技术》对重载这个概念的介绍： 重写重写是子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。另外，如果父类方法访问修饰符为 private 则子类就不能重写该方法。也就是说方法提供的行为改变，而方法的外貌并没有改变。 9.Java 面向对象编程三大特性: 封装 继承 多态封装封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。 关于继承如下 3 点请记住： 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。 多态所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。 10.String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?可变性简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。 补充（来自issue 675）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte[] value; 而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。 AbstractStringBuilder.java 1234567891011121314abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; &#x2F;** * The value is used for character storage. *&#x2F; char[] value; &#x2F;** * The count is the number of characters used. *&#x2F; int count; AbstractStringBuilder(int capacity) &#123; value &#x3D; new char[capacity]; &#125; 线程安全性 String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结： 操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.lida1024.top/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Mysql之ONLY_FULL_GROUP_BY默认配置问题","slug":"Mysql之ONLY-FULL-GROUP-BY默认配置问题","date":"2020-03-08T02:58:00.000Z","updated":"2020-04-11T09:10:39.962Z","comments":true,"path":"2020/03/08/Mysql之ONLY-FULL-GROUP-BY默认配置问题/","link":"","permalink":"http://www.lida1024.top/2020/03/08/Mysql%E4%B9%8BONLY-FULL-GROUP-BY%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"错误12345### Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Expression #3 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;fhshgl.ii.COMMODITYDETAILPRICE_ID&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by 原因在把MySQL升级到5.7或者更高的版本，一些以前看上去不会出错的group by 操作在这个版本以后就会出现语法报错的情况： 在这个模式下，我们使用分组查询时，出现在select字段后面的只能是group by后面的分组字段，或使用聚合函数包裹着的字段。 Oracled等数据库都不支持select target list中出现语义不明确的列，这样的语句在这些数据库中是会被报错的，所以从MySQL 5.7版本开始修正了这个语义，就是所说的ONLY_FULL_GROUP_BY语义。 因为有only_full_group_by，所以我们要在MySQL中正确的使用group by语句的话，只能是select column1 from tb1 group by column1(即只能展示group by的字段，其他均都要报1055的错) 解决暂时性关闭可以通过select @@sql_mode查出sql_mode以后去掉ONLY_FULL_GROUP_BY 查看当前连接会话的sql模式：select @@session.sql_mode;查看全局sql_mode设置：select @@global.sql_mode; 设置全局sql_mode可以在不重启MySQL的情况下生效 123set @@global.sql_mode&#x3D;&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;set @@SESSION.sql_mode&#x3D;&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;; 更改配置文件 linux系统更改/etc/my.cnf文件，使用vi命令打开，如果有sql_mode=…的注释就把注释打开，如果没有就加上sql_mode=…（可以通过select @@sql_mode查出sql_mode以后去掉ONLY_FULL_GROUP_BY后复制过来） windows下配置文件是安装目录下的my.ini文件，其余同上 相关参数说明 参数 说明 ONLY_FULL_GROUP_BY 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中 NO_AUTO_VALUE_ON_ZERO 该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。 STRICT_TRANS_TABLES 在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制。 NO_ZERO_IN_DATE 在严格模式下，不允许日期和月份为零 NO_ZERO_DATE 设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。 ERROR_FOR_DIVISION_BY_ZERO 在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL NO_AUTO_CREATE_USER 禁止GRANT创建密码为空的用户 NO_ENGINE_SUBSTITUTION 如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 PIPES_AS_CONCAT 将||视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似 ANSI_QUOTES 启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"DataBase","slug":"Dev/DataBase","permalink":"http://www.lida1024.top/categories/Dev/DataBase/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.lida1024.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Java虚拟机是如何加载Java类的？","slug":"Java虚拟机是如何加载Java类的？","date":"2020-03-07T01:08:00.000Z","updated":"2020-04-11T00:30:01.320Z","comments":true,"path":"2020/03/07/Java虚拟机是如何加载Java类的？/","link":"","permalink":"http://www.lida1024.top/2020/03/07/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDJava%E7%B1%BB%E7%9A%84%EF%BC%9F/","excerpt":"","text":"Java 虚拟机中的类加载即从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。 虚拟机的加载对象是什么？上文中说过Java中有两种类型：基本类型和引用类型，而基本类型是由虚拟机预先定义好的，引用类型中的泛型参数又会在编译过程中被擦除，所以加载的对象就剩下类、接口和数组类。 在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。无论是直接生成的数组类，还是加载的类，Java 虚拟机都需要对其进行链接和初始化。接下来，就详细介绍一下每个步骤具体都在干些什么。 虚拟机的加载流程是什么？1.加载是指查找字节流，并且据此创建类的过程。上面提过数组类是由Java虚拟机直接生成的，所以加载过程针对的是生成字节流的类与接口。如何找到这些字节流，则需要虚拟机借助类加载器。 启动类加载器是由 C++ 实现的，没有对应的 Java 对象，因此在 Java 中只能用 null 来指代。在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载器之外，另外两个重要的类加载器是扩展类加载器（extension class loader）和应用类加载器（application class loader），均由 Java 核心类库提供。故除了启动类加载器之外，其他的类加载器都是java.lang.ClassLoader 的子类，因此有对应的 Java 对象。 扩展类加载器的父类加载器是启动类加载器。它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。 应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。 Java 9 引入了模块系统，并且略微更改了上述的类加载器1。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。当然还可以自定义类加载器哦。 除了加载功能之外，类加载器还提供了命名空间的作用，在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。 2.链接是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。 验证阶段：确保被加载类能够满足 Java 虚拟机的约束条件。 准备阶段：为被加载类的静态字段分配内存，构造其他跟类层次相关的数据结构。 解析阶段：将符号引用解析成为实际引用（Java 虚拟机规范并没有要求在链接过程中完成解析。它仅规定了：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析）。 符号引用则是在 class 文件被加载至 Java 虚拟机之前，类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。 3.初始化初始化即给常量赋值以及执行 &lt; clinit &gt; 方法的过程，完成之后，类才正式成为可执行的状态。 类初始化触发条件 当虚拟机启动时，初始化用户指定的主类； 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类； 当遇到调用静态方法的指令时，初始化该静态方法所在的类； 当遇到访问静态字段的指令时，初始化该静态字段所在的类； 子类的初始化会触发父类的初始化； 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化； 使用反射 API 对某个类进行反射调用时，初始化这个类； 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。 总结虚拟机加载Java类是Java 虚拟机将字节流转化为 Java 类的过程。这个过程可分为加载、链接以及初始化三大步骤。 加载：是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。 链接：是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。 初始化：是为标记为常量值的字段赋值，以及执行 &lt; clinit &gt; 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.lida1024.top/tags/JVM/"}]},{"title":"将SpringBoot项目发布到Docker","slug":"将SpringBoot项目发布到Docker","date":"2020-03-06T11:33:00.000Z","updated":"2020-04-10T03:40:29.297Z","comments":true,"path":"2020/03/06/将SpringBoot项目发布到Docker/","link":"","permalink":"http://www.lida1024.top/2020/03/06/%E5%B0%86SpringBoot%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83%E5%88%B0Docker/","excerpt":"","text":"1.创建springboot项目123456789101112131415package com.test.demo.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloController &#123; @RequestMapping(&quot;&#x2F;&quot;) @ResponseBody public String hello() &#123; return &quot;Hello, SpringBoot With Docker&quot;; &#125;&#125; 2.将SpringBoot项目打jar包pom.xml增加spring-boot-maven-plugin插件 使用右侧maven-Lifecycle-package打jar包 使用java -jar *-1.0.0.jar测试可用 3.编写Dockerfile文件12345678910# 基础镜像使用javaFROM java:8# VOLUME 指定了临时文件目录为&#x2F;tmp。# 其效果是在主机 &#x2F;var&#x2F;lib&#x2F;docker 目录下创建了一个临时文件，并链接到容器的&#x2F;tmpVOLUME &#x2F;tmp # 将jar包添加到容器中并更名为app.jarADD demo-0.0.1-SNAPSHOT.jar app.jar # 运行jar包RUN bash -c &#39;touch &#x2F;app.jar&#39;ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;] 解释下这个配置文件： VOLUME 指定了临时文件目录为/tmp。其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录项目的 jar 文件作为 “app.jar” 添加到容器的ENTRYPOINT 执行项目 app.jar。为了缩短 Tomcat 启动时间，添加一个系统属性指向 “/dev/./urandom” 作为 Entropy Source 如果是第一次打包，它会自动下载java 8的镜像作为基础镜像，以后再制作镜像的时候就不会再下载了。 4.将jar包拷贝到和Dockerfile同文件夹在服务器新建一个docker文件夹，将maven打包好的jar包和Dockerfile文件复制到服务器的docker文件夹下 5.制作镜像1docker build -t springbootdemo4docker . 6.运行镜像1docker run -d -p 8088:8088 --name springbootdemo4docker","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Container","slug":"Dev/Container","permalink":"http://www.lida1024.top/categories/Dev/Container/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://www.lida1024.top/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"ECharts地图省市联动","slug":"ECharts地图省市联动","date":"2020-03-05T12:22:00.000Z","updated":"2020-04-11T00:54:01.140Z","comments":true,"path":"2020/03/05/ECharts地图省市联动/","link":"","permalink":"http://www.lida1024.top/2020/03/05/ECharts%E5%9C%B0%E5%9B%BE%E7%9C%81%E5%B8%82%E8%81%94%E5%8A%A8/","excerpt":"","text":"最近需要做一个省市联动的地图，来随时观看各地区的用户数量。 记录实现代码。 主页面china.html： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;EDGE&quot;&gt; &lt;style&gt; #china-map &#123; width: 1000px; height: 1000px; margin: auto; &#125; #box &#123; display: none; background-color: goldenrod; width: 180px; height: 30px; &#125; #box-title &#123; display: block; &#125; &lt;&#x2F;style&gt; &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;www.jq22.com&#x2F;jquery&#x2F;jquery-1.10.2.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;echarts&#x2F;4.2.0-rc.2&#x2F;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;js&#x2F;map&#x2F;china.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;wrapper wrapper-content&quot;&gt; &lt;div class&#x3D;&quot;row&quot;&gt; &lt;button id&#x3D;&quot;back&quot;&gt;返回全国&lt;&#x2F;button&gt; &lt;div id&#x3D;&quot;china-map&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script&gt; var myChart &#x3D; echarts.init(document.getElementById(&#39;china-map&#39;)); var oBack &#x3D; document.getElementById(&quot;back&quot;); var provinces &#x3D; [&#39;shanghai&#39;, &#39;hebei&#39;, &#39;shanxi&#39;, &#39;neimenggu&#39;, &#39;liaoning&#39;, &#39;jilin&#39;, &#39;heilongjiang&#39;, &#39;jiangsu&#39;, &#39;zhejiang&#39;, &#39;anhui&#39;, &#39;fujian&#39;, &#39;jiangxi&#39;, &#39;shandong&#39;, &#39;henan&#39;, &#39;hubei&#39;, &#39;hunan&#39;, &#39;guangdong&#39;, &#39;guangxi&#39;, &#39;hainan&#39;, &#39;sichuan&#39;, &#39;guizhou&#39;, &#39;yunnan&#39;, &#39;xizang&#39;, &#39;shanxi1&#39;, &#39;gansu&#39;, &#39;qinghai&#39;, &#39;ningxia&#39;, &#39;xinjiang&#39;, &#39;beijing&#39;, &#39;tianjin&#39;, &#39;chongqing&#39;, &#39;xianggang&#39;, &#39;aomen&#39;]; var provincesText &#x3D; [&#39;上海&#39;, &#39;河北&#39;, &#39;山西&#39;, &#39;内蒙古&#39;, &#39;辽宁&#39;, &#39;吉林&#39;, &#39;黑龙江&#39;, &#39;江苏&#39;, &#39;浙江&#39;, &#39;安徽&#39;, &#39;福建&#39;, &#39;江西&#39;, &#39;山东&#39;, &#39;河南&#39;, &#39;湖北&#39;, &#39;湖南&#39;, &#39;广东&#39;, &#39;广西&#39;, &#39;海南&#39;, &#39;四川&#39;, &#39;贵州&#39;, &#39;云南&#39;, &#39;西藏&#39;, &#39;陕西&#39;, &#39;甘肃&#39;, &#39;青海&#39;, &#39;宁夏&#39;, &#39;新疆&#39;, &#39;北京&#39;, &#39;天津&#39;, &#39;重庆&#39;, &#39;香港&#39;, &#39;澳门&#39;]; oBack.onclick &#x3D; function () &#123; initEcharts(&quot;china&quot;, &quot;点亮中国&quot;); &#125;; initEcharts(&quot;china&quot;, &quot;点亮中国&quot;); &#x2F;&#x2F; 初始化echarts function initEcharts(pName, Chinese_) &#123; $.ajax(&#123; type: &quot;GET&quot;, url: &quot;http:&#x2F;&#x2F;localhost:4000&#x2F;user&#x2F;userCount?searchName&#x3D;&quot;+pName, success: function (res) &#123; &#x2F;&#x2F; var seriesData &#x3D; res.data; &#x2F;&#x2F; var tmpSeriesData &#x3D; pName &#x3D;&#x3D;&#x3D; &quot;china&quot; ? seriesData : []; var tmpSeriesData &#x3D; res.data; var option &#x3D; &#123; title: &#123; text: Chinese_ || pName, left: &#39;center&#39; &#125;, toolbox: &#123; show: !0, orient: &quot;vertical&quot;, x: &quot;right&quot;, y: &quot;center&quot;, feature: &#123; mark: &#123; show: !0 &#125;, dataView: &#123; show: !0, readOnly: !1 &#125;, restore: &#123; show: !0 &#125;, saveAsImage: &#123; show: !0 &#125; &#125; &#125;, tooltip: &#123; trigger: &#39;item&#39;, formatter: &#39;&#123;b&#125;&lt;br&#x2F;&gt;&#123;c&#125; (人)&#39;, backgroundColor: &quot;#ff7f50&quot;,&#x2F;&#x2F;提示标签背景颜色 textStyle: &#123;color: &quot;#fff&quot;&#125; &#x2F;&#x2F;提示标签字体颜色 &#125;, series: [ &#123; name: Chinese_ || pName, type: &#39;map&#39;, mapType: pName, roam: false,&#x2F;&#x2F;是否开启鼠标缩放和平移漫游 data: tmpSeriesData, top: &quot;3%&quot;,&#x2F;&#x2F;组件距离容器的距离 zoom: 1.1, selectedMode: &#39;single&#39;, label: &#123; normal: &#123; show: true,&#x2F;&#x2F;显示省份标签 textStyle: &#123;color: &quot;#fbfdfe&quot;&#125;&#x2F;&#x2F;省份标签字体颜色 &#125;, emphasis: &#123;&#x2F;&#x2F;对应的鼠标悬浮效果 show: true, textStyle: &#123;color: &quot;#323232&quot;&#125; &#125; &#125;, itemStyle: &#123; normal: &#123; borderWidth: .5,&#x2F;&#x2F;区域边框宽度 borderColor: &#39;#0550c3&#39;,&#x2F;&#x2F;区域边框颜色 areaColor: &quot;#4ea397&quot;,&#x2F;&#x2F;区域颜色 &#125;, emphasis: &#123; borderWidth: .5, borderColor: &#39;#4b0082&#39;, areaColor: &quot;#ece39e&quot;, &#125; &#125;, &#125; ] &#125;; myChart.setOption(option); myChart.off(&quot;click&quot;); if (pName &#x3D;&#x3D;&#x3D; &quot;china&quot;) &#123; &#x2F;&#x2F; 全国时，添加click 进入省级 myChart.on(&#39;click&#39;, function (param) &#123; console.log(param.name); &#x2F;&#x2F; 遍历取到provincesText 中的下标 去拿到对应的省js for (var i &#x3D; 0; i &lt; provincesText.length; i++) &#123; if (param.name &#x3D;&#x3D;&#x3D; provincesText[i]) &#123; &#x2F;&#x2F;显示对应省份的方法 showProvince(provinces[i], provincesText[i]); break; &#125; &#125; if (param.componentType &#x3D;&#x3D;&#x3D; &#39;series&#39;) &#123; var provinceName &#x3D; param.name; $(&#39;#box&#39;).css(&#39;display&#39;, &#39;block&#39;); $(&quot;#box-title&quot;).html(provinceName); &#125; &#125;); &#125; else &#123; &#x2F;&#x2F; 省份，添加双击 回退到全国 myChart.on(&quot;dblclick&quot;, function () &#123; initEcharts(&quot;china&quot;, &quot;点亮中国&quot;); &#125;); &#125; &#125; &#125;); &#125; &#x2F;&#x2F; 展示对应的省 function showProvince(pName, Chinese_) &#123; &#x2F;&#x2F;这写省份的js都是通过在线构建工具生成的，保存在本地，需要时加载使用即可，最好不要一开始全部直接引入。 loadBdScript(&#39;$&#39; + pName + &#39;JS&#39;, &#39;.&#x2F;js&#x2F;map&#x2F;province&#x2F;&#39; + pName + &#39;.js&#39;, function () &#123; initEcharts(Chinese_); &#125;); &#125; &#x2F;&#x2F; 加载对应的JS function loadBdScript(scriptId, url, callback) &#123; var script &#x3D; document.createElement(&quot;script&quot;); script.type &#x3D; &quot;text&#x2F;javascript&quot;; if (script.readyState) &#123; &#x2F;&#x2F;IE script.onreadystatechange &#x3D; function () &#123; if (script.readyState &#x3D;&#x3D;&#x3D; &quot;loaded&quot; || script.readyState &#x3D;&#x3D;&#x3D; &quot;complete&quot;) &#123; script.onreadystatechange &#x3D; null; callback(); &#125; &#125;; &#125; else &#123; &#x2F;&#x2F; Others script.onload &#x3D; function () &#123; callback(); &#125;; &#125; script.src &#x3D; url; script.id &#x3D; scriptId; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script); &#125;;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 效果图： 源码地址：https://github.com/coder-lida/chinamap.git","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Front","slug":"Dev/Front","permalink":"http://www.lida1024.top/categories/Dev/Front/"}],"tags":[{"name":"ECharts","slug":"ECharts","permalink":"http://www.lida1024.top/tags/ECharts/"}]},{"title":"JVM运行内存分类","slug":"JVM运行内存分类","date":"2020-03-04T12:58:00.000Z","updated":"2020-04-10T06:53:58.058Z","comments":true,"path":"2020/03/04/JVM运行内存分类/","link":"","permalink":"http://www.lida1024.top/2020/03/04/JVM%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E7%B1%BB/","excerpt":"","text":"一、程序计数器 java线程私有的，类似于操作系统里的PC计数器，可以看做是当前线程所执行的字节码的行号指示器。 如果线程正在执行的是一个java方法，这个计数器记录的正在执行的虚拟机字节码指令的地址。 如果正在执行的是native方法，这个计数器值则为空。 undefined 此内存区域是唯一一个在java虚拟规范中没有规定任何OutOfMemoryError情况的区域 二、虚拟机栈（栈内存） java线程私有，虚拟机栈描述的是java方法执行的内存模型。 每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。 每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程。 三、本地方法栈 和java虚拟机栈的作用类似。区别是该区域为JVM提供使用Native方法的服务。 四、堆内存 所有线程共享的一块区域，垃圾回收器管理的主要区域。 目前主要垃圾回收算法都是分代收集算法，所以java堆中还可以细分为：新生代和老年代，再细致一点的还有eden区，from survivor、to survivor，默认情况下是8：1：1的比例。 根据java虚拟机规范的规定，java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。 五、方法区 各个线程共享的一个区域，用于存储虚拟机加载的类信息，常量、静态变量，即时编译器编译后的代码等数据。 虽然虚拟机规范中把方法区描述成堆的一个逻辑部分，但是他却有一个别名叫Non-heap 非堆，目的是为了与java堆区分开来。 运行时常量池。是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。 直接内存 direct memory，并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。在1.4中新加入的NIO类，引入了一种基于通道Channel与缓冲区Buffer的IO方式，它可以使用native函数库直接分配堆外内存， 然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在java堆和Nativa堆中来回复制数据。 本机直接内存的分配不会受到Java堆大小的限制，受到本机总内存的大小限制。配置虚拟机参数时，不要忽略直接内存，防止出现OOM异常。 比较 直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。 直接内存IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。 后续发展 JDK7： 存储在永久代的部分数据转移到了JVM heap或者是Native heap中。 JDK8： 废弃了永久代PermGen，新增Metaspace元数据区 方法区在Metaspace中了。 MetaSpace大小默认没有限制，一般根据系统内存的大小，jvm会动态改变此值。 可以通过jvm参数配置： -XX：MetaspaceSize 分配给类元数据空间(以字节计算)的初始大小。MetaspaceSize的值设置的太大会延长垃圾回收时间，垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。 -XX:MaxMteaspaceSize：分配给类元数据空间的最大值，超过此值就会触发FullGC，此值默认没有限制，但应取决于系统内存的大小，JVM会动态改变此值。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.lida1024.top/tags/JVM/"}]},{"title":"免费CDN：jsDelivr + Github","slug":"免费CDN：jsDelivr-Github","date":"2020-03-03T00:44:00.000Z","updated":"2020-04-10T03:28:34.293Z","comments":true,"path":"2020/03/03/免费CDN：jsDelivr-Github/","link":"","permalink":"http://www.lida1024.top/2020/03/03/%E5%85%8D%E8%B4%B9CDN%EF%BC%9AjsDelivr-Github/","excerpt":"","text":"CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。 1、新建Github仓库 2、克隆Github仓库到本地在本地目录右键 Git Bash Here，执行以下命令： 1git clone 一键复制的仓库地址 3、上传资源12345echo &quot;# CDN&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git push -u origin master 4、发布仓库点击release发布 自定义发布版本号 5、通过jsDelivr引用资源使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 例如：https://cdn.jsdelivr.net/gh/coder-lida/CDN/css/style.css","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://www.lida1024.top/categories/Dev/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.lida1024.top/tags/Hexo/"}]},{"title":"Tomcat 配置https证书","slug":"Tomcat-配置https证书","date":"2020-03-02T09:54:00.000Z","updated":"2020-04-11T00:53:05.238Z","comments":true,"path":"2020/03/02/Tomcat-配置https证书/","link":"","permalink":"http://www.lida1024.top/2020/03/02/Tomcat-%E9%85%8D%E7%BD%AEhttps%E8%AF%81%E4%B9%A6/","excerpt":"","text":"TTPS 是安全套接字层超文本传输协议，在http 的基础上加入了 SSL协议，需要使用证书来校验身份。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。其默认端口为：443。越来越多的网站使用了https，这里简介其相关配置。 一、使用jdk创建证书1、keytool的概念 keytool 是个密钥和证书管理工具。它使用户能够管理自己的公钥/私钥对及相关证书，用于（通过数字签名）自我认证（用户向别的用户/服务认证自己）或数据完整性以及认证服务。在JDK 1.4以后的版本中都包含了这一工具，它的位置为%JAVA_HOME%\\bin\\keytool.exe，如下图所示： 2、keytool的用法这里在安装有 JDK 环境的情况下进行，利用 keytool 工具生成 tomcat 证书，可使用 –help 命令查看相关残数据说明，具体如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Microsoft Windows [版本 6.1.7601]版权所有 (c) 2009 Microsoft Corporation。保留所有权利。C:\\Users\\Administrator&gt;keytool密钥和证书管理工具命令: -certreq 生成证书请求 -changealias 更改条目的别名 -delete 删除条目 -exportcert 导出证书 -genkeypair 生成密钥对 -genseckey 生成密钥 -gencert 根据证书请求生成证书 -importcert 导入证书或证书链 -importpass 导入口令 -importkeystore 从其他密钥库导入一个或所有条目 -keypasswd 更改条目的密钥口令 -list 列出密钥库中的条目 -printcert 打印证书内容 -printcertreq 打印证书请求的内容 -printcrl 打印 CRL 文件的内容 -storepasswd 更改密钥库的存储口令使用 &quot;keytool -command_name -help&quot; 获取 command_name 的用法C:\\Users\\Administrator&gt;keytool -genkeypair --helpkeytool -genkeypair [OPTION]...生成密钥对选项: -alias &lt;alias&gt; 要处理的条目的别名 -keyalg &lt;keyalg&gt; 密钥算法名称 -keysize &lt;keysize&gt; 密钥位大小 -sigalg &lt;sigalg&gt; 签名算法名称 -destalias &lt;destalias&gt; 目标别名 -dname &lt;dname&gt; 唯一判别名 -startdate &lt;startdate&gt; 证书有效期开始日期&#x2F;时间 -ext &lt;value&gt; X.509 扩展 -validity &lt;valDays&gt; 有效天数 -keypass &lt;arg&gt; 密钥口令 -keystore &lt;keystore&gt; 密钥库名称 -storepass &lt;arg&gt; 密钥库口令 -storetype &lt;storetype&gt; 密钥库类型 -providername &lt;providername&gt; 提供方名称 -providerclass &lt;providerclass&gt; 提供方类名 -providerarg &lt;arg&gt; 提供方参数 -providerpath &lt;pathlist&gt; 提供方类路径 -v 详细输出 -protected 通过受保护的机制的口令使用 &quot;keytool -help&quot; 获取所有可用命令 3、创建证书这里使用如下命令生成证书： 1keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -keystore &quot;E:\\tomcat.keystore&quot; 参数说明：-genkeypair 表示生成密钥对;-alias 表示别名，该别名是公开的;-keyalg 表示密钥算法名称,本例中的采用通用的RAS加密算法;-keystore 表示密钥库的路径及名称，不指定的话，默认在操作系统的用户目录下生成一个”.keystore”的文件 然后安装提示输入，但需要注意的是 名字与姓氏 那个是填写域名的。 此外，尽量前后密码一致，避免后面出现密码错误的问题。密钥库的密码至少必须6个字符，可以是纯数字或者字母或者数字和字母的组合等等,其他的可以不填。 12345678910111213141516171819202122C:\\Users\\Administrator&gt;keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -keystore &quot;E:\\tomcat.keystore&quot;输入密钥库口令:再次输入新口令:您的名字与姓氏是什么? [Unknown]: local.test.com您的组织单位名称是什么? [Unknown]:您的组织名称是什么? [Unknown]:您所在的城市或区域名称是什么? [Unknown]:您所在的省&#x2F;市&#x2F;自治区名称是什么? [Unknown]:该单位的双字母国家&#x2F;地区代码是什么? [Unknown]:CN&#x3D;local.test.com, OU&#x3D;Unknown, O&#x3D;Unknown, L&#x3D;Unknown, ST&#x3D;Unknown, C&#x3D;Unknown是否正确? [否]: y输入 &lt;tomcat&gt; 的密钥口令 (如果和密钥库口令相同, 按回车): 这里随便写了个域名，是一个不存在的二级域名，为了能够访问，需要在 C:\\Windows\\System32\\drivers\\etc 路径下的 hosts 文件添加： 1127.0.0.1 local.test.com 二、tomcat 配置 https 证书通过上面的步骤，生成了密钥，修改tomcat配置文件：/conf/server.xml, 添加如下设置： 1234567891011&lt;Connector port&#x3D;&quot;443&quot; protocol&#x3D;&quot;org.apache.coyote.http11.Http11Protocol&quot; maxThreads&#x3D;&quot;150&quot; SSLEnabled&#x3D;&quot;true&quot; scheme&#x3D;&quot;https&quot; secure&#x3D;&quot;true&quot; clientAuth&#x3D;&quot;false&quot; sslProtocol&#x3D;&quot;TLS&quot; keystoreFile&#x3D;&quot;E:\\tomcat.keystore&quot; keystorePass&#x3D;&quot;test8544903&quot; &#x2F;&gt; 其中，keystoreFile 指明密钥位置，keystorePass 指明密钥密码。在该配置文件中有 https的 Connector 配置，被注释掉了。https 默认端口为 443。上面介绍了自己生成密钥配置https的方法，只适合本地测试.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Container","slug":"Dev/Container","permalink":"http://www.lida1024.top/categories/Dev/Container/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://www.lida1024.top/tags/Tomcat/"}]},{"title":"Centos 7 web 环境搭建","slug":"Centos-7-web-环境搭建","date":"2020-03-01T09:51:00.000Z","updated":"2020-04-11T00:28:14.457Z","comments":true,"path":"2020/03/01/Centos-7-web-环境搭建/","link":"","permalink":"http://www.lida1024.top/2020/03/01/Centos-7-web-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"1、Xshell 5为了方便管理操作服务器，这里采用 xshell 5 来连接服务器，使用ssh证书，端口号 22，对于购买的与主机需要开放相应的端口。如下是连接成功的提示： 123456[c:\\~]$ open Connecting to 115.159.200.102:22... Connection established. To escape to local shell, press &#39;Ctrl+Alt+]&#39;. Last login: Sat Mar 10 18:37:31 2017 from 115.195.220.207 [root@imtianx ~]# 其中 [root@imtianx ~]一句，rooot为登陆账号，imtianx 为主机名。默认主机名一般很长，可以进行修改： 12345678# 设置主机名为namehostnamectl set-hostname name # 查看是否设置成功hostnamectl status # 重启 reboot 重启后提示符才会变。 2、JDK安装jdk，这里采用 rpm 方式安装， 1234# 下载jdk curl -O http:&#x2F;&#x2F;download.oracle.com&#x2F;otn-pub&#x2F;java&#x2F;jdk&#x2F;8u121-b13&#x2F;jdk-8u121-linux-x64.rpm # 使用 rpm 安装 rpm -ivh jdk-8u121-linux-x64.rpm 然后 可以使用 java -version 、javac 查看是否安装成功。由于 rpm 的安装方式会把jdk安装到 /usr/java/jdk1.8.0_121下，通过三层；链接到 /usr/bin下，环境变量可以不用配置。环境变量配置方法： 1vim &#x2F;etc&#x2F;profile &#x2F;&#x2F;打开 profile 添加下面的配置信息: 123456#set java environment JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_121 JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre CLASS_PATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin export JAVA_HOME JRE_HOME CLASS_PATH PATH 若需要立即生效，可执行如下命令： 1source &#x2F;etc&#x2F;profile 3、Tomcat1234567891011# 下载 Tomcat wget http:&#x2F;&#x2F;download.nextag.com&#x2F;apache&#x2F;tomcat&#x2F;tomcat-8&#x2F;v8.5.12&#x2F;bin&#x2F;apache-tomcat-8.5.12.zip # 解压,可使用 rm 移动位子 unzip apache-tomcat-8.5.12.zip # tomcat&#x2F;bin下执行，授予 .sh 文件执行权限 chomd +x *.sh # 启动服务，若无法启动 请看后文 使用 systemctl 命令 startup.sh 由于防火墙的限制，需要开放相应的端口，这里选择 iptables 防火墙。 12345678910111213141516# 安装 yum install iptables-services #配置防火墙 vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables # 在 22端口号线面添加 如下端口，然后保存并退出 （：wq） -A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT #重启防火墙 systemctl restart iptables.service #查看 开放端口 iptables -L -n 注：这里必须要在 22端口号下面添加，不能添加到最后，为方便将tomcat端口配置为80，mysql 数据库端口为 3306，这里一并开放。设置Tomcat 为服务，开机自启。首先在 /usr/lib/systemd/system/ 目录下添加 tomcat.service 文件，内容如下： 1234567891011121314[unit] Description&#x3D;Tomcat After&#x3D;syslog.target network.target remote-fs.target nss-lookup.target [Service] Type&#x3D;forking PIDFile&#x3D;&#x2F;home&#x2F;tomcat&#x2F;tomcat.pid ExecStart&#x3D;&#x2F;home&#x2F;tomcat&#x2F;bin&#x2F;startup.sh ExecReload&#x3D;&#x2F;bin&#x2F;kill -s HUP $MAINPID ExecStop&#x3D;&#x2F;bin&#x2F;kill -s QUIT $MAINPID PrivateTmp&#x3D;true [Install] WantedBy&#x3D;multi-user.target 然后在 tomcat/bin/ 下添加 setenv.ssh文件，设置pid 及 java内存（可忽略）内容如下： 1234#add tomcat pid CATALINA_PID&#x3D;&quot;$CATALINA_BASE&#x2F;tomcat.pid&quot; #add java opts JAVA_OPTS&#x3D;&quot;-server -XX:PermSize&#x3D;256M -XX:MaxPermSize&#x3D;1024m -Xms512M -Xmx1024M -XX:MaxNewSize&#x3D; 256m&quot; 最后使用 systemctl 相关命令，设置服务，如下： 1234567891011# 启动服务，stop停止 systemctl start tomcat # 查看服务状态 systemctl status name # 设置开机自启，disable删除 systemctl enable tomcat # 重启服务 systemctl restart tomcat 4、Mysql（Mariadb）这里选择了较为轻量级的 Mariadb 安装，与mysql类似。具体安装命令如下： 12345678910111213# 安装 yum -y install mariadb mariadb-server # 启动 systemctl start mariadb # 设置开机启动 systemctl enable mariadb # 接着是对数据库的配置信息 # ... # 最后授予 权限 grant all privileges on *.* to root@&#39;%&#39; identified by &#39;password&#39;; 对于设置编码之类的，更多 Mariadb 的安装配置，请 点击此处查看 此外，往往需要文件的上传下载，这里选择 lrzsz 123456# 安装yum install lrzsz# 上传rz# 下载sz 转载:http://imtianx.cn/2017/03/25/Centos%207%20web%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Linux","slug":"Dev/Linux","permalink":"http://www.lida1024.top/categories/Dev/Linux/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://www.lida1024.top/tags/%E9%83%A8%E7%BD%B2/"}],"author":"少年闰土"},{"title":"Git常用命令","slug":"Git常用命令","date":"2020-02-29T10:53:00.000Z","updated":"2020-04-11T08:04:30.829Z","comments":true,"path":"2020/02/29/Git常用命令/","link":"","permalink":"http://www.lida1024.top/2020/02/29/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"相关资料：廖雪峰教程链接Git远程操作详解Git查看、删除、重命名远程分支和tag 操作流程日常使用git更新提交代码的一般流程是这样的： 在对代码进行了一些修改之后，使用：git add .或git add -A(git add --all的缩写)将本地所有新增文件添加进版本库。 使用：git commit -m 备注 将代码提交到本地版本库。（备注内容没有空格的话不需要加引号） 使用：git pull 从服务器拉取代码，更新本地版本库。 使用：git push 将本地版本库推送到服务器。 git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写） git add -A ：是上面两个功能的合集（git add –all的缩写） 创建创建并切换 branch1git checkout -b 分支名 仅仅切换 branch1git checkout 分支名 创建 tag1git tag 标签名 创建 tag 并备注(备注信息加不加双引号都可以)1git tag -a 标签名 -m 备注信息 创建PGP tag 并备注1git tag -s 标签名 -m 备注信息 查看查看本地 branch list1git branch 分支名 查看远程 branch list1git branch -r 分支名 查看所有 branch list1git branch -a 分支名 查看本地 tag1git tag 查看某个本地 tag 详情1git show 标签名 删除删除本地 branch / tag1git branch -d 分支名或标签名 删除所有未推送的本地 branch1git fetch -p 仅仅删除某个远程 branch / tag123git push origin :分支名或标签名# 或者git push origin --delete 分支名或标签名 推送推送某个 branch / tag1git push origin 分支名或标签名 推送所有 branch1git push --all origin 推送所有 tag1git push --tags 重命名重命名本地分支 1git branch -m 旧分支名 新分支名 重命名远程分支需要分三步操作 删除远程分支 重命名本地分支 推送本地分支 回滚soft （默认）只回滚到某个commit，本地代码不变 (不加–soft或–hard默认为–soft) 1git reset --soft 分支名或标签名 hard彻底回滚（commit和本地代码都回滚） 1彻底回滚（commit和本地代码都回滚） 下载、合并分支合并某本地分支到当前分支 1git merge 分支名 合并某远程分支到当前分支 直接合并，慎用 1git pull origin 远程分支名 下载某个远程标签 1git fetch origin tag 远程标签名","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Tools","slug":"Dev/Tools","permalink":"http://www.lida1024.top/categories/Dev/Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.lida1024.top/tags/Git/"}]},{"title":"RSA 非对称加密原理","slug":"RSA-非对称加密原理","date":"2020-02-28T06:22:00.000Z","updated":"2020-04-10T06:02:55.013Z","comments":true,"path":"2020/02/28/RSA-非对称加密原理/","link":"","permalink":"http://www.lida1024.top/2020/02/28/RSA-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/","excerpt":"","text":"RSA 加密原理 步骤 说明 描述 备注 1 找出质数 P 、Q - 2 计算公共模数 N = P * Q - 3 欧拉函数 φ(N) = (P-1)(Q-1) - 4 计算公钥E 1 &lt; E &lt; φ(N) E的取值必须是整数E 和 φ(N) 必须是互质数 5 计算私钥D E * D % φ(N) = 1 - 6 加密 C ＝ M E mod N C：密文 M：明文 7 解密 M ＝C D mod N C：密文 M：明文 公钥＝(E , N)私钥＝(D, N) 对外，我们只暴露公钥。 示例1、找出质数 P 、Q12P &#x3D; 3 Q &#x3D; 11 2、计算公共模数12N &#x3D; P * Q &#x3D; 3 * 11 &#x3D; 33N &#x3D; 33 3、 欧拉函数12φ(N) &#x3D; (P-1)(Q-1) &#x3D; 2 * 10 &#x3D; 20φ(N) &#x3D; 20 4、计算公钥E121 &lt; E &lt; φ(N)1 &lt;E &lt; 20 E 的取值范围 {3, 7, 9, 11, 13, 17, 19}E的取值必须是整数, E 和 φ(N) 必须是互质数为了测试，我们取最小的值 E =33 和 φ(N) =20 互为质数，满足条件 5、计算私钥D12E * D % φ(N) &#x3D; 13 * D % 20 &#x3D; 1 根据上面可计算出 D = 7 6、公钥加密我们这里为了演示，就加密一个比较小的数字 M = 2 公式：C ＝ ME mod N 123M &#x3D; 2E &#x3D; 3N &#x3D; 33 C = 23 % 33 = 8 明文 “2” 经过 RSA 加密后变成了密文 “8” 7、私钥解密 M ＝CD mod N 123C &#x3D; 8D &#x3D; 7N &#x3D; 33 M = 87 % 338 * 8 * 8 * 8 * 8 * 8 * 8=20971528 * 8 * 8 * 8 * 8 * 8 * 8 % 33 = 2 密文 “8” 经过 RSA 解密后变成了明文 2。 JDK 自带的 RSA 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.NoSuchAlgorithmException;import java.security.PrivateKey;import java.security.PublicKey;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import javax.crypto.Cipher;import org.apache.commons.codec.binary.Base64;&#x2F;** * 非对称加密 唯一广泛接受并实现 数据加密&amp;数字签名 公钥加密、私钥解密 私钥加密、公钥解密 * * @author jjs * *&#x2F;public class RSADemo &#123; private static String src &#x3D; &quot;infcn&quot;; private static RSAPublicKey rsaPublicKey; private static RSAPrivateKey rsaPrivateKey; static &#123; &#x2F;&#x2F; 1、初始化密钥 KeyPairGenerator keyPairGenerator; try &#123; keyPairGenerator &#x3D; KeyPairGenerator.getInstance(&quot;RSA&quot;); keyPairGenerator.initialize(512);&#x2F;&#x2F; 64的整倍数 KeyPair keyPair &#x3D; keyPairGenerator.generateKeyPair(); rsaPublicKey &#x3D; (RSAPublicKey) keyPair.getPublic(); rsaPrivateKey &#x3D; (RSAPrivateKey) keyPair.getPrivate(); System.out.println(&quot;Public Key : &quot; + Base64.encodeBase64String(rsaPublicKey.getEncoded())); System.out.println(&quot;Private Key : &quot; + Base64.encodeBase64String(rsaPrivateKey.getEncoded())); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; &#125; &#x2F;** * 公钥加密，私钥解密 * @author jijs *&#x2F; public static void pubEn2PriDe() &#123; &#x2F;&#x2F;公钥加密 X509EncodedKeySpec x509EncodedKeySpec &#x3D; new X509EncodedKeySpec(rsaPublicKey.getEncoded()); KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;); PublicKey publicKey &#x3D; keyFactory.generatePublic(x509EncodedKeySpec); Cipher cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.ENCRYPT_MODE, publicKey); byte[] result &#x3D; cipher.doFinal(src.getBytes()); System.out.println(&quot;公钥加密，私钥解密 --加密: &quot; + Base64.encodeBase64String(result)); &#x2F;&#x2F;私钥解密 PKCS8EncodedKeySpec pkcs8EncodedKeySpec &#x3D; new PKCS8EncodedKeySpec(rsaPrivateKey.getEncoded()); keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;); PrivateKey privateKey &#x3D; keyFactory.generatePrivate(pkcs8EncodedKeySpec); cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.DECRYPT_MODE, privateKey); result &#x3D; cipher.doFinal(result); System.out.println(&quot;公钥加密，私钥解密 --解密: &quot; + new String(result)); &#125; &#x2F;** * 私钥加密，公钥解密 * @author jijs *&#x2F; public static void priEn2PubDe() &#123; &#x2F;&#x2F;私钥加密 PKCS8EncodedKeySpec pkcs8EncodedKeySpec &#x3D; new PKCS8EncodedKeySpec(rsaPrivateKey.getEncoded()); KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;); PrivateKey privateKey &#x3D; keyFactory.generatePrivate(pkcs8EncodedKeySpec); Cipher cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.ENCRYPT_MODE, privateKey); byte[] result &#x3D; cipher.doFinal(src.getBytes()); System.out.println(&quot;私钥加密，公钥解密 --加密 : &quot; + Base64.encodeBase64String(result)); &#x2F;&#x2F;公钥解密 X509EncodedKeySpec x509EncodedKeySpec &#x3D; new X509EncodedKeySpec(rsaPublicKey.getEncoded()); keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;); PublicKey publicKey &#x3D; keyFactory.generatePublic(x509EncodedKeySpec); cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.DECRYPT_MODE, publicKey); result &#x3D; cipher.doFinal(result); System.out.println(&quot;私钥加密，公钥解密 --解密: &quot; + new String(result)); &#125; public static void main(String[] args) &#123; pubEn2PriDe(); &#x2F;&#x2F;公钥加密，私钥解密 priEn2PubDe(); &#x2F;&#x2F;私钥加密，公钥解密 &#125;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"加密解密","slug":"加密解密","permalink":"http://www.lida1024.top/tags/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"}]},{"title":"HTTP 413错误解决方法","slug":"HTTP-413错误解决方法","date":"2020-02-27T03:26:00.000Z","updated":"2020-04-10T03:57:32.701Z","comments":true,"path":"2020/02/27/HTTP-413错误解决方法/","link":"","permalink":"http://www.lida1024.top/2020/02/27/HTTP-413%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"这是由于上传文件过大引起的。 代码检查如果是springmvc的框架，用mutipartFile上传的文件，先检查配置文件中的最大上传文件胆小。spring-mvc.xml 12345&lt;!-- 上传文件拦截，设置最大上传文件大小 10M&#x3D;10*1024*1024(B)&#x3D;10485760 bytes 和编码，如果这里设置过小会导致图片可能无法上传--&gt; &lt;bean id&#x3D;&quot;multipartResolver&quot; class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;10485760&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;UTF-8&quot; &#x2F;&gt; &lt;&#x2F;bean&gt; 查看上传的文件是否超出了最大限制，根据自己的情况进行修改。 如果服务器使用了nginx做反向代理。检查Nginx的文件上传大小的配置。方法：修改nginx配置文件，配置客户端请求大小和缓存大小 1vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 在http{}中输入: 12client_max_body_size 8M;(配置请求体缓存区大小) client_body_buffer_size 128k;(设置客户端请求体最大值) 重启nginx 12cd sbin.&#x2F;nginx -s reload","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"Http","slug":"Http","permalink":"http://www.lida1024.top/tags/Http/"}]},{"title":"Lambda表达式","slug":"Lambda表达式","date":"2020-02-26T03:29:00.000Z","updated":"2020-04-10T06:04:51.366Z","comments":true,"path":"2020/02/26/Lambda表达式/","link":"","permalink":"http://www.lida1024.top/2020/02/26/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"引言在 Java 8 以前，若我们想要把某些功能传递给某些方法，总要去写匿名类。以前注册事件监听器的写法与下面的示例代码就很像： 123456manager.addScheduleListener(new ScheduleListener() &#123; @Override public void onSchedule(ScheduleEvent e) &#123; &#x2F;&#x2F; Event listener implementation goes here... &#125;&#125;); 这里我们添加了一些自定义代码到 Schedule 监听器中，需要先定义匿名内部类，然后传递一些功能到 onSchedule 方法中。 正是 Java 在作为参数传递普通方法或功能的限制，Java 8 增加了一个全新语言级别的功能，称为 Lambda 表达式。 为什么 Java 需要 Lambda 表达式Java 是面向对象语言，除了原始数据类型之处，Java 中的所有内容都是一个对象。而在函数式语言中，我们只需要给函数分配变量，并将这个函数作为参数传递给其它函数就可实现特定的功能。JavaScript 就是功能编程语言的典范（闭包）。 Lambda 表达式的加入，使得 Java 拥有了函数式编程的能力。在其它语言中，Lambda 表达式的类型是一个函数；但在 Java 中，Lambda 表达式被表示为对象，因此它们必须绑定到被称为功能接口的特定对象类型。 Lambda 表达式简介Lambda 表达式是一个匿名函数（对于 Java 而言并不很准确，但这里我们不纠结这个问题）。简单来说，这是一种没有声明的方法，即没有访问修饰符，返回值声明和名称。 在仅使用一次方法的地方特别有用，方法定义很短。它为我们节省了，如包含类声明和编写单独方法的工作。 Java 中的 Lambda 表达式通常使用语法是 (argument) -&gt; (body)，比如： 123(arg1, arg2...) -&gt; &#123; body &#125;(type1 arg1, type2 arg2...) -&gt; &#123; body &#125; 以下是 Lambda 表达式的一些示例： 123456789(int a, int b) -&gt; &#123; return a + b; &#125;() -&gt; System.out.println(&quot;Hello World&quot;);(String s) -&gt; &#123; System.out.println(s); &#125;() -&gt; 42() -&gt; &#123; return 3.1415 &#125;; Lambda 表达式的结构 Lambda 表达式可以具有零个，一个或多个参数。 可以显式声明参数的类型，也可以由编译器自动从上下文推断参数的类型。例如(int a) 与刚才相同 (a)。 参数用小括号括起来，用逗号分隔。例如 (a, b) 或 (int a, int b) 或 (String a, int b, float c)。 空括号用于表示一组空的参数。例如 () -&gt; 42。 当有且仅有一个参数时，如果不显式指明类型，则不必使用小括号。例如 a -&gt; return a*a。 Lambda 表达式的正文可以包含零条，一条或多条语句。 如果 Lambda 表达式的正文只有一条语句，则大括号可不用写，且表达式的返回值类型要与匿名函数的返回类型相同。 如果 Lambda 表达式的正文有一条以上的语句必须包含在大括号（代码块）中，且表达式的返回值类型要与匿名函数的返回类型相同。方法引用#####从 Lambda 表达式到双冒号操作符使用 Lambda 表达式，我们已经看到代码可以变得非常简洁。 例如，要创建一个比较器，以下语法就足够了 1Comparator c &#x3D; (Person p1, Person p2) -&gt; p1.getAge().compareTo(p2.getAge()); 然后，使用类型推断： 1Comparator c &#x3D; (p1, p2) -&gt; p1.getAge().compareTo(p2.getAge()); 但是，我们可以使上面的代码更具表现力和可读性吗？我们来看一下： 1Comparator c &#x3D; Comparator.comparing(Person::getAge); 使用 :: 运算符作为 Lambda 调用特定方法的缩写，并且拥有更好的可读性。 使用方式双冒号（::）操作符是 Java 中的方法引用。当们使用一个方法的引用时，目标引用放在::之前，目标引用提供的方法名称放在::之后，即 目标引用::方法。比如： 1Person::getAge; 在 Person 类中定义的方法 getAge 的方法引用。 然后我们可以使用 Function 对象进行操作： 1234&#x2F;&#x2F; 获取 getAge 方法的 Function 对象Function&lt;Person, Integer&gt; getAge &#x3D; Person::getAge;&#x2F;&#x2F; 传参数调用 getAge 方法Integer age &#x3D; getAge.apply(p); 我们引用 getAge，然后将其应用于正确的参数。 目标引用的参数类型是 Function&lt;T,R&gt;，T 表示传入类型，R 表示返回类型。比如，表达式person -&gt; person.getAge();，传入参数是person，返回值是 person.getAge()，那么方法引用 Person::getAge 就对应着 Function&lt;Person,Integer&gt; 类型。 什么是功能接口（Functional interface）在 Java 中，功能接口（Functional interface）指只有一个抽象方法的接口。 java.lang.Runnable 是一个功能接口，在 Runnable 中只有一个方法的声明 void run()。我们使用匿名内部类实例化功能接口的对象，而使用 Lambda 表达式，可以简化写法。 每个 Lambda 表达式都可以隐式地分配给功能接口。例如，我们可以从 Lambda 表达式创建 Runnable 接口的引用，如下所示： 1Runnable r &#x3D; () -&gt; System.out.println(&quot;hello world&quot;); 当我们不指定功能接口时，这种类型的转换会被编译器自动处理。例如： 123new Thread( () -&gt; System.out.println(&quot;hello world&quot;)).start(); 在上面的代码中，编译器会自动推断，Lambda 表达式可以从 Thread类的构造函数签名（public Thread(Runnable r) { }）转换为 Runnable 接口。 @FunctionalInterface 是在 Java 8 中添加的一个新注解，用于指示接口类型，声明接口为 Java 语言规范定义的功能接口。Java 8 还声明了 Lambda 表达式可以使用的功能接口的数量。当您注释的接口不是有效的功能接口时， @FunctionalInterface会产生编译器级错误。 以下是自定义功能接口的示例： 1234567package com.wuxianjiezh.demo.lambda;@FunctionalInterfacepublic interface WorkerInterface &#123; public void doSomeWork();&#125; 正如其定义所述，功能接口只能有一个抽象方法。如果我们尝试在其中添加一个抽象方法，则会抛出编译时错误。例如： 12345678package com.wuxianjiezh.demo.lambda;@FunctionalInterfacepublic interface WorkerInterface &#123; public void doWork(); public void doMoreWork();&#125; 错误： 123Error:(3, 1) java: 意外的 @FunctionalInterface 注释 com.wuxianjiezh.demo.lambda.WorkerInterface 不是函数接口 在 接口 com.wuxianjiezh.demo.lambda.WorkerInterface 中找到多个非覆盖抽象方法 一旦定义了功能接口，我们就可以利用 Lambda 表达式调用。例如： 123456789101112131415161718192021222324252627package com.wuxianjiezh.demo.lambda;@FunctionalInterfacepublic interface WorkerInterface &#123; public void doWork();&#125;class WorkTest &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; 通过匿名内部类调用 WorkerInterface work &#x3D; new WorkerInterface() &#123; @Override public void doWork() &#123; System.out.println(&quot;通过匿名内部类调用&quot;); &#125; &#125;; work.doWork(); &#x2F;&#x2F; 通过 Lambda 表达式调用 &#x2F;&#x2F; Lambda 表达式实际上是一个对象。 &#x2F;&#x2F; 我们可以将 Lambda 表达式赋值给一个变量，就可像其它对象一样调用。 work &#x3D; ()-&gt; System.out.println(&quot;通过 Lambda 表达式调用&quot;); work.doWork(); &#125;&#125; 运行结果： 12通过匿名内部类调用通过 Lambda 表达式调用 Lambda 表达式的例子线程初始化线程可以初始化如下： 123456789101112&#x2F;&#x2F; Old waynew Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Hello world&quot;); &#125;&#125;).start();&#x2F;&#x2F; New waynew Thread( () -&gt; System.out.println(&quot;Hello world&quot;)).start(); 我们在使用IDEA的时候，如果写出Old way的代码，IDEA会提示我们将其转换为Lambda表达式的形式，为IDEA点赞！ 我们将光标移动到灰色代码区域(new Runnable这里)，使用快捷键alt+Enter就可以实现自动转换了。 事件处理事件处理可以用 Java 8 使用Lambda表达式来完成。以下代码显示了将 ActionListener 添加到 UI 组件的新旧方式： 123456789101112&#x2F;&#x2F; Old waybutton.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println(&quot;Hello world&quot;); &#125;&#125;);&#x2F;&#x2F; New waybutton.addActionListener( (e) -&gt; &#123; System.out.println(&quot;Hello world&quot;);&#125;); 遍例输出（方法引用）输出给定数组的所有元素的简单代码。请注意，还有一种使用 Lambda 表达式的方式。 1234567891011&#x2F;&#x2F; old wayList&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7);for (Integer n : list) &#123; System.out.println(n);&#125;&#x2F;&#x2F; 使用 -&gt; 的 Lambda 表达式list.forEach(n -&gt; System.out.println(n));&#x2F;&#x2F; 使用 :: 的 Lambda 表达式list.forEach(System.out::println); 这里顺便补充一下Arrays.asList()方法。Arrays.asList()将数组转换为集合后,底层其实还是数组，《阿里巴巴》Java 开发使用手册对于这个方法有如下描述： 如何正确的将数组转换为ArrayList？可以像下面这样(参见：stackoverflow- https://dwz.cn/vcBkTiTW) 1List list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) 逻辑操作输出通过逻辑判断的数据。 123456789101112131415161718192021222324252627282930313233343536package com.wuxianjiezh.demo.lambda;import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class Main &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7); System.out.print(&quot;输出所有数字：&quot;); evaluate(list, (n) -&gt; true); System.out.print(&quot;不输出：&quot;); evaluate(list, (n) -&gt; false); System.out.print(&quot;输出偶数：&quot;); evaluate(list, (n) -&gt; n % 2 &#x3D;&#x3D; 0); System.out.print(&quot;输出奇数：&quot;); evaluate(list, (n) -&gt; n % 2 &#x3D;&#x3D; 1); System.out.print(&quot;输出大于 5 的数字：&quot;); evaluate(list, (n) -&gt; n &gt; 5); &#125; public static void evaluate(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123; for (Integer n : list) &#123; if (predicate.test(n)) &#123; System.out.print(n + &quot; &quot;); &#125; &#125; System.out.println(); &#125;&#125; 运行结果： 12345输出所有数字：1 2 3 4 5 6 7不输出：输出偶数：2 4 6输出奇数：1 3 5 7输出大于 5 的数字：6 7 Stream API 示例java.util.stream.Stream接口 和 Lambda 表达式一样，都是 Java 8 新引入的。所有 Stream 的操作必须以 Lambda 表达式为参数。Stream 接口中带有大量有用的方法，比如 map()的作用就是将 input Stream 的每个元素，映射成output Stream 的另外一个元素。 下面的例子，我们将 Lambda 表达式 x -&gt; x*x传递给map()方法，将其应用于流的所有元素。之后，我们使用 forEach打印列表的所有元素。 12345678910&#x2F;&#x2F; old wayList&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5,6,7);for(Integer n : list) &#123; int x &#x3D; n * n; System.out.println(x);&#125;&#x2F;&#x2F; new wayList&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5,6,7);list.stream().map((x) -&gt; x*x).forEach(System.out::println); 下面的示例中，我们给定一个列表，然后求列表中每个元素的平方和。这个例子中，我们使用了 reduce() 方法，这个方法的主要作用是把 Stream 元素组合起来。 12345678910111213&#x2F;&#x2F; old wayList&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5,6,7);int sum &#x3D; 0;for(Integer n : list) &#123; int x &#x3D; n * n; sum &#x3D; sum + x;&#125;System.out.println(sum);&#x2F;&#x2F; new wayList&lt;Integer&gt; list &#x3D; Arrays.asList(1,2,3,4,5,6,7);int sum &#x3D; list.stream().map(x -&gt; x*x).reduce((x,y) -&gt; x + y).get();System.out.println(sum); Lambda 表达式和匿名类之间的区别 this 关键字。对于匿名类this 关键字解析为匿名类，而对于 Lambda 表达式，this 关键字解析为包含写入 Lambda 的类。 编译方式。Java 编译器编译Lambda 表达式时，会将其转换为类的私有方法，再进行动态绑定。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"Lambda","slug":"Lambda","permalink":"http://www.lida1024.top/tags/Lambda/"}]},{"title":"MyBatis返回Map键值对数据Key值大小写问题","slug":"MyBatis返回Map键值对数据Key值大小写问题","date":"2020-01-23T00:56:00.000Z","updated":"2020-04-10T06:04:38.927Z","comments":true,"path":"2020/01/23/MyBatis返回Map键值对数据Key值大小写问题/","link":"","permalink":"http://www.lida1024.top/2020/01/23/MyBatis%E8%BF%94%E5%9B%9EMap%E9%94%AE%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AEKey%E5%80%BC%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/","excerpt":"","text":"Controller1234567891011121314@RestController@RequestMapping(&quot;&#x2F;web&quot;)public class MapKeyTest &#123; @Autowired private InvoicingBuyOrderService invoicingBuyOrderService; @GetMapping(&quot;&#x2F;testKey&quot;) public Map&lt;String,Object&gt; testMayKey(String id)&#123; Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;(); Map&lt;String,String&gt; result &#x3D; this.invoicingBuyOrderService.test(id); map.put(&quot;data&quot;,result); return map; &#125;&#125; Service1Map&lt;String,String&gt; test(String id); ServiceImpl12345@Overridepublic Map&lt;String, String&gt; test(String id) &#123; Map&lt;String, String&gt; map &#x3D; this.invoicingPackageunitMapper.selectPackageNameByCommodityDetailId(id); return map;&#125; Mapper1Map&lt;String,String&gt; selectPackageNameByCommodityDetailId(@Param(&quot;commodityDetailId&quot;) String commodityDetailId); XML①我们不设置字段的别名123&lt;select id&#x3D;&quot;selectPackageNameByCommodityDetailId&quot; parameterType&#x3D;&quot;java.lang.String&quot; resultType&#x3D;&quot;java.util.HashMap&quot;&gt;select * from invoicing_commoditydetailprice icd where icd.COMMODITYDETAILPRICE_ID&#x3D;#&#123;commodityDetailId&#125; postMan请求：localhost:8001/FHSHGL/web/testKey?id=15b67d1756134936a6fbc8a5d5007bef返回值： 123456789101112131415161718&#123; &quot;data&quot;: &#123; &quot;SMALL_PACKAGE_COUNT&quot;: &quot;300&quot;, &quot;SMALL_PACKAGE_UNIT_ID&quot;: &quot;0f899de1f92911e8bb4500ffa0c803da&quot;, &quot;PHP_ID&quot;: 80270, &quot;MIDDLE_PACKAGE_UNIT_ID&quot;: &quot;0f8995cef92911e8bb4500ffa0c803da&quot;, &quot;CREATED_TIME&quot;: 1570839233000, &quot;UPDATED_TIME&quot;: 1570839233000, &quot;PRODUCTION_TIME&quot;: 1522425600000, &quot;IN_PRICE&quot;: &quot;15.00&quot;, &quot;MIDDLE_PACKAGE_COUNT&quot;: &quot;20&quot;, &quot;OUT_PRICE&quot;: &quot;15.00&quot;, &quot;INVOICING_COMMODITY_ID&quot;: &quot;25422c6135ed497dafa5f6e50fd6abcd&quot;, &quot;CODE&quot;: &quot;11325882056318109808267349261365&quot;, &quot;BIG_PACKAGE_UNIT_ID&quot;: &quot;0f894c61f92911e8bb4500ffa0c803da&quot;, &quot;COMMODITYDETAILPRICE_ID&quot;: &quot;15b67d1756134936a6fbc8a5d5007bef&quot; &#125;&#125; ②设置返回字段的别名123456789101112&lt;select id&#x3D;&quot;selectPackageNameByCommodityDetailId&quot; parameterType&#x3D;&quot;java.lang.String&quot; resultType&#x3D;&quot;java.util.HashMap&quot;&gt; SELECT ips.&#96;NAME&#96; AS smallName, ipm.&#96;NAME&#96; AS middleName, ipb.&#96;NAME&#96; AS bigName FROM invoicing_commoditydetailprice icd LEFT JOIN invoicing_packageunit ips ON icd.SMALL_PACKAGE_UNIT_ID &#x3D; ips.PACKAGEUNIT_ID LEFT JOIN invoicing_packageunit ipm ON icd.MIDDLE_PACKAGE_UNIT_ID &#x3D; ipm.PACKAGEUNIT_ID LEFT JOIN invoicing_packageunit ipb ON icd.BIG_PACKAGE_UNIT_ID &#x3D; ipb.PACKAGEUNIT_ID WHERE icd.COMMODITYDETAILPRICE_ID&#x3D;#&#123;commodityDetailId&#125;&lt;&#x2F;select&gt; postMan请求：localhost:8001/FHSHGL/web/testKey?id=15b67d1756134936a6fbc8a5d5007bef返回值： 1234567&#123; &quot;data&quot;: &#123; &quot;bigName&quot;: &quot;箱&quot;, &quot;middleName&quot;: &quot;瓶&quot;, &quot;smallName&quot;: &quot;克&quot; &#125;&#125; springboot中处理mybatis返回Map时key值的大小写为了统一不同数据库返回key值大小写不一致的问题，特自定义ObjectWrapperFactory来做统一的处理 1、首先自定义MapWrapper12345678910111213&#x2F;** * 将Map的key全部转换为小写 * *&#x2F;public class MapKeyLowerWrapper extends MapWrapper &#123; public MapKeyLowerWrapper(MetaObject metaObject, Map&lt;String, Object&gt; map) &#123; super(metaObject, map); &#125; @Override public String findProperty(String name, boolean useCamelCaseMapping) &#123; return name&#x3D;&#x3D;null?&quot;&quot;:name.toLowerCase() ; &#125;&#125; 2、自定义ObjectWrapperFactorymybatis默认的ObjectWrapperFactory 12345678910public class DefaultObjectWrapperFactory implements ObjectWrapperFactory &#123; public boolean hasWrapperFor(Object object) &#123; return false; &#125; public ObjectWrapper getWrapperFor(MetaObject metaObject, Object object) &#123; throw new ReflectionException( &quot;The DefaultObjectWrapperFactory should never be called to provide an ObjectWrapper.&quot;); &#125;&#125; 我们自定义的如下： 123456789101112public class MapWrapperFactory implements ObjectWrapperFactory &#123; @Override public boolean hasWrapperFor(Object object) &#123; return object !&#x3D; null &amp;&amp; object instanceof Map; &#125; @Override public ObjectWrapper getWrapperFor(MetaObject metaObject, Object object) &#123; return new MapKeyLowerWrapper(metaObject, (Map) object); &#125;&#125; 3、在mybatis的配置中添加 MapWrapperFactory 的配置123456789101112131415161718192021222324252627282930@Bean(name &#x3D; &quot;sqlSessionFactory&quot;)@ConditionalOnBean(name &#x3D; &quot;dataSource&quot;)public SqlSessionFactory sqlSessionFactoryBean(@Qualifier(&quot;dataSource&quot;) DataSource dataSource) &#123; SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean(); bean.setObjectWrapperFactory(new MapWrapperFactory()); bean.setDataSource(dataSource); &#x2F;&#x2F; 添加XML目录 ResourcePatternResolver resolver &#x3D; new PathMatchingResourcePatternResolver(); try &#123; bean.setMapperLocations(resolver.getResources(&quot;classpath*:com&#x2F;ultrapower&#x2F;ioss&#x2F;**&#x2F;mapper&#x2F;**&#x2F;*.xml&quot;)); return bean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125;&#125;@Bean(&quot;sqlSessionTemplate&quot;)@ConditionalOnBean(name &#x3D; &quot;sqlSessionFactory&quot;)public SqlSessionTemplate sqlSessionTemplate( @Qualifier(&quot;sqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory);&#125;@ConditionalOnBean(name &#x3D; &quot;dataSource&quot;)@Bean(name &#x3D; &quot;transactionManager&quot;)public PlatformTransactionManager transactionManager(@Qualifier(&quot;dataSource&quot;) DataSource dataSource) &#123; DataSourceTransactionManager dataSourceTransactionManager &#x3D; new DataSourceTransactionManager(dataSource); return dataSourceTransactionManager;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.lida1024.top/tags/MyBatis/"}]},{"title":"什么是Java中的魔法值？","slug":"什么是Java中的魔法值？","date":"2020-01-20T00:40:00.000Z","updated":"2020-04-11T00:50:15.794Z","comments":true,"path":"2020/01/20/什么是Java中的魔法值？/","link":"","permalink":"http://www.lida1024.top/2020/01/20/%E4%BB%80%E4%B9%88%E6%98%AFJava%E4%B8%AD%E7%9A%84%E9%AD%94%E6%B3%95%E5%80%BC%EF%BC%9F/","excerpt":"","text":"使用IDEA时，启用了阿里的代码规范检查，其中就有一项提示是不允许任何魔法值出现在代码里，于是出于好奇就了解一下到底啥时魔法值。 介绍魔法数值、魔法数字、魔法值，这是一个东西，不同的叫法。所谓魔法值，是指在代码中直接出现的数值，只有在这个数值记述的那部分代码中才能明确了解其含义。 看一段代码 1234567891011121314151617181920&#x2F;** * 获取当前周所有的日期 * * @return *&#x2F; public static List&lt;String&gt; getRangeDayOfWeek() &#123; List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 日期格式转换 SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); &#x2F;&#x2F; 时间调整到本周一 Calendar instance &#x3D; Calendar.getInstance(); instance.set(instance.get(Calendar.YEAR), instance.get(Calendar.MONDAY), instance.get(Calendar.DAY_OF_MONTH), 0, 0, 0); instance.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); &#x2F;&#x2F;循环打印 for (int i &#x3D; 1; i &lt;&#x3D; 7; i++) &#123; list.add(sdf.format(instance.getTime())); instance.add(Calendar.DAY_OF_WEEK, 1); &#125; return list; &#125; 解决使用static final 定义常量或使用enum值 1static final int WEEK_DAYS&#x3D; 7; 注：使用static final 声明常量，可以方便以后维护更新。修改变量的值时只用修改一处，还不用担心修改了其他不该修改的常量。 总结魔法值的问题对于代码逻辑来说，并不是什么要命的事情，即使不修改也基本不影响代码的正常运行，我以前没有安装阿里代码检查规范时，一样这么使用，也没出现过啥问题。好吧，应该说但是了。但是，遵循公认的代码规范，可以有效的避免开发过程的一些小问题（最让人头疼的往往都是一些小问题引起的），提升开发的效率和代码的可阅读性，老老实实按照规范来，自然就会受益良多，继续加油！","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://www.lida1024.top/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"如何写出让同事无法维护的代码？","slug":"如何写出让同事无法维护的代码？","date":"2020-01-20T00:20:00.000Z","updated":"2020-04-10T03:52:15.885Z","comments":true,"path":"2020/01/20/如何写出让同事无法维护的代码？/","link":"","permalink":"http://www.lida1024.top/2020/01/20/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E8%AE%A9%E5%90%8C%E4%BA%8B%E6%97%A0%E6%B3%95%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F/","excerpt":"","text":"原文：http://mindprod.com/jgloss/unmain.html译文：http://coolshell.cn/articles/4758.html对，你没看错，本文就是教你怎么写出让同事无法维护的代码。 程序命名容易输入的变量名比如：Fred，asdf 单字母的变量名比如：a，b，c，x，y，z（如果不够用，可以考虑 a1，a2，a3，a4，….） 有创意地拼写错误比如：SetPintleOpening， SetPintalClosing，这样可以让人很难搜索代码。 抽象比如：ProcessData，DoIt，GetData… 抽象到就跟什么都没说一样。 缩写比如：WTF，RTFSC …… （使用拼音缩写也同样给力，比如： BT，TMD，TJJTDS） 随机大写字母比如：gEtnuMbER.. 重用命名在内嵌的语句块中使用相同的变量名有奇效。 使用重音字母比如：int ínt（第二个 ínt 不是 int ） 使用下划线比如：_， ， _。 使用不同的语言比如混用英语，德语，或是中文拼音。 使用字符命名比如：slash, asterix, comma… 使用无关的单词比如：god, superman, iloveu…. 混淆l和1字母 l 和数字 1 有时候是看不出来的。 伪装欺诈把注释和代码交织在一起 1for(j&#x3D;0; j&lt;array_len; j+ &#x3D;8)&#123; total +&#x3D; array[j+0 ]; total +&#x3D; array[j+1 ]; total +&#x3D; array[j+2 ]; &#x2F;* Main body of total +&#x3D; array[j+3]; * loop is unrolled total +&#x3D; array[j+4]; * for greater speed. total +&#x3D; array[j+5]; *&#x2F; total +&#x3D; array[j+6 ]; total +&#x3D; array[j+7 ];&#125; 代码和显示不一致比如，你的界面显示叫 postal code，但是代码里确叫 zipcode。 隐藏全局变量把使用全局变量以函数参数的方式传递给函数，这样可以让人觉得那个变量不是全局变量。 使用相似的变量名如：单词相似，swimmer 和 swimner，字母相似：ilI1| 或 oO08，parselnt 和 parseInt， D0Calc 和 DOCalc，还有这一组：xy_Z, xy__z, _xy_z, _xyz, XY_Z, xY_z, Xy_z。 重载函数使用相同的函数名，但是其功能和具体实现完全没有关系。 操作符重载重载操作符可以让你的代码变得诡异，感谢 CCTV，感谢 C++，这个东西是可以把混乱代码提高到一种艺术的形式。比如：重载一个类的 ! 操作符，但实际功能并不是取反，让其返回一个整数。于是，如果你使用 ! ! 操作符，那么，有意思的事就发生了—— 先是调用类的重载 ! 操作符，然后把其返回的整数给 ! 成了 布尔变量，如果是 !!! 呢？呵呵。 文档和注释在注释中撒谎你不用真的去撒谎，只需在改代码的时候不要更新注释就可以了。 注释里面写废话比如：/* add 1 to i */ 只注释是什么，而不是为什么。 不要注释秘密如果你开发一个航班系统，请你一定要保证每有一个新的航班被加入，就得要修改 25 个以上的位置的程序。千万别把这个事写在文档中。 注重细节当你设计一个很复杂的算法的时候，你一定要把所有的详细细设计都写下来，没有 100 页不能罢休，段落要有5级以上，段落编号要有 500 个以上。 例如：1.2.4.6.3.13 – Display all impacts for activity where selected mitigations can apply (short pseudocode omitted).。 这样，当你写代码的时候，你就可以让你的代码和文档一致，如：Act1_2_4_6_3_13() 千万不要注释度衡单位。 比如时间用的是秒还是毫秒，尺寸用的是像素还是英寸，大小是 MB 还是 KB 等等。另外，在你的代码里，你可以混用不同的度衡单位，但也不要注释。 Gotchas陷阱千万不要注释代码中的陷阱。 在注释和文档中发泄不满。 程序设计Java CastsJava 的类型转型是天赐之物，每一次当你从 Collectio n里取到一个 object 的时候，你都需要把其转回原来的类型。 因些，这些转型操作会出现在 N 多的地方。 如果你改变了类型，那么你不一定能改变所有的地方。而编译器可能能检查到，也可能检查不到。 利用 Java 的冗余比如：Bubblegum b = new Bubblegom(); 和 swimmer = swimner + 1; 注意变量间的细微差别。 从不验证从不验证输入的数据，从不验证函数的返回值。这样做可以向大家展示你是多么的信任公司的设备和其它程序员 不要封装调用者需要知道被调用的所有的细节。 克隆和拷贝为了效率，你要学会使用 copy + past，你几乎都不用理解别人的代码，你就可以高效地编程了。 巨大的listener写一个 listener，然后让你的所有的 button 类都使用这个 listener，这样你可以在这个 listener 中整出一大堆 if…else… 语句，相当的刺激。 使用三维数组如果你觉得三维还不足够，你可以试试四维。 混用同时使用类的 get/set 方法和直接访问那个 public 变量，这样做的好处是可以极大的挫败维护人员。 包装包装，包装。把你所有的 API 都包装上 6 到 8 遍，包装深度多达 4层以上，然后包装出相似的功能。 没有秘密把所有的成员都声明成 public 的，这样，你以后就很难限制其被人使用，而且这样可以和别的代码造成更多的耦合度，可以让你的代码存活得更久。 排列和阻碍把drawRectangle(height, width) 改成 drawRectangle(width, height)，等 release 了几个版本后，再把其改回去，这样维护程序的程序员们很快就不明白哪一个是对的。 把变量改在名字上例如，把 setAlignment(int alignment) 改成，setLeftAlignment，setRightAlignment，setCenterAlignment。 保留你所有的没有使用的和陈旧的变量，方法和代码。 Final 你所有的子结点的类这样，当你做完这个项目后，没有人可以通过继承来扩展你的类。java.lang.String 不也是这样吗？ 避免使用 layout这样就使得我们只能使用绝对坐标，如果你的老大强制你使用 layout，你可以考虑使用 GridBagLayout，然后把 grid 坐标 hard code。 环境变量如果你的代码需要使用环境变量，那么，你应该把你的类的成员的初始化使用环境变量，而不是构造函数。 使用全局变量1）把全局变量的初始化放在不同的函数中，就算这个函数和这个变量没有任何关系，这样能够让我们的维护人员就像做侦探工作一样。2）使用全局变量可以让你的函数的参数变得少一些。 配置文件配置文件主要用于一些参数的初始化，在编程中，我们可以让配置文件中的参数名和实际程序中的名字不一样。 膨胀你的类让你的类尽可能地拥有各种臃肿和晦涩的方法，比如，你的类只实现一种可能性，但是你要提供所有可能性的方法。不要定义其它的类，把所有的功能都放在一个类中。 使用子类面向对象是写出无法维护代码的天赐之物，如果你有一个类有十个成为（变量和方法）你可以考虑写 10 个层次的继承，然后把这十个属性分别放在这十个层次中。如果可能的话，把这十个类分别放在十个不同的文件中。 混乱你的代码使用 XML，XML 的强大是无人能及的，使用 XML 你可以把本来只要 10 行的代码变成 100 行。而且，还要逼着别人也有 XML。（参看，信 XML 得永生，信 XML 得自信） 分解条件表达式如：把 a==100 分解成，a&gt;99 &amp;&amp; a&lt;101 学会利用分号如：if ( a );else;{ int d; d = c;} 间接转型如：把 double 转 string，写成 new Double(d).toString() 而不是 Double.toString(d) 大量使用嵌套一个 NB 的程序员可以在一行代码上使用超过 10 层的小括号（），或是在一个函数里使用超过 20 层的语句嵌套{}，把嵌套的 if else 转成 [? :] 也是一件很 NB 的事。 长代码行一行的代码越长越好，这样别人阅读时就需要来来回回的。 不要过早的return不要使用 break，这样，你就需要至少 5 层以上的 if-else 来处理错误。 不要使用{}不要在 if else 使用{}，尤其是在你重量地使用 if-else 嵌套时，你甚至可以在其中乱缩进代码，这样一来，就算是最有经验的程序员也会踩上陷阱。 琐碎的封装比较封装一个 bool 类，类里面什么都做，就是一个 bool。 循环千万不可用 for(int i=0; i&lt;n; i++) 使用 while 代替 for，交换 n 和 i，把 &lt; 改成 &lt;=，使用 i– 调整步伐 。 测试从不测试千万不要测试任何的出错处理，从来也不检测系统调用的返回值。 永远不做性能测试如果不够快就告诉用户换一个更快的机器。如果你一做测试，那么就可能会要改你的算法，甚至重设计，重新架构。 不要写测试案例不要做什么代码覆盖率测试，自动化测试。 测试是懦夫行为一个勇敢的程序员是根本不需要这一步的，太多的程序太害怕他们的老板，害怕失去工作，害怕用户抱怨，甚至被起诉，这种担心害怕直接影响了生产力。 如果你对你的代码有强大的信心，那还要什么测试呢？真正的程序员是不需要测试自己的代码的。 其他你的老板什么都知道无论你的老板有多 SB，你都要严格地遵照他的旨意办事，这样一来，你会学到更多的知识以及如何写出更加无法维护的代码。 颠覆Help Desk你要确保你那满是 bug 的程序永远不要被维护团队知道。当用户打电话和写邮件给你的时候，你就不要理会，就算要理会，让用户重做系统或是告诉用户其帐号有问题，是标准的回答。 闭嘴对于一些像 y2k 这样的大 bug，你要学会守口如瓶，不要告诉任何人，包括你的亲人好友以及公司的同事和管理层，这样当到那一天的时候，你就可以用这个 bug 挣钱了。 忽悠你会学会忽悠，就算你的代码写得很烂，你也要为其挂上 GoF 设计模式的标签，就算你的项目做得再烂，你也要为其挂上敏捷的标签，让整个团队和公司，甚至整个业界都开始躁动，这样才能真正为难维护的代码铺平道路。 最后总之，我们的口号是—— Write Everywhere, Read Nowhere","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://www.lida1024.top/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"使用 Travis CI 自动更新 GitHub Pages","slug":"使用-Travis-CI-自动更新-GitHub-Pages","date":"2020-01-15T03:26:00.000Z","updated":"2020-04-10T03:51:45.922Z","comments":true,"path":"2020/01/15/使用-Travis-CI-自动更新-GitHub-Pages/","link":"","permalink":"http://www.lida1024.top/2020/01/15/%E4%BD%BF%E7%94%A8-Travis-CI-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-GitHub-Pages/","excerpt":"","text":"前言Github Pages 不能运行动态程序，只能输出一些静态内容。因此 Github Pages 非常适合用于前端项目的展示。可用于存放项目介绍、项目文档或者个人博客。本文介绍了怎么用 Travis CI 自动化部署 Github Pages。 CI持续集成（Continuous integration）是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。目前 github 开源项目用的较多的 CI 主要是 Circle CI 和 Travis CI，两者都是利用容器技术来适配不同项目环境。 GitHub Pageshexo虽然可以方便地部署github静态博客，但是仅仅是把最终生成的html保存在repository中，像原始的Markdown文件，hexo配置文件，主题配置文件，修改文件都仅仅是保存在本地。这样不利于保存，也无法查看每篇博客的修改历史。在github上搭blog最大的问题就是，每次提交都需要先hexo g，然后再hexo d生成文件，这样哪怕是改一个小的地方都需要重新编译全部blog。 Travis CI &amp; GitHub Pages以我的博客为例coder-lida.github.io:博客静态文件仓库blog-source:文档源码仓库文档源码放置在blog-source仓库，最终部署文件在 coder-lida.github.io仓库。当在 blog-source仓库更改某些内容之后，通过运行 hexo g来生成最终部署的 HTML 文件到 public 目录，随后再进入 public 目录初始化 git 仓库、添加文件、提交文件，最后将提交强制推送到远程coder-lida.github.io仓库。 Start Travis CI.travis.ymlHexo官网配置,官方配置是在同一个仓库的不同分支来实现的。我没用这种方式，而是创建了2个仓库，一个放部署的网页，另一个放blog的源文件，包括post和themes。 注册并设置Travis CITravis CI官网点击右上角使用Github登录的按钮登录成功后选中博客的源文件仓库，点击Setting 关于GH_TOKEN登录到GitHub，点击右上角头像框，选择Settings选择Developer settings添加一个token填写token description，比如叫hexo deploy.勾选上授予的权限，比如我勾选的是repo和gist，然后create.将产生的token串复制保留下来，后面会使用到,如果丢失，只能重新产生。 将生成的token设置到Travis CI作为环境变量。 到此Travis CI设置完成。 添加 .travis.yml先贴出我的配置 12345678910111213141516171819202122232425262728293031323334language: node_js #设置语言node_js: stable # nodejs版本branches: only: - master #只监测master分支cache: apt: true directories: - node_modules # 缓存不经常更改的内容before_install: - git config --global user.name &quot;your name&quot; # github用户名 - git config --global user.email &quot;your email&quot; # 邮箱 - npm install -g hexo-cliinstall: - npm ibefore_script:# 无其他依赖项所以执行npm run build 构建就行了script: - hexo clean #清除 - hexo generate #生成after_script: - git clone https:&#x2F;&#x2F;$&#123;GH_REF&#125; .deploy_git # GH_REF是最下面配置的仓库地址 - cd .deploy_git - git checkout master - cd ..&#x2F; - mv .deploy_git&#x2F;.git&#x2F; .&#x2F;public&#x2F; # 这一步之前的操作是为了保留master分支的提交记录，不然每次git init的话只有1条commit - cd .&#x2F;public - git init - git add . - git commit -m &quot;Travis CI Auto Builder at &#96;date +&quot;%Y-%m-%d %H:%M&quot;&#96;&quot; # 提交记录包含时间 - git push --force --quiet &quot;https:&#x2F;&#x2F;$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master #GH_TOKEN是在Travis中配置环境变量的名称env: global: - GH_REF: github.com&#x2F;coder-lida&#x2F;coder-lida.github.io.git #设置GH_REF,换成自己用户名和仓库名 哪些文件需要提交到源文件的仓库 package-lock.json文件在.gitignore文件中加上 在经历的11次失败之后，第12次终于成功了。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://www.lida1024.top/categories/Dev/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.lida1024.top/tags/Hexo/"}]},{"title":"Java中的clone","slug":"Java中的clone","date":"2020-01-12T23:56:00.000Z","updated":"2020-04-11T00:49:39.192Z","comments":true,"path":"2020/01/13/Java中的clone/","link":"","permalink":"http://www.lida1024.top/2020/01/13/Java%E4%B8%AD%E7%9A%84clone/","excerpt":"","text":"Java中对象的创建 使用new操作符创建一个对象 使用clone方法复制一个对象两种方式的异同new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。而clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部 。Java中的Cloneclone 顾名思义就是 复制 ， 在Java语言中， clone方法被对象调用，所以会复制对象。所谓的复制对象，首先要分配一个和源对象同样大小的空间，在这个空间中创建一个新的对象复制对象 or 复制引用1234Person p &#x3D; new Person(23, &quot;张三&quot;); Person p1 &#x3D; p;System.out.println(p); System.out.println(p1); 打印结果：12com.pansoft.zhangjg.testclone.Person@2f9ee1accom.pansoft.zhangjg.testclone.Person@2f9ee1ac 可以看出，打印的地址值是相同的，既然地址都是相同的，那么肯定是同一个对象。p和p1只是引用而已，他们都指向了一个相同的对象Person(23, “张三”) 。 可以把这种现象叫做 引用的复制而下面的代码是真真正正的克隆了一个对象：1234Person p &#x3D; new Person(23, &quot;张三&quot;); Person p1 &#x3D; (Person) p.clone(); System.out.println(p); System.out.println(p1); 打印结果:12com.pansoft.zhangjg.testclone.Person@2f9ee1accom.pansoft.zhangjg.testclone.Person@67f1fba0 深拷贝 or 浅拷贝上面的示例代码中，Person中有两个成员变量，分别是name和age， name是String类型， age是int类型。代码非常简单，如下所示：12345678910111213141516171819public class Person implements Cloneable&#123; private int age ; private String name; public Person(int age, String name) &#123; this.age &#x3D; age; this.name &#x3D; name; &#125; public Person() &#123;&#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; @Override protected Object clone() throws CloneNotSupportedException&#123; return (Person)super.clone(); &#125;&#125; 由于age是基本数据类型， 那么对它的拷贝没有什么疑议，直接将一个4字节的整数值拷贝过来就行。但是name是String类型的， 它只是一个引用， 指向一个真正的String对象，那么对它的拷贝有两种方式： ①直接将源对象中的name的引用值拷贝给新对象的name字段； ②根据原Person对象中的name指向的字符串对象创建一个新的相同的字符串对象，将这个新字符串对象的引用赋给新拷贝的Person对象的name字段。 这两种拷贝方式分别叫做 浅拷贝 和 深拷贝 。 深拷贝和浅拷贝的原理如下图所示： clone是浅拷贝还是深拷贝如果两个Person对象的name的地址值相同， 说明两个对象的name都指向同一个String对象， 也就是浅拷贝， 而如果两个对象的name的地址值不同， 那么就说明指向不同的String对象， 也就是在拷贝Person对象的时候， 同时拷贝了name引用的String对象， 也就是深拷贝。验证代码如下： 1234Person p &#x3D; new Person(23,&quot;张三&quot;);Person p1 &#x3D;(Person)p.clone();String result &#x3D; p.getName() &#x3D;&#x3D; p1.getName() ? &quot;clone是浅拷贝的&quot;:&quot;clone是深拷贝的&quot;; 打印结果: 1clone是浅拷贝的","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://www.lida1024.top/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"微信小程序版本自动更新","slug":"微信小程序版本自动更新","date":"2020-01-07T09:24:00.000Z","updated":"2020-04-10T03:41:27.898Z","comments":true,"path":"2020/01/07/微信小程序版本自动更新/","link":"","permalink":"http://www.lida1024.top/2020/01/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%89%88%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/","excerpt":"","text":"公司的小程序项目上线, 后期还会有小型的版本迭代. 为了让用户能在我们进行版本迭代后及时使用最新版本的功能. 做了以下优化.. 小程序的销毁当用户点击左上角关闭，或者按了设备Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台，只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。 “冷启动” 和 “热启动”.热启动是指: 小程序打开后，在一段时间内（目前：5分钟）再次被打开，此时会将后台的小程序切换到前台。冷启动是指: 小程序首次打开或销毁后再次被打开. 更新版本冷启动时, 如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。如果要马上应用最新版本，使用 wx.getUpdateManager API 进行处理。 代码如下 12345678910111213141516171819202122232425262728293031323334&#x2F; 在app.js里写下以下代码 onLaunch () &#123; if (wx.canIUse(&#39;getUpdateManager&#39;)) &#123; const updateManager &#x3D; wx.getUpdateManager() updateManager.onCheckForUpdate(function (res) &#123; console.log(&#39;onCheckForUpdate&#x3D;&#x3D;&#x3D;&#x3D;&#39;, res) &#x2F;&#x2F; 请求完新版本信息的回调 if (res.hasUpdate) &#123; console.log(&#39;res.hasUpdate&#x3D;&#x3D;&#x3D;&#x3D;&#39;) updateManager.onUpdateReady(function () &#123; wx.showModal(&#123; title: &#39;更新提示&#39;, content: &#39;新版本已经准备好，是否重启应用？&#39;, success: function (res) &#123; console.log(&#39;success&#x3D;&#x3D;&#x3D;&#x3D;&#39;, res) &#x2F;&#x2F; res: &#123;errMsg: &quot;showModal: ok&quot;, cancel: false, confirm: true&#125; if (res.confirm) &#123; &#x2F;&#x2F; 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123; &#x2F;&#x2F; 新的版本下载失败 wx.showModal(&#123; title: &#39;已经有新版本了哟~&#39;, content: &#39;新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~&#39; &#125;) &#125;) &#125; &#125;) &#125; &#125; 小程序重新初始化时会触发onLaunch事件onLaunch事件会触发在页面onShow事件之前.获取小程序更新版本可以写在onLaunch里. 注意：在开发和体验版无法测试版本更新 需要在开发者工具里,编译时选择”模拟更新编译” (部分开发者工具版本, 每次update编译时都需要重新勾选此选项)点击确定,重新编译.页面会弹窗显示:点击确定后： 随着小程序的不断更新, 部分功能可能需要最新版的微信客户端才能使用. 这时候可以弹窗提示用户更新到最新版本微信 12345678 if (wx.canIUse(&#39;getUpdateManager&#39;)) &#123; ...&#125; else &#123; &#x2F;&#x2F; can&#39;t use getUpdateManager wx.showModal(&#123; title: &#39;提示&#39;, content: &#39;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&#39; &#125;) 完整版本: 12345678910111213141516171819202122232425262728293031onLaunch () &#123; if (wx.canIUse(&#39;getUpdateManager&#39;)) &#123; const updateManager &#x3D; wx.getUpdateManager() updateManager.onCheckForUpdate(function (res) &#123; if (res.hasUpdate) &#123; updateManager.onUpdateReady(function () &#123; wx.showModal(&#123; title: &#39;更新提示&#39;, content: &#39;新版本已经准备好，是否重启应用？&#39;, success: function (res) &#123; if (res.confirm) &#123; updateManager.applyUpdate() &#125; &#125; &#125;) &#125;) updateManager.onUpdateFailed(function () &#123; wx.showModal(&#123; title: &#39;已经有新版本了哟~&#39;, content: &#39;新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~&#39; &#125;) &#125;) &#125; &#125;) &#125; else &#123; wx.showModal(&#123; title: &#39;提示&#39;, content: &#39;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&#39; &#125;) &#125; &#125; 如果在onLaunch里进行请求, 这是异步请求. 如果对交互顺序有要求, 如: 版本更新–重新获取数据– 用户展示, 那么需要考虑在callback里进行重获数据.小程序启动时，正常是会热更新，下载新版本的包，下一次启动就会使用新包。但发现有更新不成功的情况发生.官方回答: 策略生效跟网络环境以及发布时间等若干因素有关，会尽可能让小程序快地更新，但无法保证每次都热更新成功。小程序的异步更新发生在冷启动过程. 官方不建议热更新. 原因:","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Weixin","slug":"Dev/Weixin","permalink":"http://www.lida1024.top/categories/Dev/Weixin/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.lida1024.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Double为什么会失真？","slug":"Double为什么会失真？","date":"2020-01-07T05:43:00.000Z","updated":"2020-04-11T00:27:42.925Z","comments":true,"path":"2020/01/07/Double为什么会失真？/","link":"","permalink":"http://www.lida1024.top/2020/01/07/Double%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%A4%B1%E7%9C%9F%EF%BC%9F/","excerpt":"","text":"前言先来看一个double失真的例子 12345678910public class DoubleTest &#123; public static void main(String[] args) &#123; for (double i &#x3D; 0; i &lt; 1; i &#x3D; (i * 10 + 1) &#x2F; 10) &#123; for (double k &#x3D; 0; k &lt; i; k &#x3D; (k * 10 + 1) &#x2F; 10) &#123; System.out.println(i + &quot;-&quot; + k + &quot;&#x3D;&quot; + (i - k)); &#125; &#125; &#125;&#125; 输出： 0.1-0.0=0.10.2-0.0=0.20.2-0.1=0.10.3-0.0=0.30.3-0.1=0.199999999999999980.3-0.2=0.099999999999999980.4-0.0=0.40.4-0.1=0.300000000000000040.4-0.2=0.20.4-0.3=0.100000000000000030.5-0.0=0.50.5-0.1=0.40.5-0.2=0.30.5-0.3=0.20.5-0.4=0.099999999999999980.6-0.0=0.60.6-0.1=0.50.6-0.2=0.399999999999999970.6-0.3=0.30.6-0.4=0.199999999999999960.6-0.5=0.099999999999999980.7-0.0=0.70.7-0.1=0.60.7-0.2=0.499999999999999940.7-0.3=0.399999999999999970.7-0.4=0.299999999999999930.7-0.5=0.199999999999999960.7-0.6=0.099999999999999980.8-0.0=0.80.8-0.1=0.70000000000000010.8-0.2=0.60000000000000010.8-0.3=0.50.8-0.4=0.40.8-0.5=0.300000000000000040.8-0.6=0.200000000000000070.8-0.7=0.100000000000000090.9-0.0=0.90.9-0.1=0.80.9-0.2=0.70.9-0.3=0.60000000000000010.9-0.4=0.50.9-0.5=0.40.9-0.6=0.300000000000000040.9-0.7=0.200000000000000070.9-0.8=0.09999999999999998 一、 什么是浮点数？1、小数一个小数的组成：在我国，小数表示由三部分组成，分别是整数+小数点（分隔符）+小数。 2、小数为什么会被称为浮点数浮点数是属于有理数中某特定子集的数的数字表示，在计算机中用以近似表示任意某个实数。具体的说，这个实数由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到，这种表示方法类似于基数为10的科学计数法。 对于浮点数可以这样简单的理解：浮点数就是小数点可以任意浮动的数字。 在计算机的机器语言中，只有二进制，机器语言只能识别0和1。所以，计算机也是不可能存储小数的，所以需要有另一种变通的存储方案。这种方案就是指数方案：通过观察以上的图片不难发现，作为一个小数3.14。如果使用指数表现形式的话（3.14E0），其写法是多种多样的，这样写的话，小数点就可以任意浮动了。 3、Java中浮点数的表示方法对于float来说，4个字节，32位，0-22位表示尾数，23-30(8位)表示指数，31位表示符号位。 对于double来说，8个字节，64位，0-51表示尾数，52-62(11位)表示指数，63位最高位表示符号位。 二、浮点数在内存中是如何存储的？我们知道，任何数据在计算机内存中都是用‘0\\1’来存储的，浮点数亦是如此。因此十进制浮点数在存储时必定会转换为二进制的浮点数。 在内存中使用二进制的科学计数法来存储，因此分为阶码（即指数）和底数，由于也有正负之分，所以还有一位符号位。以float为例，float在内存中的存储为：float 符号位(1bit) 指数(8 bit) 尾数(23 bit) double 符号位(1bit) 指数(11 bit) 尾数(52 bit) float在内存中占8位，由于阶码实际存储的是指数的移码，假设指数的真值是e,阶码为E，则有E=e+(2^n-1 -1)。其中 2^n-1 -1是IEEE754标准规定的指数偏移量，根据这个公式我们可以得到 2^8 -1=127。于是，float的指数范围为-128 +127，而double的指数范围为-1024 +1023。其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。 float的范围为-2^128 ~ +2^127，也即-3.40E+38 ~ +3.40E+38； double的范围为-2^1024 ~ +2^1023，也即-1.79E+308 ~ +1.79E+308 这里使用移位存储，对于float来说，指数位加上127，double位加上1023(这里指的是存储，在比较的时候要分别减去127和1023) 移位存储本质上是为了保证+0和-0的一致性。 以float指数部分的这8位来分析， 那么这8位组成的新的字节，我们来用下面的一串数字表示：0000 0000 首先，我们假设不使用移位存储技术，而是单单看看这个 8位组成的新字节，到底能表示多少个数： 0000 0000 -1111 1111 即0-255，一共256个数。 但是我们知道这8位数既要表示正数也要表示负数。 所以将左边第一位拿出来表示正负的符号： 第一个区间： 0 000 0000 - 0 111 1111即+0 到127 第二个区间： 1 000 0000 - 1 111 1111即 -0到-127 这就是问题的所在:怎么会有两个0，一个正零，一个负零。 这时候使用移位存储：float使用127(0111 1111) 表示0：0+127=127 即 0000 0000 +0111 1111=0111 1111表示1：1+127=128 即 0000 0001 +0111 1111=1000 0000表示128：128+127=255 即 1000 0000+0111 1111=1111 1111 最大的正数，再大就要溢出了。 表示-1： -1+127=126=127-1 即 0111 1111-0000 0001=0111 1110表示-1： -2+127=125=127-2 即 0111 1111-0000 0010=0111 1101表示-127： -127+127=0 即0111 1111-0111 1111=0000 0000 最小的负数，在校就溢出了。 三、浮点数的进制转换1、十进制转二进制主要看看十进制转二进制，整数部分和小数部分分开处理 整数部分：整数除以2，得到一个商和余数，得到的商继续除以2并得到一个商和一个余数，继续除以2操作直至商为0，上述操作得到一系列余数，从最后一个余数开始直至第一个余数，这一系列0\\1即为转换后的二进制数。 小数部分：乘以2，然后取出整数部分，将剩下的小数部分继续乘以2，然后再取整数部分，一直取到小数部分为零为止。如果永远不为零，则按要求保留足够位数的小数，最后一位做0舍1入。将取出的整数顺序排列。 从以上转换过程可以看出，并不是任何一个十进制小数都可以用二进制精确表示出来。一个在0到1之间的小数P可用如下形式表示：从这个式子中我们也可看出二进制表示出的小数是分段的，这也是为什么在Java中浮点数很多时候并不是十分精确的表示十进制小数的根本原因。 12345678910111213public static void main(String[] args) &#123; float f1&#x3D;20f; float f2&#x3D;20.3f; float f3&#x3D;20.5f; double d1&#x3D;20; double d2&#x3D;20.3; double d3&#x3D;20.5; System.out.println(f1&#x3D;&#x3D;d1); System.out.println(f2&#x3D;&#x3D;d2); System.out.println(f3&#x3D;&#x3D;d3);&#125; truefalsetrue 以20.3举例：20转换后变为 101000.3 要转换二进制，需要乘2, 乘完之后 取整数部分，然后用乘的结果减去整数部分， 然后 接着乘2, 直至最后没有小数或者小数出现循环, 即乘完. 0.3 * 2 = 0.6 (0) 0.6 * 2 = 1.2 (1) 0.2 * 2 = 0.4 (0) 0.4 * 2 = 0.8 (0) 0.8 * 2 = 1.6 (1) 计算到这里， 将再出现0.6,进入循环了，所以，结果0.3 = 0.010011001…1001所以20.3 = 10100.010011001…1001 (二进制). 2、二进制的科学记数法表示20.3 = 10100.010011001…1001 (二进制)=1.01000100110011E10…..（十进制科学计数）=1.01000100110011E100…..(二进制科学计数) 这里使用移位存储，对于float来说，指数位加上127，double位加上1023(这里指的是存储，在比较的时候要分别减去127和1023) 同时要注意一点，以float为例，最高位表示的是整个数的符号位，指数位一共8位，最高位表示的是指数位的正负，因为有可能是E-100这样的情况，所以虽然有8位，最高位只是符号位，剩下7位才是表示真正的数值，这也是使用移位存储的原因。 对于一个数字，只要不超过和float的范围，同时小数部分不是无限小数，就可以和对应的double类型相等。 3、浮点数舍入规则以52位尾数的双精度浮点数为例，舍入时需要重点参考第53位。 若第53位为1，而其后的位数都是0，此时就要使第52位为0；若第52位为0则不用再进行其他操作，若第52位为1，则第53位就要向52位进一位。 若第53位为1，但其后的位数不全为0，则第53为就要向第52位进一位。 若不是以上两种情况，也即53位为0，那么就直接舍弃不进位，称为下舍入。 浮点数舍入规则也就证明了为何在上文中提到的浮点数舍入中，相对舍入误差不能大于机器ε的一半。 对于java来说，一般float类型小数点后保留7位，而double类型小数点后保留15位。 这个原因也是因为尾数的数据宽度限制 对于float型来说，因为2^23 = 8388608 同时最左一位默认省略了，故实际能表示2^24 = 16777216个数，最多能表示8位，但绝对精确的只能表示7位。 而对于double型来说，2^52 = 4503599627370496，共16位。加上省略的一位，能表示2^53 = 9007199254740992。故double型最多能表示16位，而绝对精确的只能表示15位。 4、机器ε机器ε表示1与大于1的最小浮点数之差。不同精度定义的机器ε不同。以双精度为例， 双精度表示1是 1.000……0000（52个0） × 2^0 而比1大的最小的双精度是（其实还能表示更小的范围，后文中会提到，但并不影响这里的机器ε） 1.000……0001 × 2^0 也即 2^-52 ≈ 2.220446049250313e-16。所以它就是双精度浮点数的机器ε。 在舍入中，相对舍入误差不能大于机器ε的一半。 对于双精度浮点数来说，这个值为0.00000005960464477539。 所以在Java中double类型中连续8个0.1相乘，就会出现表示不精确的情况。 参考：https://baijiahao.baidu.com/s?id=1618173300159774003&amp;wfr=spider&amp;for=pchttps://www.cnblogs.com/Vicebery/p/9997636.htmlhttps://blog.csdn.net/Return_head/article/details/88623060https://blog.csdn.net/u011277123/article/details/95774544https://blog.csdn.net/endlessseaofcrow/article/details/81269079","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"数据类型","slug":"数据类型","permalink":"http://www.lida1024.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"Java反射","slug":"Java反射","date":"2020-01-05T23:57:00.000Z","updated":"2020-04-11T00:49:56.971Z","comments":true,"path":"2020/01/06/Java反射/","link":"","permalink":"http://www.lida1024.top/2020/01/06/Java%E5%8F%8D%E5%B0%84/","excerpt":"","text":"一、什么是反射？JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 简单的来说：1.通过new关键字创建对象操作对象，在编译时就已经确定。2.通过反射可以在程序运行过程中动态的操作对象，可以获得编译期无法获得的信息，动态操作最大限度发挥了java扩展性。 二、反射原理Java反射的原理:java类的执行需要经历以下过程： 编译：.java文件编译后生成.class字节码文件 加载：类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例 链接验证：格式（class文件规范） 语义（final类是否有子类） 操作准备：静态变量赋初值和内存空间，final修饰的内存空间直接赋原值，此处不是用户指定的初值。解析：符号引用转化为直接引用，分配地址 初始化：有父类先初始化父类，然后初始化自己；将static修饰代码执行一遍，如果是静态变量，则用用户指定值覆盖原有初值；如果是代码块，则执行一遍操作。 Java的反射就是利用上面第二步加载到jvm中的.class文件来进行操作的。.class文件中包含java类的所有信息，当你不知道某个类具体信息时，可以使用反射获取class，然后进行各种操作。 Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。总结说：反射就是把java类中的各种成分映射成一个个的Java对象，并且可以进行操作。 三、反射机制相关与Java反射相关的类如下： 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 反射可访问的常用信息 类型 访问方法 返回值类型 说明 包路径 getPackage() Package 对象 获取该类的存放路径 类名称 getName() String 对象 获取该类的名称 继承类 getSuperclass() Class 对象 获取该类继承的类 实现接口 getlnterfaces() Class 型数组 获取该类实现的所有接口 构造方法 getConstructors() Constructor 型数组 获取所有权限为 public 的构造方法 构造方法 getDeclaredContruectors() Constructor 对象 获取当前对象的所有构造方法 方法 getMethods() Methods 型数组 获取所有权限为 public 的方法 方法 getDeclaredMethods() Methods 对象 获取当前对象的所有方法 成员变量 getFields() Field 型数组 获取所有权限为 public 的成员变量 成员变量 getDeclareFileds() Field 对象 获取当前对象的所有成员变量 内部类 getClasses() Class 型数组 获取所有权限为 public 的内部类 内部类 getDeclaredClasses() Class 型数组 获取所有内部类 内部类的声明类 getDeclaringClass() Class 对象 如果该类为内部类，则返回它的成员类，否则返回 null Java 反射机制主要提供了以下功能，这些功能都位于java.lang.reflect包。 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 生成动态代理。 四、反射的使用1、java中的Class三种获取方式 jdk提供了三种方式获取一个对象的Class，就Person person 来说 1.person .getClass()，这个是Object类里面的方法 2.Person .Class属性，任何的数据类型，基本数据类型或者抽象数据类型，都可以通过这种方式获取类 3.Class.forName(“”)，Class类提供了这样一个方法，让我们通过类名来获取到对象类 说明：在运行期间，如果我们要产生某个类的对象，Java虚拟机(JVM)会检查该类型的Class对象是否已被加载。如果没有被加载，JVM会根据类的名称找到.class文件并加载它。一旦某个类型的Class对象已被加载到内存，就可以用它来产生该类型的所有对象。 12345678910111213&#x2F;&#x2F;方式一Person person &#x3D; new Person();Class&lt;? extends Person&gt; personClazz01 &#x3D; person.getClass(); &#x2F;&#x2F;方式二try &#123; Class&lt;?&gt; personClazz02 &#x3D; Class.forName(&quot;Person&quot;);&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125; &#x2F;&#x2F;方式三Class&lt;? extends Person&gt; personClazz03 &#x3D; Person.class; 2、如何通过反射获取私有成员变量和私有方法Person类 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Person &#123;private String name &#x3D; &quot;zhangsan&quot;;private String age; public String getName() &#123; return name;&#125; public void setName(String name) &#123; this.name &#x3D; name;&#125;&#125; Person person &#x3D; new Person(); &#x2F;&#x2F;打印没有改变属性之前的name值 System.out.println(&quot;before：&quot; + getPrivateValue(person, &quot;name&quot;)); person.setName(&quot;lisi&quot;); &#x2F;&#x2F;打印修改之后的name值 System.out.println(&quot;after：&quot; + getPrivateValue(person, &quot;name&quot;)); &#x2F;** * 通过反射获取私有的成员变量 * * @param person * @return *&#x2F;private Object getPrivateValue(Person person, String fieldName) &#123; try &#123; Field field &#x3D; person.getClass().getDeclaredField(fieldName); &#x2F;&#x2F; 参数值为true，打开禁用访问控制检查 &#x2F;&#x2F;setAccessible(true) 并不是将方法的访问权限改成了public，而是取消java的权限控制检查。 &#x2F;&#x2F;所以即使是public方法，其accessible 属相默认也是false field.setAccessible(true); return field.get(person); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 运行结果 3、demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307package cn.lee.demo; import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.TypeVariable; public class Main &#123; &#x2F;** * 为了看清楚Java反射部分代码，所有异常我都最后抛出来给虚拟机处理！ * @param args * @throws ClassNotFoundException * @throws InstantiationException * @throws IllegalAccessException * @throws InvocationTargetException * @throws IllegalArgumentException * @throws NoSuchFieldException * @throws SecurityException * @throws NoSuchMethodException *&#x2F; public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, SecurityException, NoSuchFieldException, NoSuchMethodException &#123; &#x2F;&#x2F; TODO Auto-generated method stub &#x2F;&#x2F;Demo1. 通过Java反射机制得到类的包名和类名 Demo1(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo2. 验证所有的类都是Class类的实例对象 Demo2(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo3. 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]，无参构造 Demo3(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo4: 通过Java反射机制得到一个类的构造函数，并实现构造带参实例对象 Demo4(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo5: 通过Java反射机制操作成员变量, set 和 get Demo5(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等 Demo6(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo7: 通过Java反射机制调用类中方法 Demo7(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;Demo8: 通过Java反射机制获得类加载器 Demo8(); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125; &#x2F;** * Demo1: 通过Java反射机制得到类的包名和类名 *&#x2F; public static void Demo1() &#123; Person person &#x3D; new Person(); System.out.println(&quot;Demo1: 包名: &quot; + person.getClass().getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + person.getClass().getName()); &#125; &#x2F;** * Demo2: 验证所有的类都是Class类的实例对象 * @throws ClassNotFoundException *&#x2F; public static void Demo2() throws ClassNotFoundException &#123; &#x2F;&#x2F;定义两个类型都未知的Class , 设置初值为null, 看看如何给它们赋值成Person类 Class&lt;?&gt; class1 &#x3D; null; Class&lt;?&gt; class2 &#x3D; null; &#x2F;&#x2F;写法1, 可能抛出 ClassNotFoundException [多用这个写法] class1 &#x3D; Class.forName(&quot;cn.lee.demo.Person&quot;); System.out.println(&quot;Demo2:(写法1) 包名: &quot; + class1.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + class1.getName()); &#x2F;&#x2F;写法2 class2 &#x3D; Person.class; System.out.println(&quot;Demo2:(写法2) 包名: &quot; + class2.getPackage().getName() + &quot;，&quot; + &quot;完整类名: &quot; + class2.getName()); &#125; &#x2F;** * Demo3: 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在] * @throws ClassNotFoundException * @throws IllegalAccessException * @throws InstantiationException *&#x2F; public static void Demo3() throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; class1 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.Person&quot;); &#x2F;&#x2F;由于这里不能带参数，所以你要实例化的这个类Person，一定要有无参构造函数哈～ Person person &#x3D; (Person) class1.newInstance(); person.setAge(20); person.setName(&quot;LeeFeng&quot;); System.out.println(&quot;Demo3: &quot; + person.getName() + &quot; : &quot; + person.getAge()); &#125; &#x2F;** * Demo4: 通过Java反射机制得到一个类的构造函数，并实现创建带参实例对象 * @throws ClassNotFoundException * @throws InvocationTargetException * @throws IllegalAccessException * @throws InstantiationException * @throws IllegalArgumentException *&#x2F; public static void Demo4() throws ClassNotFoundException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; Class&lt;?&gt; class1 &#x3D; null; Person person1 &#x3D; null; Person person2 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.Person&quot;); &#x2F;&#x2F;得到一系列构造函数集合 Constructor&lt;?&gt;[] constructors &#x3D; class1.getConstructors(); person1 &#x3D; (Person) constructors[0].newInstance(); person1.setAge(30); person1.setName(&quot;leeFeng&quot;); person2 &#x3D; (Person) constructors[1].newInstance(20,&quot;leeFeng&quot;); System.out.println(&quot;Demo4: &quot; + person1.getName() + &quot; : &quot; + person1.getAge() + &quot; , &quot; + person2.getName() + &quot; : &quot; + person2.getAge() ); &#125; &#x2F;** * Demo5: 通过Java反射机制操作成员变量, set 和 get * * @throws IllegalAccessException * @throws IllegalArgumentException * @throws NoSuchFieldException * @throws SecurityException * @throws InstantiationException * @throws ClassNotFoundException *&#x2F; public static void Demo5() throws IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException, InstantiationException, ClassNotFoundException &#123; Class&lt;?&gt; class1 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.Person&quot;); Object obj &#x3D; class1.newInstance(); Field personNameField &#x3D; class1.getDeclaredField(&quot;name&quot;); personNameField.setAccessible(true); personNameField.set(obj, &quot;胖虎先森&quot;); System.out.println(&quot;Demo5: 修改属性之后得到属性变量的值：&quot; + personNameField.get(obj)); &#125; &#x2F;** * Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等 * @throws ClassNotFoundException *&#x2F; public static void Demo6() throws ClassNotFoundException &#123; Class&lt;?&gt; class1 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.SuperMan&quot;); &#x2F;&#x2F;取得父类名称 Class&lt;?&gt; superClass &#x3D; class1.getSuperclass(); System.out.println(&quot;Demo6: SuperMan类的父类名: &quot; + superClass.getName()); System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); Field[] fields &#x3D; class1.getDeclaredFields(); for (int i &#x3D; 0; i &lt; fields.length; i++) &#123; System.out.println(&quot;类中的成员: &quot; + fields[i]); &#125; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;取得类方法 Method[] methods &#x3D; class1.getDeclaredMethods(); for (int i &#x3D; 0; i &lt; methods.length; i++) &#123; System.out.println(&quot;Demo6,取得SuperMan类的方法：&quot;); System.out.println(&quot;函数名：&quot; + methods[i].getName()); System.out.println(&quot;函数返回类型：&quot; + methods[i].getReturnType()); System.out.println(&quot;函数访问修饰符：&quot; + Modifier.toString(methods[i].getModifiers())); System.out.println(&quot;函数代码写法： &quot; + methods[i]); &#125; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#x2F;&#x2F;取得类实现的接口,因为接口类也属于Class,所以得到接口中的方法也是一样的方法得到哈 Class&lt;?&gt; interfaces[] &#x3D; class1.getInterfaces(); for (int i &#x3D; 0; i &lt; interfaces.length; i++) &#123; System.out.println(&quot;实现的接口类名: &quot; + interfaces[i].getName() ); &#125; &#125; &#x2F;** * Demo7: 通过Java反射机制调用类方法 * @throws ClassNotFoundException * @throws NoSuchMethodException * @throws SecurityException * @throws InvocationTargetException * @throws IllegalAccessException * @throws IllegalArgumentException * @throws InstantiationException *&#x2F; public static void Demo7() throws ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Class&lt;?&gt; class1 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.SuperMan&quot;); System.out.println(&quot;Demo7: \\n调用无参方法fly()：&quot;); Method method &#x3D; class1.getMethod(&quot;fly&quot;); method.invoke(class1.newInstance()); System.out.println(&quot;调用有参方法walk(int m)：&quot;); method &#x3D; class1.getMethod(&quot;walk&quot;,int.class); method.invoke(class1.newInstance(),100); &#125; &#x2F;** * Demo8: 通过Java反射机制得到类加载器信息 * * 在java中有三种类类加载器。[这段资料网上截取] 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\\lib\\ext目录中的类 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。 * * @throws ClassNotFoundException *&#x2F; public static void Demo8() throws ClassNotFoundException &#123; Class&lt;?&gt; class1 &#x3D; null; class1 &#x3D; Class.forName(&quot;cn.lee.demo.SuperMan&quot;); String nameString &#x3D; class1.getClassLoader().getClass().getName(); System.out.println(&quot;Demo8: 类加载器类名: &quot; + nameString); &#125; &#125;&#x2F;** * * @author xiaoyaomeng * *&#x2F;class Person&#123; private int age; private String name; public Person()&#123; &#125; public Person(int age, String name)&#123; this.age &#x3D; age; this.name &#x3D; name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age &#x3D; age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name &#x3D; name; &#125;&#125; class SuperMan extends Person implements ActionInterface&#123; private boolean BlueBriefs; public void fly() &#123; System.out.println(&quot;超人会飞耶～～&quot;); &#125; public boolean isBlueBriefs() &#123; return BlueBriefs; &#125; public void setBlueBriefs(boolean blueBriefs) &#123; BlueBriefs &#x3D; blueBriefs; &#125; @Override public void walk(int m) &#123; &#x2F;&#x2F; TODO Auto-generated method stub System.out.println(&quot;超人会走耶～～走了&quot; + m + &quot;米就走不动了！&quot;); &#125;&#125;interface ActionInterface&#123; public void walk(int m);&#125; 五、java反射调用service或mapper中的接口java中的反射需要一个实例，但是接口无法提供这样的实例，但是JDK提供了一个叫做动态代理的东西，这个代理恰恰只能代理接口。所以我们想要反射接口需要使用这个动态代理来做。 在java的动态代理机制中，有两个重要的东西，一个是 InvocationHandler(接口)、另一个则是 Proxy(类)，这是我们动态代理必须用到的两个东西。 1、静态代理先来看一下静态代理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TestStaticProxy &#123; &#x2F;&#x2F;这里传入的是接口类型的对象，方便向上转型，实现多态 public static void consumer(ProxyInterface pi)&#123; pi.say(); &#125; public static void main(String[] args) &#123; &#x2F;&#x2F; TODO Auto-generated method stub consumer(new ProxyObject()); &#125;&#125;&#x2F;&#x2F;代理接口interface ProxyInterface&#123; public void say();&#125;&#x2F;&#x2F;被代理者class RealObject implements ProxyInterface&#123; &#x2F;&#x2F;实现接口方法 @Override public void say() &#123; &#x2F;&#x2F; TODO Auto-generated method stub System.out.println(&quot;say&quot;); &#125; &#125;&#x2F;&#x2F;代理者class ProxyObject implements ProxyInterface&#123; @Override public void say() &#123; &#x2F;&#x2F; TODO Auto-generated method stub &#x2F;&#x2F;dosomething for example System.out.println(&quot;hello proxy&quot;); new RealObject().say(); System.out.println(&quot;this is method end&quot;); &#125; &#125;output:hello proxysaythis is method end 2、动态代理123456789101112131415161718192021222324252627282930313233343536373839import java.lang.reflect.*;public class TestActiveProxy&#123; static void customer(ProxyInterface pi)&#123; pi.say(); &#125; public static void main(String[] args)&#123; RealObject real &#x3D; new RealObject(); ProxyInterface proxy &#x3D; (ProxyInterface)Proxy.newProxyInstance(ProxyInterface.class.getClassLoader(),new Class[]&#123;ProxyInterface.class&#125;, new ProxyObject(real)); customer(proxy); &#125;&#125;interface ProxyInterface&#123; void say();&#125;&#x2F;&#x2F;被代理类class RealObject implements ProxyInterface&#123; public void say()&#123; System.out.println(&quot;i&#39;m talking&quot;); &#125;&#125;&#x2F;&#x2F;代理类，实现InvocationHandler 接口class ProxyObject implements InvocationHandler&#123; private Object proxied &#x3D; null; public ProxyObject()&#123; &#125; public ProxyObject(Object proxied)&#123; this.proxied &#x3D; proxied; &#125; public Object invoke(Object arg0, Method arg1, Object[] arg2) throws Throwable &#123; System.out.println(&quot;hello&quot;); return arg1.invoke(proxied, arg2); &#125;;&#125; 3、应用场景假如现在我们需要通过反射得到TestMapper接口，然后调用其中的一个selectById方法 123456public interface TestMapper&#123; &#x2F;** * 根据id查对象 *&#x2F; User selectById(@Param(&quot;id&quot;) Integer id);&#125; 现在如果我们需要反射使用该接口根据用户ID获取用户对象是无法直接反射调取的，所以我们需要一个动态代理类。创建一个MyInvocationHandler实现InvocationHandler接口 12345678910111213public class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target) &#123; this.target &#x3D; target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(target,args); &#125;&#125; 去生成代理对象并调用方法 1234567891011121314 SqlSession sqlSession &#x3D; this.sqlSessionFactory.openSession(); Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.example.demo.mapper.TestMapper&quot;); Object instance &#x3D; Proxy.newProxyInstance( clazz.getClassLoader(), new Class[]&#123;clazz&#125;, new MyInvocationHandler(sqlSession.getMapper(clazz)) );&#x2F;&#x2F;这里我是通过sqlSession来获取Mapper的 Method method &#x3D; instance.getClass().getMethod(&quot;selectById&quot;,Integer.class); method.invoke(instance, 1);&#x2F;&#x2F;object为mapper中传入的参数 这里需要注意，newProxyInstance()方法中最后一个参数，即为我们创建的动态代理的类（因为我这里调用的接口为mybatis中mapper中的接口，所以需要从sqlSession中getMapper）。 参考：http://blog.qiji.tech/archives/4374https://www.jianshu.com/p/9be58ee20deehttps://blog.csdn.net/ljphhj/article/details/12858767https://developer.android.google.cn/reference/java/lang/reflect/Method?hl=zh-cn","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"反射","slug":"反射","permalink":"http://www.lida1024.top/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"zipkin","slug":"zipkin","date":"2020-01-01T03:39:00.000Z","updated":"2020-04-10T03:55:04.746Z","comments":true,"path":"2020/01/01/zipkin/","link":"","permalink":"http://www.lida1024.top/2020/01/01/zipkin/","excerpt":"","text":"Waht is zipkin?Zipkin是一种分布式跟踪系统。它有助于收集解决微服务架构中的延迟问题所需的时序数据。它管理这些数据的收集和查找。Zipkin的设计基于Google Dapper论文。 应用程序用于向Zipkin报告时序数据。Zipkin UI还提供了一个依赖关系图，显示了每个应用程序通过的跟踪请求数。如果要解决延迟问题或错误，可以根据应用程序，跟踪长度，注释或时间戳对所有跟踪进行筛选或排序。选择跟踪后，您可以看到每个跨度所需的总跟踪时间百分比，从而可以识别问题应用程序。 快速开始下面我们将逐步构建并启动Zipkin实例，以便在本地检查Zipkin。有三个选项：使用Java，Docker或从源代码运行。 如果您熟悉Docker，这是首选的方法。如果您不熟悉Docker，请尝试通过Java或源代码运行。 无论您如何启动Zipkin，请浏览http：// your_host：9411以查找跟踪！ DockerDocker zipkin工程可以创建docker 镜像, 提供脚本和一个docker-compose.yml 用于启动预建的镜像。最快的开始是直接运行最新的镜像： 1docker run -d -p 9411:9411 openzipkin&#x2F;zipkin Java如果安装了Java 8或更高版本，最快的方法是获得最新版本后，通过java启动 123&gt;curl -sSL https:&#x2F;&#x2F;zipkin.io&#x2F;quickstart.sh | bash -s&gt;java -jar zipkin.jar Running from Source（源代码运行）Zipkin可以从源代码运行。要实现这一点，您需要获得zipkin源码 get the latest source git clone https://github.com/openzipkin/zipkin cd zipkin Build the server and also make its dependencies ./mvnw -DskipTests –also-make -pl zipkin-server clean install Run the server java -jar ./zipkin-server/target/zipkin-server-*exec.jar","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"解决Tomcat8上传文件无可读权限问题","slug":"解决Tomcat8上传文件无可读权限问题","date":"2020-01-01T03:34:00.000Z","updated":"2020-04-11T00:52:56.413Z","comments":true,"path":"2020/01/01/解决Tomcat8上传文件无可读权限问题/","link":"","permalink":"http://www.lida1024.top/2020/01/01/%E8%A7%A3%E5%86%B3Tomcat8%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%A0%E5%8F%AF%E8%AF%BB%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"描述使用springmvc做了一个文件上传的功能，上传到nginx目录下的一个文件夹，但是通过目录访问的时候却报403的错误去服务器查看了一下文件的权限，发现没有可读权限，于是定位了问题，上传的文件全都没有可读权限。 为什么没有可读权限网上查阅资料发现，linux默认umask为022，对应权限为755，其它用户可读可执行。可以vim /etc/profile，搜索umusk关键字查看 1234if [ $UID -gt 199 ] &amp;&amp; [ &quot;&#96;&#x2F;usr&#x2F;bin&#x2F;id -gn&#96;&quot; &#x3D; &quot;&#96;&#x2F;usr&#x2F;bin&#x2F;id -un&#96;&quot; ]; then umask 002else umask 022 而tomcat8默认umask为027，对应权限为750，也就是说其它用户连可读的权限都没有。可打开catalina.sh文件，搜索umask查看。 12345# Set UMASK unless it has been overriddenif [ -z &quot;$UMASK&quot; ]; then UMASK&#x3D;&quot;0027&quot;fiumask $UMASK 在catalina.sh文件的开篇可以看到 1# UMASK (Optional) Override Tomcat&#39;s default UMASK of 0027 于是问题有了答案登录到服务器，进入到tomcat的bin目录下 123vim catalina.sh输入i,进入编辑模式，将umask改为0022：wq(保存退出) 可以看到接下来重启tomcat，重新上传图片即可香油可读权限。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Container","slug":"Dev/Container","permalink":"http://www.lida1024.top/categories/Dev/Container/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://www.lida1024.top/tags/Tomcat/"}]},{"title":"软件版本命名规范及各阶段说明","slug":"软件版本命名规范及各阶段说明","date":"2020-01-01T03:27:00.000Z","updated":"2020-04-10T03:52:06.781Z","comments":true,"path":"2020/01/01/软件版本命名规范及各阶段说明/","link":"","permalink":"http://www.lida1024.top/2020/01/01/%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E5%8F%8A%E5%90%84%E9%98%B6%E6%AE%B5%E8%AF%B4%E6%98%8E/","excerpt":"","text":"前言很多开发人员都没有经历过产品不断的迭代过程，基本上都是做完一套，至多经历一两个版本的迭代，基本上都会调入到另一个项目组或者离职，之后这样的事情不断地重复，直至离开这个行业。 开发人员3个月开发一个版本，定位version1，如果有bug，修复后该怎么升级这个版本号呢？可能是version2，修复这个bug后，如果还有bug呢，可能继续version3.，如果这样下去，还没到产品上线，你这个版本号都会很大，而且很难记得哪一版有什么功能。如果产品上线了以后，还会升级，大家可以想象一下，这样下去后，可能到达了version9999…. 命名格式版本控制比较普遍的 3 种命名格式 :GNU 风格的版本号命名格式、Windows 风格的版本号命名格式、.Net Framework 风格的版本号命名格式。 GNU 风格的版本号命名格式主版本号 . 子版本号 [. 修正版本号 [. 编译版本号 ]]Major_Version_Number.Minor_Version_Number[.Revision_Number[.Build_Number]]示例 :1.2.1, 2.0, 5.0.0 build-13124 Windows 风格的版本号命名格式主版本号 . 子版本号 [ 修正版本号 [. 编译版本号 ]]Major_Version_Number.Minor_Version_Number[Revision_Number[.Build_Number]]示例: 1.21, 2.0 .Net Framework 风格的版本号命名格式主版本号.子版本号[.编译版本号[.修正版本号]]Major_Version_Number.Minor_Version_Number[.Build_Number[.Revision_Number]]版本号由二至四个部分组成：主版本号、次版本号、内部版本号和修订号。主版本号和次版本号是必选的；内部版本号和修订号是可选的，但是如果定义了修订号部分，则内部版本号就是必选的。所有定义的部分都必须是大于或等于 0 的整数。 应根据下面的约定使用这些部分：Major ：具有相同名称但不同主版本号的程序集不可互换。例如，这适用于对产品的大量重写，这些重写使得无法实现向后兼容性。 Minor：如果两个程序集的名称和主版本号相同，而次版本号不同，这指示显著增强，但照顾到了向后兼容性。例如，这适用于产品的修正版或完全向后兼容的新版本。 Build ：内部版本号的不同表示对相同源所作的重新编译。这适合于更改处理器、平台或编译器的情况。 Revision ：名称、主版本号和次版本号都相同但修订号不同的程序集应是完全可互换的。这适用于修复以前发布的程序集中的安全漏洞。 程序集的只有内部版本号或修订号不同的后续版本被认为是先前版本的修补程序 (Hotfix) 更新。 因为目前市场上的软件基本上都是移动端化了，所以这里主要介绍GNU风格。 软件版本阶段说明 Base版: 此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是页面中的功能都没有做完整的实现，只是做为整体网站的一个基础架构。 Alpha版: 此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改。 Beta版: 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI。 RC版: 该版本已经相当成熟了，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。 Release版: 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(Ｒ)。 版本命名规范软件版本号由四部分组成： 第一部分为主版本号 第二部分为子版本号 第三部分为阶段版本号 第四部分为日期版本号加希腊字母版本号版本号修改规则 主版本号修改 当功能模块有较大的变动，比如增加多个模块或者整体架构发生变化。此版本号由项目决定是否修改。 子版本号修改 当功能有一定的增加或变化，比如增加了对权限控制、增加自定义视图等功能。此版本号由项目决定是否修改。 阶段版本号修改 一般是 Bug 修复或是一些小的变动，要经常发布修订版，时间间隔不限，修复一个严重的bug即可发布一个修订版。此版本号由项目经理决定是否修改。 日期版本号 用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本号。此版本号由开发人员决定是否修改。 希腊字母版本号 此版本号用于标注当前版本的软件处于哪个开发阶段，当软件进入到另一个阶段时需要修改此版本号。此版本号由项目决定是否修改。版本号阶段标志 阶段名称 阶段标识 需求控制 a 设计阶段 b 编码阶段 c 单元测试 d 单元测试修改 e 集成测试 f 集成测试修改 g 系统测试 h 系统测试修改 i 验收测试 j 验收测试修改 k","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"规范","slug":"规范","permalink":"http://www.lida1024.top/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"快速搭建Spring Boot项目及常用技术整合","slug":"快速搭建Spring-Boot项目及常用技术整合","date":"2020-01-01T03:18:00.000Z","updated":"2020-04-10T03:52:47.248Z","comments":true,"path":"2020/01/01/快速搭建Spring-Boot项目及常用技术整合/","link":"","permalink":"http://www.lida1024.top/2020/01/01/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BASpring-Boot%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E6%95%B4%E5%90%88/","excerpt":"","text":"Spring Boot简介Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 Spring Boot特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成并且对XML也没有配置要求 快速入门1、访问http://start.spring.io/构建项目，也可在idea创建如下图： 2、 springboot默认生成三个文件2.1 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;groupId&gt;com.example&lt;&#x2F;groupId&gt; &lt;artifactId&gt;demo&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;name&gt;demo&lt;&#x2F;name&gt; &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;&#x2F;properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 重点就一个gav：spring-boot-starter-web，其他可以删除。 2.2 application.properties该文件默认为空，springboot的默认启动端口号：8080，可以在改文件修改。建议用yml的格式 12server: port: 8080 2.3 启动类文件1234567public class JxcApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(JxcApplication.class, args); &#125;&#125; 2.4 验证springboot在项目包路径下创建一个Controller，写一个HelloController 123456789@Controllerpublic class HelloController &#123; @RequestMapping(&quot;&#x2F;&quot;) @ResponseBody public String getHello() &#123; return &quot;hello&quot;; &#125;&#125; 浏览器查看效果 完成项目完整项目目录 1、项目依赖 web 12345678910111213141516 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;2.1.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;aspectjweaver.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; mysql12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; lombok(可选)12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;optional&gt;true&lt;&#x2F;optional&gt; &lt;&#x2F;dependency&gt; pagehelper(可选)12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;pagehelper.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; JWT(可选)12345&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;jwt.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; mybatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; shiro12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt; &lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt; &lt;version&gt;1.4.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; hutool(可选)12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt; &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt; &lt;version&gt;5.0.7&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; druid1234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.10&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt; &lt;version&gt;1.1.10&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; jdbc1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; fastjson12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt; &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; tomcat1234&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 附上properties123456789101112&lt;properties&gt; &lt;project.version&gt;1.0&lt;&#x2F;project.version&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;mysql.version&gt;5.1.25&lt;&#x2F;mysql.version&gt; &lt;pagehelper.version&gt;1.2.12&lt;&#x2F;pagehelper.version&gt; &lt;jwt.version&gt;0.9.1&lt;&#x2F;jwt.version&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;commons.lang.version&gt;3.9&lt;&#x2F;commons.lang.version&gt; &lt;aspectjweaver.version&gt;1.9.4&lt;&#x2F;aspectjweaver.version&gt; &lt;fastjson.version&gt;1.2.62&lt;&#x2F;fastjson.version&gt; &lt;&#x2F;properties&gt; 2、配置文件2.1修改application.properties为application.yml配置端口，项目根路径，spring配置，mybatis配置，分页插件配置1234567891011121314151617181920212223242526272829303132333435server: port: 8100 servlet: context-path: &#x2F;apispring: profiles: active: dev http: encoding: charset: UTF-8 force: true enabled: truemybatis: mapper-locations: classpath:&#x2F;mapper&#x2F;*.xml type-aliases-package: com.example.jxc.domain.entity.* configuration: cache-enabled: true lazy-loading-enabled: true multiple-result-sets-enabled: true use-column-label: true call-setters-on-nulls: true local-cache-scope: session map-underscore-to-camel-case: true default-executor-type: BATCH auto-mapping-behavior: PARTIALpagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count&#x3D;countSql mybatis中的configuration配置，这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项的意图、默认值等。| 设置名| 描述| 有效值|默认值||—–|—–|——|——|| cacheEnabled | 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。 | true false |true|| lazyLoadingEnabled| 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 | true false |false|| aggressiveLazyLoading| 当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载（参考 lazyLoadTriggerMethods)。 | true false |false （在 3.4.1 及之前的版本默认值为 true） || multipleResultSetsEnabled| 是否允许单一语句返回多结果集（需要驱动支持）。 | true false |true|| useColumnLabel| 使用列标签代替列名。不同的驱动在这方面会有不同的表现，具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。 | true false |true|| useGeneratedKeys| 允许 JDBC 支持自动生成主键，需要驱动支持。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能支持但仍可正常工作（比如 Derby）。 | true false |false || autoMappingBehavior| 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。 | NONE, PARTIAL, FULL |PARTIAL|| autoMappingUnknownColumnBehavior| 指定发现自动映射目标未知列（或者未知属性类型）的行为。NONE: 不做任何反应，WARNING: 输出提醒日志 (‘org.apache.ibatis.session.AutoMappingUnknownColumnBehavior’ 的日志等级必须设置为 WARN) ，FAILING: 映射失败 (抛出 SqlSessionException) | NONE, WARNING, FAILING |NONE|| defaultExecutorType| 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。 | SIMPLE REUSE BATCH |SIMPLE|| defaultStatementTimeout| 设置超时时间，它决定驱动等待数据库响应的秒数。 | 任意正整数 |未设置 (null) || defaultFetchSize| 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 | 任意正整数 |未设置 (null) || defaultResultSetType| Specifies a scroll strategy when omit it per statement settings. (Since: 3.5.2) | FORWARD_ONLY SCROLL_SENSITIVE SCROLL_INSENSITIVE DEFAULT(same behavior with ‘Not Set’) |Not Set (null) || safeRowBoundsEnabled| 允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 | true false |false || safeResultHandlerEnabled|允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为 false。 | true false |false || mapUnderscoreToCamelCase|是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 | true false |false || localCacheScope| MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 | SESSION STATEMENT |SESSION || jdbcTypeForNull| 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 | JdbcType 常量，常用值：NULL, VARCHAR 或 OTHER。|OTHER|| lazyLoadTriggerMethods| 指定哪个对象的方法触发一次延迟加载。 | 用逗号分隔的方法列表 |equals,clone,hashCode,toString || defaultScriptingLanguage| 指定动态 SQL 生成的默认语言。 | 一个类型别名或完全限定类名 |org.apache.ibatis.scripting.xmltags.XMLLanguageDriver || defaultEnumTypeHandler|指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5） | 一个类型别名或完全限定类名 |org.apache.ibatis.type.EnumTypeHandler || callSettersOnNulls| 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值初始化的时候比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 | true false |false || returnInstanceForEmptyRow| 当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 （如集合或关联）。（新增于 3.4.2） | true false |false || logPrefix| 指定 MyBatis 增加到日志名称的前缀。 | 任何字符串 |未设置|| logImpl| 指定 MyBatis 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 | SLF4J,LOG4J,LOG4J2,JDK_LOGGING,COMMONS_LOGGING,STDOUT_LOGGING,NO_LOGGING |未设置|| proxyFactory| 指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。 | CGLIB ,JAVASSIST |AVASSIST （MyBatis 3.3 以上） || vfsImpl| 指定 VFS 的实现 | 自定义 VFS 的实现的类全限定名，以逗号分隔。 |未设置|| useActualParamName| 允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 -parameters 选项。（新增于 3.4.1） | true false |true|| configurationFactory| 指定一个提供 Configuration 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为static Configuration getConfiguration() 的方法。（新增于 3.2.3） | 类型别名或者全类名. |未设置| 2.2 新建application-dev.yml配置数据库信息,通过application.yml中的active来启用dev配置文件 123spring: profiles: active: dev application-dev.yml完整配置 12345678910111213141516171819202122232425spring: datasource: # 数据源基本配置 username: root password: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;fhshgl type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙 filters: stat,wall maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;500 3、数据库连接池 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;) @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; &#x2F;** * 配置Druid的监控 * @return *&#x2F; @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean &#x3D; new ServletRegistrationBean(new StatViewServlet(), &quot;&#x2F;druid&#x2F;*&quot;); Map&lt;String,String&gt; initParams &#x3D; new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); &#x2F;&#x2F;默认就是允许所有访问 initParams.put(&quot;allow&quot;,&quot;&quot;); initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;); bean.setInitParameters(initParams); return bean; &#125; &#x2F;** * 配置一个web监控的filter * @return *&#x2F; @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean &#x3D; new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams &#x3D; new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,&#x2F;druid&#x2F;*&quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;&#x2F;*&quot;)); return bean; &#125;&#125; 4、shiro4.1自定义realm代码如下： 123456789101112131415161718192021222324252627public class MyRealm extends AuthorizingRealm&#123; @Autowired private UserService userService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; return null; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; &#x2F;&#x2F;拿到封装好账户密码的token UsernamePasswordToken token &#x3D; (UsernamePasswordToken) authenticationToken; String userName &#x3D; token.getUsername(); &#x2F;&#x2F;用户校验 User user &#x3D; this.userService.getUser(userName); if (user &#x3D;&#x3D; null) &#123; throw new AuthenticationException(&quot;用户名或密码错误！&quot;); &#125; &#x2F;&#x2F;加盐 计算盐值 保证每个加密后的 MD5 不一样 ByteSource credentialsSalt &#x3D; ByteSource.Util.bytes(user.getUsername()); SimpleAuthenticationInfo info &#x3D; new SimpleAuthenticationInfo(user, user.getPassword(), credentialsSalt, this.getName()); return info; &#125;&#125; 4.2shiro配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Configurationpublic class ShiroConfig &#123; &#x2F;** * 主要配置一些相应的URL的规则和访问权限 *&#x2F; @Bean public ShiroFilterFactoryBean shiroFilter() &#123; ShiroFilterFactoryBean shiroFilterFactoryBean &#x3D; new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager()); &#x2F;&#x2F;拦截器. Map&lt;String, String&gt; filterChainDefinitionMap &#x3D; new LinkedHashMap&lt;String, String&gt;(); &#x2F;&#x2F;配置退出 过滤器,其中的具体的退出代码Shiro已经替我们实现了 filterChainDefinitionMap.put(&quot;&#x2F;system&#x2F;logout&quot;, &quot;anon&quot;); &#x2F;&#x2F;过滤链定义，从上向下顺序执行，一般将&#x2F;**放在最为下边 &#x2F;&#x2F;authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问&#x2F;&#x2F; filterChainDefinitionMap.put(&quot;&#x2F;static&#x2F;**&quot;, &quot;anon&quot;); shiroFilterFactoryBean.setLoginUrl(&quot;&#x2F;system&#x2F;login&quot;); filterChainDefinitionMap.put(&quot;&#x2F;**&quot;, &quot;authc&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; &#125; &#x2F;** * 注入 securityManager *&#x2F; @Bean public DefaultWebSecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager &#x3D; new DefaultWebSecurityManager(); &#x2F;&#x2F; 设置realm. securityManager.setRealm(customRealm()); return securityManager; &#125; &#x2F;** * 自定义身份认证 realm; * &lt;p&gt; * 必须写这个类，并加上 @Bean 注解，目的是注入 MyRealm， * 否则会影响 MyRealm 中其他类的依赖注入 *&#x2F; @Bean public MyRealm customRealm() &#123; return new MyRealm(); &#125; &#x2F;** * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证 * 配置以下两个bean(DefaultAdvisorAutoProxyCreator(可选)和AuthorizationAttributeSourceAdvisor)即可实现此功能 * * @return *&#x2F; @Bean @DependsOn(&#123;&quot;lifecycleBeanPostProcessor&quot;&#125;) public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() &#123; DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator &#x3D; new DefaultAdvisorAutoProxyCreator(); advisorAutoProxyCreator.setProxyTargetClass(true); return advisorAutoProxyCreator; &#125; @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor() &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor &#x3D; new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager()); return authorizationAttributeSourceAdvisor; &#125; &#x2F;** * Shiro生命周期处理器 ---可以自定的来调用配置在 Spring IOC 容器中 shiro bean 的生命周期方法. * * @return *&#x2F; @Bean public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125;&#125; 5、过滤器-跨域过滤5.1跨域过滤 1234567891011121314151617181920212223242526272829public class CostFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req &#x3D; (HttpServletRequest) request; HttpServletResponse resp &#x3D; (HttpServletResponse) response; String origin &#x3D; req.getHeader(&quot;Origin&quot;); if (origin &#x3D;&#x3D; null) &#123; origin &#x3D; req.getHeader(&quot;Referer&quot;); &#125; &#x2F;&#x2F; 允许指定域访问跨域资源 resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); &#x2F;&#x2F; 允许客户端携带跨域cookie，此时origin值不能为“*”，只能为指定单一域名 resp.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); if (&quot;OPTIONS&quot;.equals(req.getMethod())) &#123; String allowMethod &#x3D; req.getHeader(&quot;Access-Control-Request-Method&quot;); String allowHeaders &#x3D; req.getHeader(&quot;Access-Control-Request-Headers&quot;); &#x2F;&#x2F; 浏览器缓存预检请求结果时间,单位:秒 resp.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;86400&quot;); &#x2F;&#x2F; 允许浏览器在预检请求成功之后发送的实际请求方法名 resp.setHeader(&quot;Access-Control-Allow-Methods&quot;, allowMethod); &#x2F;&#x2F; 允许浏览器发送的请求消息头 resp.setHeader(&quot;Access-Control-Allow-Headers&quot;, allowHeaders); resp.setHeader(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;utf-8&quot;); return; &#125; chain.doFilter(request, response); &#125;&#125; 5.2 过滤器配置 12345678910111213141516@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean configureFilter()&#123; FilterRegistrationBean bean &#x3D; new FilterRegistrationBean&lt;&gt;(); bean.setName(&quot;costFilter&quot;); CostFilter costFilter &#x3D; new CostFilter(); bean.setFilter(costFilter); bean.setOrder(1); List&lt;String&gt; urlList &#x3D; new ArrayList&lt;String&gt;(); urlList.add(&quot;&#x2F;*&quot;); bean.setUrlPatterns(urlList); return bean; &#125;&#125; 6、token拦截6.1JWTjwt工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class JwtUtils &#123; public static SecretKey getBase64Key() &#123; String stringKey &#x3D; &quot;MyJwtSecret&quot;; byte[] encodeKey &#x3D; Base64.getDecoder().decode(stringKey); SecretKey key &#x3D; new SecretKeySpec(encodeKey, 0, encodeKey.length, &quot;AES&quot;); return key; &#125; &#x2F;** * 签发token * * @param userName 用户名 * @return token *&#x2F; public static String create(String userName) &#123; Date now &#x3D; new Date(System.currentTimeMillis()); String token &#x3D; Jwts.builder() .setIssuedAt(now) .setSubject(userName) .setExpiration(new Date(System.currentTimeMillis() + 60 * 60 * 1000)) .signWith(SignatureAlgorithm.HS256, getBase64Key()) .compact(); return token; &#125; &#x2F;** * 解析token * * @param token token * @return 用户名 *&#x2F; public static String parse(String token) &#123; String username &#x3D; null; try &#123; username &#x3D; Jwts.parser() .setSigningKey(getBase64Key()) .parseClaimsJws(token.replace(&quot;Bearer &quot;, &quot;&quot;)) .getBody() .getSubject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return username; &#125; &#x2F;** * 检验token是否过期 * * @param token * @return *&#x2F; public static boolean verify(String token) &#123; Date expiraDate &#x3D; null; Date currentDate &#x3D; new Date(); try &#123; expiraDate &#x3D; Jwts.parser() .setSigningKey(getBase64Key()) .parseClaimsJws(token.replace(&quot;Bearer &quot;, &quot;&quot;)) .getBody() .getExpiration(); if (currentDate.before(expiraDate)) &#123; return true; &#125; else &#123; return false; &#125; &#125; catch (Exception e) &#123; return false; &#125; &#125;&#125; 6.2token拦截器 123456789101112131415161718192021222324@Componentpublic class TokenInterceptor implements HandlerInterceptor &#123; public Log log &#x3D; LogFactory.getLog(TokenInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)&#123; if (request.getMethod().equals(&quot;OPTIONS&quot;)) &#123; response.setStatus(HttpServletResponse.SC_OK); return true; &#125; response.setCharacterEncoding(&quot;utf-8&quot;); String token &#x3D; request.getHeader(&quot;Authorization&quot;); if (token !&#x3D; null) &#123; boolean result &#x3D; JwtUtils.verify(token); if (result) &#123; return true; &#125; &#125; log.error(&quot;认证失败&quot;); response.setStatus(HttpServletResponse.SC_NON_AUTHORITATIVE_INFORMATION); return false; &#125;&#125; 6.3配置拦截器 1234567891011121314@Configurationpublic class InterceptorConfig extends WebMvcConfigurationSupport &#123; @Autowired private TokenInterceptor tokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(tokenInterceptor) .addPathPatterns(&quot;&#x2F;**&quot;) .excludePathPatterns(&quot;&#x2F;**&#x2F;login&quot;) .excludePathPatterns(&quot;&#x2F;**&#x2F;logOut&quot;); &#125;&#125; 7、完成一个登录接口LoginController123456789101112131415161718192021222324252627282930@RestController@RequestMapping(&quot;&#x2F;system&quot;)public class LoginController extends BaseController &#123; @Autowired private UserService userService; &#x2F;** * 浏览器点击登录 * * @param user * @return *&#x2F; @PostMapping(&quot;&#x2F;login&quot;) public R login(@RequestBody User user) &#123; log.debug(&quot;------浏览器点击登录------&quot;); String userName &#x3D; user.getUsername(); String passWord &#x3D; user.getPassword(); UsernamePasswordToken usernamePasswordToken &#x3D; new UsernamePasswordToken(userName, MD5.md5Salt(passWord, userName)); Subject subject &#x3D; SecurityUtils.getSubject(); try &#123; subject.login(usernamePasswordToken); String token &#x3D; JwtUtils.create(userName); return R.ok(R.SUCCESS, R.MSG_SUCCESS, token); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); return R.error(R.MSG_LOGIN_ERROR); &#125; &#125;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"微服务网关 Spring Cloud Gateway","slug":"微服务网关-Spring-Cloud-Gateway","date":"2020-01-01T03:09:00.000Z","updated":"2020-04-10T06:39:37.760Z","comments":true,"path":"2020/01/01/微服务网关-Spring-Cloud-Gateway/","link":"","permalink":"http://www.lida1024.top/2020/01/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3-Spring-Cloud-Gateway/","excerpt":"","text":"什么是网关假设你现在要做一个电商应用，前端是移动端的APP，后端是各种微服务。那你可能某个页面需要调用多个服务的数据来展示。如果没有网关，你的系统看起来就是这个样子的： 而如果加上了网关，你的系统就会变成这个样子：#Spring Cloud GatewaySpring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。 Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。 相关概念 Route（路由）：这是网关的基本构建块。它由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配。 Predicate（断言）：这是一个 Java 8 的 Predicate。输入类型是一个 ServerWebExchange。我们可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。 Filter（过滤器）：这是org.springframework.cloud.gateway.filter.GatewayFilter的实例，我们可以使用它修改请求和响应。工作流程 （PS：看到这张图是不是很熟悉，没错，很像SpringMVC的请求处理过程） 请求发送到网关，DispatcherHandler是HTTP请求的中央分发器，接管请求并将请求匹配到相应的 HandlerMapping。 请求与处理器之间有一个映射关系，网关将会对请求进行路由，handler 此处会匹配到 RoutePredicateHandlerMapping，匹配请求对应的 Route。 随后到达网关的 web 处理器，该 WebHandler 代理了一系列网关过滤器和全局过滤器的实例，如对请求或者响应的 Header 处理（增加或者移除某个 Header）。 最后，转发到具体的代理服务。 简而言之：客户端向 Spring Cloud Gateway 发出请求。如果 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。 快速开始1.新建一个项目gatewayTest在项目中添加3个moduleeureka,producer,gateway项目结构 2.rureka新建module 添加eureka依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 完整pom 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.example.eureka&lt;&#x2F;groupId&gt; &lt;artifactId&gt;eureka&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;packaging&gt;jar&lt;&#x2F;packaging&gt; &lt;name&gt;eureka&lt;&#x2F;name&gt; &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt; &lt;parent&gt; &lt;groupId&gt;com.gateway.test&lt;&#x2F;groupId&gt; &lt;artifactId&gt;gatewayTest&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;relativePath&gt;..&lt;&#x2F;relativePath&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 配置文件 1234567891011121314spring: application: name: eurekaserver: port: 8761eureka: instance: hostname: localhost client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F; 启动类 123456789101112131415package com.example.eureka.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 启动程序，访问http://localhost:8761/![图片.png](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjU1MzI0OS05NzY5NzhkMzZmOGM1NmJlLnBuZw?x-oss-process=image/format,png)现在还没有服务进行注册 3.producer新建producer的module，同创建rureka，不同处如下图，其他都一样。 完整pom 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.example.producer&lt;&#x2F;groupId&gt; &lt;artifactId&gt;producer&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;name&gt;producer&lt;&#x2F;name&gt; &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt; &lt;parent&gt; &lt;groupId&gt;com.gateway.test&lt;&#x2F;groupId&gt; &lt;artifactId&gt;gatewayTest&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;relativePath&gt;..&lt;&#x2F;relativePath&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 配置文件 12345678910spring: application: name: producerserver: port: 8081eureka: client: service-url: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F; 启动类 123456789101112131415package com.example.producer.producer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@EnableEurekaClient@SpringBootApplicationpublic class ProducerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProducerApplication.class, args); &#125;&#125; 新建2个类控制器HelloController 123456789@RestController@RequestMapping(&quot;&#x2F;hello&quot;)public class HelloController &#123; @RequestMapping(&quot;say&quot;) public String say() &#123; return &quot;Hello Every Buddy&quot;; &#125;&#125; GoodByeController 123456789@RestController@RequestMapping(&quot;&#x2F;goodbye&quot;)public class GoodByeController &#123; @RequestMapping(&quot;say&quot;) public String say() &#123; return &quot;Bye Bye&quot;; &#125;&#125; 启动程序，访问http://localhost:8761/ 4.gateway创建过程同eureka完整pom 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.example.gateway&lt;&#x2F;groupId&gt; &lt;artifactId&gt;gateway&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;name&gt;gateway&lt;&#x2F;name&gt; &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt; &lt;parent&gt; &lt;groupId&gt;com.gateway.test&lt;&#x2F;groupId&gt; &lt;artifactId&gt;gatewayTest&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;relativePath&gt;..&lt;&#x2F;relativePath&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344test: uri: lb:&#x2F;&#x2F;producerspring: application: name: gateway# cloud:# gateway:# routes:# - id: route_producer_hello# uri: $&#123;test.uri&#125; # uri以lb:&#x2F;&#x2F;开头（lb代表从注册中心获取服务），后面接的就是你需要转发到的服务名称# predicates:# - Path&#x3D;&#x2F;api-hello&#x2F;**# filters:# - StripPrefix&#x3D;1 # 表示在转发时去掉api## - id: route_producer_goodbye# uri: $&#123;test.uri&#125;# predicates:# - Path&#x3D;&#x2F;api-goodbye&#x2F;**# filters:# - StripPrefix&#x3D;1# - name: Hystrix# args:# name: myfallbackcmd# fallbackUri: forward:&#x2F;user&#x2F;fallbackserver: port: 8080logging: level: org.springframework.cloud.gateway: TRACE org.springframework.http.server.reactive: DEBUG org.springframework.web.reactive: DEBUG reactor.ipc.netty: DEBUGeureka: client: service-url: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F; enabled: true # 是否启用注册服务 默认为true, false是不启用 instance: prefer-ip-address: true 启动类 123456789101112131415161718192021222324252627package com.example.gateway.gateway;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.gateway.route.RouteLocator;import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class GatewayApplication &#123; @Value(&quot;$&#123;test.uri&#125;&quot;) private String uri; @Bean public RouteLocator routeLocator(RouteLocatorBuilder builder)&#123; return builder.routes() .route(r -&gt;r.path(&quot;&#x2F;hello&#x2F;**&quot;).uri(uri)) .route(r -&gt;r.path(&quot;&#x2F;goodbye&#x2F;**&quot;).uri(uri)).build(); &#125; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 启动程序，访问http://localhost:8761/ 5.测试服务都已经注册到reureka,我们定义了hello和goodbye开头的请求都会转发到lb://producer服务，我们定义gateway的端口是8080，producer的端口是8081直接请求producer服务http://localhost:8081/hello/sayhttp://localhost:8081/goodbye/say 通过网关请求http://localhost:8080/hello/sayhttp://localhost:8080/goodbye/say 网关本身的负载均衡那所有微服务就只有一个网关，万一并发量上去了，网关承受不住怎么办？Spring Cloud Gateway底层是Netty的，它本身就能承受比较大的并发。如果还是承受不了并发量，那可以注册多个Gateway实例，然后在前面弄一个Nginx或者F5等负载均衡器。大概图是这样：","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"微服务注册中心为什么要使用Consul？","slug":"微服务注册中心为什么要使用Consul？","date":"2020-01-01T03:03:00.000Z","updated":"2020-04-10T06:39:47.114Z","comments":true,"path":"2020/01/01/微服务注册中心为什么要使用Consul？/","link":"","permalink":"http://www.lida1024.top/2020/01/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Consul%EF%BC%9F/","excerpt":"","text":"一、Eureka不建议使用在选型微服务注册中心时，一定要长远考虑，SpringCloud提供了Eureka作为服务注册中心，我们可以开箱即用，但是，对于服务注册中心随着业务需求的不断变化，对服务注册中心提出了更高要求，Eureka就不太适合了，看到“Eureka 2.0 开源工作宣告停止，继续使用风险自负”。这意味着如果开发者继续使用作为 2.x 分支上现有工作 repo 一部分发布的代码库和工件，则将自负风险，对此，专家建议开发者尽快将相关业务迁移到 Consul/ZooKeeper/Etcd等工具上。 二、Consul与Zookeeper的区别Consul是一个在国外流行的服务发现和配置共享的服务软件。本文翻译自Consul的官方文档，文中重点讲述：在与主流同类软件ZooKeeper、Doozerd以及Etcd比较时，Consul的优势所在。 ZooKeeper、Doozerd、Etcd在架构上都非常相似，它们都有服务节点（server node），而这些服务节点的操作都要求达到节点的仲裁数（通常，节点的仲裁数遵循的是简单多数原则）。此外，它们都是强一致性的，并且提供各种原语。通过应用程序内部的客户端lib库，这些原语可以用来构建复杂的分布式系统。 Consul在一个单一的数据中心内部使用服务节点。在每个数据中心中，为了Consule能够运行，并且保持强一致性，Consul服务端需要仲裁。然而，Consul原生支持多数据中心，就像一个丰富gossip系统连接服务器节点和客户端一样。 当提供K/V存储的时候，这些系统具有大致相同的语义，读取是强一致性的，并且在面对网络分区的时候，为了保持一致性，读取的可用性是可以牺牲的。然而，当系统应用于复杂情况时，这种差异会变得更加明显。 这些系统提供的语义对开发人员构建服务发现系统很有吸引力，但更重要的是，强调开发人员要构建这些特性。ZooKeeper只提供一个原始的K/V值存储，并要求开发人员构建他们自己的系统来提供服务发现功能。相反的是，Consul提供了一个坚固的框架，这不仅仅是为了提供服务发现功能，也是为了减少推测工作和开发工作量。客户端只需简单地完成服务注册工作，然后使用一个DNS接口或者HTTP接口就可以执行工作了，而其他系统则需要你定制自己的解决方案。 一个令人信服的服务发现框架必须包含健康检测功能，并且考虑失败的可能性。要是节点失败或者服务故障了，即使开发人员知道节点A提供Foo服务也是没用的。Navie系统利用的是心跳、周期性更新和TTLs，这些系统不仅需要工作量与节点数量成线性关系，并且对服务器的固定数量提出了要求。此外，故障检测窗口的存活时间至少要和TTL一样长。 ZooKeeper提供了临时节点，这些临时节点就是K/V条目，当客户端断开连接时，这些条目会被删除。虽然这些临时节点比一个心跳系统更高级，但仍存在固有的扩展性问题，并且会增加客户端的复杂性。与ZooKeeper服务器端连接时，客户端必须保持活跃，并且去做持续性连接。此外，ZooKeeper还需要胖客户端，而胖客户端是很难编写，并且胖客户端会经常导致调试质询。 Consul使用一个完全不同的架构进行健康检测。Consul客户端可以运行在集群中的每一个节点上，而不是拥有服务器节点，这些Consul客户端属于一个gossip pool，gossip pool提供了一些功能，包括分布式健康检测。gossip协议提供了一个高效的故障检测工具，这个故障检测工具可以应用到任意规模的集群，而不仅仅是作用于特定的服务器组。同时，这个故障检测工具也支持在本地进行多种健康检测。与此相反，ZooKeeper的临时节点只是一个非常原始的活跃度检测。因为有了Consul，客户端可以检测web服务器是否正在返回200状态码，内存利用率是否达到临界点，是否有足够的数据存储盘等。此外，ZooKeeper会暴露系统的复杂性给客户端，为了避免ZooKeeper出现的这种情况，Consul只提供一个简单HTTP接口。 Consul为服务发现、健康检测、K/V存储和多数据中心提供了一流的支持。为了支持任意存储，而不仅仅是简单的K/V存储，其他系统都要求工具和lib库要率先建立。然而，通过使用客户端节点，Consul提供了一个简单的API，这个API的开发只需要瘦客户端就可以了， 而且，通过使用配置文件和DNS接口，开发人员可以建立完整的服务发现解决方案，最终，达到避免开发API的目的。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"http://www.lida1024.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"枚举真的比静态常量更占空间吗？","slug":"枚举真的比静态常量更占空间吗？","date":"2019-12-30T02:21:00.000Z","updated":"2020-04-11T08:07:52.496Z","comments":true,"path":"2019/12/30/枚举真的比静态常量更占空间吗？/","link":"","permalink":"http://www.lida1024.top/2019/12/30/%E6%9E%9A%E4%B8%BE%E7%9C%9F%E7%9A%84%E6%AF%94%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E6%9B%B4%E5%8D%A0%E7%A9%BA%E9%97%B4%E5%90%97%EF%BC%9F/","excerpt":"","text":"前两天在网上看到一条信息：枚举比静态常量更占用空间。这是真的吗？ 前言枚举枚举类型是Java 5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。 枚举实现原理在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自java.lang.Enum类。 枚举新建一个枚举类 123456789101112131415161718192021222324252627282930package com.example.demo;&#x2F;** * @Author: 少年闰土 * @Date: 2019&#x2F;12&#x2F;27 0027 上午 9:23 * @Description: *&#x2F;public enum Season &#123; SPRING(&quot;春天&quot;, &quot;趁春踏青&quot;), SUMMER(&quot;夏天&quot;, &quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot;, &quot;秋高气爽&quot;), WINTER(&quot;冬天&quot;, &quot;围炉赏雪&quot;); private final String name; private final String desc; Season(String name, String desc) &#123; this.name &#x3D; name; this.desc &#x3D; desc; &#125; public String getName() &#123; return name; &#125; public String getDesc() &#123; return desc; &#125;&#125; 接下来使用javac命令进行编译：生成class文件，然后再通过javap反编译 123456789101112131415public final class com.example.demo.Season extends java.lang.Enum&lt;com.example.demo.Season&gt; &#123; public static final com.example.demo.Season SPRING; public static final com.example.demo.Season SUMMER; public static final com.example.demo.Season AUTUMN; public static final com.example.demo.Season WINTER; &#x2F;&#x2F;编译器为我们添加的静态的values()方法 public static com.example.demo.Season[] values(); &#x2F;&#x2F;编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法 public static com.example.demo.Season valueOf(java.lang.String); &#x2F;&#x2F;构造方法 public java.lang.String getName(); public java.lang.String getDesc(); static &#123;&#125;;&#125; 静态常量123456789101112131415package com.example.demo;&#x2F;** * @Author: 少年闰土 * @Date: 2019&#x2F;12&#x2F;27 0027 上午 10:49 * @Description: *&#x2F;public class Season &#123; public static final String SPRING &#x3D;&quot;春天&quot;; public static final String SUMMER &#x3D;&quot;夏天&quot;; public static final String AUTUMN &#x3D;&quot;秋天&quot;; public static final String WINTER &#x3D;&quot;冬天&quot;;&#125; javap反编译后： 1234567public class com.example.demo.Season &#123; public static final java.lang.String SPRING; public static final java.lang.String SUMMER; public static final java.lang.String AUTUMN; public static final java.lang.String WINTER; public com.example.demo.Season();&#125; 对比枚举 静态常量 编译后的枚举class文件大小为1471字节，静态常量class文件大小为400字节。 用Chkdsk查看簇大小 经过对比枚举类型文件大小更大一些。 枚举的实现原理就是定义一个类，然后实例化几个由final修饰的这个类的对象，每个实例都带有自己的元信息。而常量相比之下，没有这一层封装，只占用最基本的内存，包括引用，和它的值本身，要简单轻巧很多。如果值可以使用基本类型而不是包装类型，那更不用说了。 不过话又说回来，通常情况下我们没必要在意这种区别。如果用枚举可读性、可扩展性更好，用就是了，枚举占那点内存，沧海一粟。在性能与代码维护性之间，除个别情况，优先选后者。高级编程语言的诞生本身就是硬件提升的背景下，牺牲某些性能来降低开发门槛，提高开发效率的，相对于微小的性能损耗，人力成本更值钱","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"Enum","slug":"Enum","permalink":"http://www.lida1024.top/tags/Enum/"}]},{"title":"JWT简介","slug":"JWT简介","date":"2019-12-21T00:43:00.000Z","updated":"2020-04-10T06:05:01.947Z","comments":true,"path":"2019/12/21/JWT简介/","link":"","permalink":"http://www.lida1024.top/2019/12/21/JWT%E7%AE%80%E4%BB%8B/","excerpt":"","text":"前言JSON Web Token（JWT）是目前最流行的跨域身份验证解决方案。微服务常见的认证方案 一、跨域认证的问题互联网服务离不开用户认证。一般流程是下面这样。 1、用户向服务器发送用户名和密码。 2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 3、服务器向用户返回一个 session_id，写入用户的 Cookie。 4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。 一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。 什么是JWT：一句话概括就是（通过客户端保存数据，而服务器根本不保存会话数据，每个请求都被发送回服务器。） 二、JWTJSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。 一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。 1、JWT的原则JWT的原则是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下所示。 123456789&#123; &quot;UserName&quot;: &quot;少年闰土&quot;, &quot;Role&quot;: &quot;Admin&quot;, &quot;Expire&quot;: &quot;2019-12-21 09:15:56&quot;&#125; 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 2、JWT的数据结构样例： 1eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI4ODgiLCJzdWIiOiLlsI_nmb0iLCJpYXQiOjE1NTc5MDU4MDIsImV4cCI6MTU1NzkwNjgwMiwicm9sZXMiOiJhZG1pbiJ9.AS5Y2fNCwUzQQxXh_QQWMpaB75YqfuK-2P7VZiCXEJI 他是一个长字符串，中间用.进行分割，代表JWT的三个组成部分，如下： Header（头部） Payload（负载） Signature（签名） 2.1、头部（Header）头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;} 这个json中的typ属性，用来标识整个token字符串是一个JWT字符串；它的alg属性，用来说明这个JWT签发的时候所使用的签名和摘要算法。typ跟alg属性的全称其实是type跟algorithm，分别是类型跟算法的意思。之所以都用三个字母来表示，也是基于JWT最终字串大小的考虑，同时也是跟JWT这个名称保持一致，这样就都是三个字符了…typ跟alg是JWT中标准中规定的属性名称 在头部指明了签名算法是HS256算法。 我们进行BASE64编码http://base64.xpcha.com/，编码后的字符串如下：eyJhbGciOiJIUzI1NiJ9 2.2、载荷（Playload）Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 1234567iss: jwt签发者sub: jwt所面向的用户aud: 接收jwt的一方exp: jwt的过期时间，这个过期时间必须要大于签发时间nbf: 定义在什么时间之前，该jwt都是不可用的.iat: jwt的签发时间jti: jwt的唯一身份标识，主要用来作为一次性token。 除了官方字段，你还可以在这个部分定义私有字段样例：{&quot;sub&quot;:&quot;1234567890&quot;,&quot;name&quot;:&quot;John Doe&quot;,&quot;admin&quot;:true}然后将其进行base64加密，得到Jwt的第二部分。eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 2.3、签名（Signature）Signature 部分是对前两部分的签名，防止数据篡改。这个签证信息由三部分组成： header (base64后的) payload (base64后的)secret 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 3、Base64URL前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 4、JWT 的使用方式客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。Authorization: Bearer &lt;token&gt; 下图显示了如何获取JWT并将其用于访问API或资源： 三、JWT使用1、添加依赖12345&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;&#x2F;groupId&gt; &lt;artifactId&gt;java-jwt&lt;&#x2F;artifactId&gt; &lt;version&gt;3.2.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 2、工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.example.demo.utils;import com.auth0.jwt.JWT;import com.auth0.jwt.JWTVerifier;import com.auth0.jwt.algorithms.Algorithm;import com.auth0.jwt.exceptions.JWTDecodeException;import com.auth0.jwt.interfaces.DecodedJWT;import org.springframework.stereotype.Component;import java.util.Date;import java.util.HashMap;import java.util.Map;&#x2F;** * @Author: 少年闰土 * @Date: 2019&#x2F;12&#x2F;11 * @Time: 下午 4:12 * @Version: v1.0 * jwt工具类 *&#x2F;@Componentpublic class JwtUtils &#123; &#x2F;** * 解析token * * @param token token * @return 用户名 *&#x2F; public static String getUserName(String token) &#123; try &#123; DecodedJWT jwt &#x3D; JWT.decode(token); return jwt.getClaim(&quot;userName&quot;).asString(); &#125; catch (JWTDecodeException e) &#123; e.printStackTrace(); return null; &#125; &#125; &#x2F;** * 签发token * * @param userName 用户名 * @return token *&#x2F; public static String sign(String userName,String secret) &#123; try &#123; &#x2F;&#x2F;token过期时间 Date date &#x3D; new Date(System.currentTimeMillis() + (60 * 60 * 1000)); Algorithm algorithm &#x3D; Algorithm.HMAC256(secret); &#x2F;&#x2F; 附带username信息 return JWT.create() .withClaim(&quot;userName&quot;, userName) .withExpiresAt(date) .sign(algorithm); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; &#x2F;** * 检验token是否过期 * * @param token * @return *&#x2F; public static Map verify(String token,String userName, String secret) &#123; Map result &#x3D; new HashMap&lt;String, Object&gt;(2); try &#123; Algorithm algorithm &#x3D; Algorithm.HMAC256(secret); JWTVerifier verifier &#x3D; JWT.require(algorithm) .withClaim(&quot;userName&quot;, userName) .build(); DecodedJWT jwt &#x3D; verifier.verify(token); result.put(&quot;isSuccess&quot;, true); result.put(&quot;exception&quot;, null); &#125; catch (Exception exception) &#123; result.put(&quot;isSuccess&quot;, false); result.put(&quot;exception&quot;, exception); &#125; return result; &#125;&#125; 3、使用12345678910111213141516@ApiOperation(value &#x3D; &quot;浏览器点击登录&quot;)@ApiImplicitParam(name &#x3D; &quot;user&quot;, value &#x3D; &quot;用户实体&quot;, required &#x3D; true, paramType &#x3D; &quot;User&quot;)@PostMapping(&quot;&#x2F;login&quot;)public R login(@RequestBody User user) &#123; log.debug(&quot;------浏览器点击登录------&quot;); String userName &#x3D; user.getUsername(); String passWord &#x3D; user.getPassword(); User u &#x3D; this.userService.getUser(userName); String passWordSalt &#x3D; MD5.md5Salt(passWord, userName); if (u !&#x3D; null &amp;&amp; u.getPassword().equals(passWordSalt)) &#123; String token &#x3D; JwtUtils.sign(userName, passWordSalt); return R.ok(R.SUCCESS, R.MSG_SUCCESS, token); &#125; else &#123; return R.error(R.MSG_LOGIN_ERROR); &#125;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://www.lida1024.top/tags/JWT/"}]},{"title":"Spring Boot 两种部署到服务器的方式","slug":"Spring-Boot-两种部署到服务器的方式","date":"2019-11-19T00:46:00.000Z","updated":"2020-04-10T03:43:34.130Z","comments":true,"path":"2019/11/19/Spring-Boot-两种部署到服务器的方式/","link":"","permalink":"http://www.lida1024.top/2019/11/19/Spring-Boot-%E4%B8%A4%E7%A7%8D%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"jar包(官方推荐)jar包方式启动，也就是使用spring boot内置的tomcat运行。服务器上面只要你配置了jdk1.8及以上，就ok。不需要外置tomcat 1.打成jar包2.将jar包放到任意目录执行下面的命令 123$ nohup java -jar test.jar &gt;temp.txt &amp;&#x2F;&#x2F;这种方法会把日志文件输入到你指定的文件中，没有则会自动创建。进程会在后台运行。 3.放开端口阿里云服务器需要放开对应的端口添加安全组：我的项目中配置的启动端口是18080，故这里需要放开18080端口，才能访问 war包传统的部署方式：将项目打成war包，放入tomcat 的webapps目录下面，启动tomcat，即可访问。 开发环境：jdk1.8 + IDEA 下面搭建一个demo演示如何打war包部署并且如何访问：spring boot + maven 1.新建项目这里我们默认打成jar包，不用修改。 2.修改启动Application文件项目新建完成后，修改启动Application文件继承SpringBootServletInitializer,实现configure方法 1234567891011121314151617181920@SpringBootApplication@RestControllerpublic class Demo1Application extends SpringBootServletInitializer &#123; &#x2F;&#x2F; 用来测试访问 @RequestMapping(&quot;&#x2F;&quot;) public String home() &#123; return &quot;hello 朋友&quot;; &#125; public static void main(String[] args) &#123; SpringApplication.run(Demo1Application.class, args); &#125; &#x2F;&#x2F; 继承SpringBootServletInitializer 实现configure 方便打war 外部服务器部署。 @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(Demo1Application.class); &#125;&#125; 3.修改pom.xml1&lt;packaging&gt;war&lt;&#x2F;packaging&gt; 完整pom.xml代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;groupId&gt;com.example&lt;&#x2F;groupId&gt; &lt;artifactId&gt;demo1&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt; &lt;!-- 这里打成war包 若打jar，需将war改为jar --&gt; &lt;packaging&gt;war&lt;&#x2F;packaging&gt; &lt;name&gt;demo1&lt;&#x2F;name&gt; &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt; &lt;&#x2F;parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt; &lt;&#x2F;properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;scope&gt;runtime&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;scope&gt;test&lt;&#x2F;scope&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;build&gt; &lt;finalName&gt;demo1&lt;&#x2F;finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt; &lt;&#x2F;plugin&gt; &lt;&#x2F;plugins&gt; &lt;&#x2F;build&gt;&lt;&#x2F;project&gt; 4.打包这里可以直接到项目根目录下面：运行 maven package命令，打包。 我这里直接使用idea打包，如下图：5.将war放入外部tomcat的webapps目录下6.启动tomcat 小结1.对比两种打包方式jar更加简单，方便。具体使用哪种方式，应视应用场景而定。 2.注意再说一次，将项目打成war包，部署到外部的tomcat中，这个时候，不能直接访问spring boot 项目中配置文件配置的端口。application.yml中配置的server.port配置的是spring boot内置的tomcat的端口号, 打成war包部署在独立的tomcat上之后, 你配置的server.port是不起作用的。一定要注意这一点！！其实我们从tomcat的启动界面，已经可以看出，是启动的哪个端口：很明显，日志告诉我们，我们应该访问8080端口。下图是使用spring boot 内置tomcat启动日志，可以看出配置的server.port是生效了的！","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://www.lida1024.top/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"Consul学习","slug":"Consul学习","date":"2019-11-19T00:43:00.000Z","updated":"2020-04-11T00:27:51.902Z","comments":true,"path":"2019/11/19/Consul学习/","link":"","permalink":"http://www.lida1024.top/2019/11/19/Consul%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"服务注册与服务发现是在分布式服务架构中常常会涉及到的东西，业界常用的服务注册与服务发现工具有 ZooKeeper、etcd、Consul 和 Eureka。Consul 的主要功能有服务发现、健康检查、KV存储、安全服务沟通和多数据中心。Consul 与其他几个工具的区别可以在这里查看 Consul vs. Other Software。##为什么需要有服务注册与服务发现？假设在分布式系统中有两个服务 Service-A （下文以“S-A”代称）和 Service-B（下文以“S-B”代称），当 S-A 想调用 S-B 时，我们首先想到的时直接在 S-A 中请求 S-B 所在服务器的 IP 地址和监听的端口，这在服务规模很小的情况下是没有任何问题的，但是在服务规模很大每个服务不止部署一个实例的情况下是存在一些问题的，比如 S-B 部署了三个实例 S-B-1、S-B-2 和 S-B-3，这时候 S-A 想调用 S-B 该请求哪一个服务实例的 IP 呢？还是将3个服务实例的 IP 都写在 S-A 的代码里，每次调用 S-B 时选择其中一个 IP？这样做显得很不灵活，这时我们想到了 Nginx 刚好就能很好的解决这个问题，引入 Nginx 后现在的架构变成了如下图这样： 引入 Nginx 后就解决了 S-B 部署多个实例的问题，还做了 S-B 实例间的负载均衡。但现在的架构又面临了新的问题，分布式系统往往要保证高可用以及能做到动态伸缩，在引入 Nginx 的架构中，假如当 S-B-1 服务实例不可用时，Nginx 仍然会向 S-B-1 分配请求，这样服务就不可用，我们想要的是 S-B-1 挂掉后 Nginx 就不再向其分配请求，以及当我们新部署了 S-B-4 和 S-B-5 后，Nginx 也能将请求分配到 S-B-4 和 S-B-5，Nginx 要做到这样就要在每次有服务实例变动时去更新配置文件再重启 Nginx。这样看似乎用了 Nginx 也很不舒服以及还需要人工去观察哪些服务有没有挂掉，Nginx 要是有对服务的健康检查以及能够动态变更服务配置就是我们想要的工具，这就是服务注册与服务发现工具的用处。下面是引入服务注册与服务发现工具后的架构图： 在这个架构中： 首先 S-B 的实例启动后将自身的服务信息（主要是服务所在的 IP 地址和端口号）注册到注册工具中。不同注册工具服务的注册方式各不相同，后文会讲 Consul 的具体注册方式。 服务将服务信息注册到注册工具后，注册工具就可以对服务做健康检查，以此来确定哪些服务实例可用哪些不可用。 S-A 启动后就可以通过服务注册和服务发现工具获取到所有健康的 S-B 实例的 IP 和端口，并将这些信息放入自己的内存中，S-A 就可用通过这些信息来调用 S-B。 S-A 可以通过监听（Watch）注册工具来更新存入内存中的 S-B 的服务信息。比如 S-B-1 挂了，健康检查机制就会将其标为不可用，这样的信息变动就被 S-A 监听到了，S-A 就更新自己内存中 S-B-1 的服务信息。 所以务注册与服务发现工具除了服务本身的服务注册和发现功能外至少还需要有健康检查和状态变更通知的功能。 Consul内部原理Consul 作为一种分布式服务工具，为了避免单点故障常常以集群的方式进行部署，在 Consul 集群的节点中分为 Server 和 Client 两种节点（所有的节点也被称为Agent），Server 节点保存数据，Client 节点负责健康检查及转发数据请求到 Server；Server 节点有一个 Leader 节点和多个 Follower 节点，Leader 节点会将数据同步到 Follower 节点，在 Leader 节点挂掉的时候会启动选举机制产生一个新的 Leader。 Client 节点很轻量且无状态，它以 RPC 的方式向 Server 节点做读写请求的转发，此外也可以直接向 Server 节点发送读写请求。下面是 Consul 的架构图： 首先Consul支持多数据中心，在上图中有两个DataCenter，他们通过Internet互联，同时请注意为了提高通信效率，只有Server节点才加入跨数据中心的通信。 在单个数据中心中，Consul分为Client和Server两种节点（所有的节点也被称为Agent），Server节点保存数据，Client负责健康检查及转发数据请求到Server；Server节点有一个Leader和多个Follower，Leader节点会将数据同步到Follower，Server的数量推荐是3个或者5个，在Leader挂掉的时候会启动选举机制产生一个新的Leader。 集群内的Consul节点通过gossip协议（流言协议）维护成员关系，也就是说某个节点了解集群内现在还有哪些节点，这些节点是Client还是Server。单个数据中心的流言协议同时使用TCP和UDP通信，并且都使用8301端口。跨数据中心的流言协议也同时使用TCP和UDP通信，端口使用8302。 集群内数据的读写请求既可以直接发到Server，也可以通过Client使用RPC转发到Server，请求最终会到达Leader节点，在允许数据轻微陈旧的情况下，读请求也可以在普通的Server节点完成，集群内数据的读写和复制都是通过TCP的8300端口完成。 Consul 的主要特点Service Discovery : 服务注册与发现，Consul 的客户端可以做为一个服务注册到 Consul，也可以通过 Consul 来查找特定的服务提供者，并且根据提供的信息进行调用。 Health Checking: Consul 客户端会定期发送一些健康检查数据和服务端进行通讯，判断客户端的状态、内存使用情况是否正常，用来监控整个集群的状态，防止服务转发到故障的服务上面。 KV Store: Consul 还提供了一个容易使用的键值存储。这可以用来保持动态配置，协助服务协调、建立 Leader 选举，以及开发者想构造的其它一些事务。 Secure Service Communication: Consul 可以为服务生成分布式的 TLS 证书，以建立相互的 TLS 连接。 可以使用 intentions 定义允许哪些服务进行通信。 可以使用 intentions 轻松管理服务隔离，而不是使用复杂的网络拓扑和静态防火墙规则。 Multi Datacenter: Consul 支持开箱即用的多数据中心，这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域。 Consul 角色 Server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其它数据中心通讯。 每个数据中心的 Server 数量推荐为 3 个或是 5 个。 Client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群。 Consul 旨在对 DevOps 社区和应用程序开发人员友好，使其成为现代、弹性基础架构的理想选择。 Consul 的调用过程 1、当 Producer 启动的时候，会向 Consul 发送一个 post 请求，告诉 Consul 自己的 IP 和 Port； 2、Consul 接收到 Producer 的注册后，每隔 10s（默认）会向 Producer 发送一个健康检查的请求，检验 Producer 是否健康； 3、当 Consumer 发送 GET 方式请求 /api/address 到 Producer 时，会先从 Consul 中拿到一个存储服务 IP 和 Port 的临时表，从表中拿到 Producer 的 IP 和 Port 后再发送 GET 方式请求 /api/address； 4、该临时表每隔 10s 会更新，只包含有通过了健康检查的 Producer。 Consul 和 eureka的对比 Consul服务发现原理 首先需要有一个正常的Consul集群，有Server，有Leader。这里在服务器Server1、Server2、Server3上分别部署了Consul Server，假设他们选举了Server2上的Consul Server节点为Leader。这些服务器上最好只部署Consul程序，以尽量维护Consul Server的稳定。 然后在服务器Server4和Server5上通过Consul Client分别注册Service A、B、C，这里每个Service分别部署在了两个服务器上，这样可以避免Service的单点问题。服务注册到Consul可以通过HTTP API（8500端口）的方式，也可以通过Consul配置文件的方式。Consul Client可以认为是无状态的，它将注册信息通过RPC转发到Consul Server，服务信息保存在Server的各个节点中，并且通过Raft实现了强一致性。 最后在服务器Server6中Program D需要访问Service B，这时候Program D首先访问本机Consul Client提供的HTTP API，本机Client会将请求转发到Consul Server，Consul Server查询到Service B当前的信息返回，最终Program D拿到了Service B的所有部署的IP和端口，然后就可以选择Service B的其中一个部署并向其发起请求了。如果服务发现采用的是DNS方式，则Program D中直接使用Service B的服务发现域名，域名解析请求首先到达本机DNS代理，然后转发到本机Consul Client，本机Client会将请求转发到Consul Server，Consul Server查询到Service B当前的信息返回，最终Program D拿到了Service B的某个部署的IP和端口。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"Consul","slug":"Consul","permalink":"http://www.lida1024.top/tags/Consul/"}]},{"title":"微服务常见的认证方案","slug":"微服务常见的认证方案","date":"2019-11-19T00:40:00.000Z","updated":"2020-04-10T06:38:43.593Z","comments":true,"path":"2019/11/19/微服务常见的认证方案/","link":"","permalink":"http://www.lida1024.top/2019/11/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88/","excerpt":"","text":"分布式Session传统的单体应用的session，在Spring cloud微服务架构下，可以采用分布式session机制，可以将用户的认证信息存储在共享存储（如redis）中，用户会话作为key实现简单的分布式哈希映射，当用户访问微服务时，用户数据可以从共享存储中获取。Spring Session对分布式Session提供了支持，也与Spring Boot/Cloud无缝集成。 API Tokens随着 Restful API、微服务的兴起，基于 Token 的认证现在已经相当普遍了。 Token一般会包含用户的相关信息，其它微服务可以从Token里提取出用户、权限等信息完成鉴权。 基于Token认证的典型流程： 用户使用包含用户名和密码的credential从客户端发起资源请求。 后端接受请求，通过授权中心，生产有效token字符串，返回给客户端。 客户端获得token后，再次发出资源请求。 后端接受带token的请求，通过授权中心，获取相关资源，返回给客户端。 优点： 服务端无状态：服务端不需要存储Session，因为Token已携带用户的相关信息 性能好：校验Token不需要访问远程服务或数据库 支持移动端 支持跨程序、跨域调用 缺点： 每次用户请求需要携带有效token，与Auth服务进行交互验证 Auth服务可能需要处理大量的生产token的操作，可能存在性能问题 基于Token的认证方案，业界推荐使用 JSON Web Tokens（JWT），它足够简单且支持程度也比较好","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"Token","slug":"Token","permalink":"http://www.lida1024.top/tags/Token/"}]},{"title":"Spring Cloud Feign使用详解","slug":"Spring-Cloud-Feign使用详解","date":"2019-11-19T00:35:00.000Z","updated":"2020-04-10T03:55:14.547Z","comments":true,"path":"2019/11/19/Spring-Cloud-Feign使用详解/","link":"","permalink":"http://www.lida1024.top/2019/11/19/Spring-Cloud-Feign%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"背景Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。Feign提供了HTTP请求的模板，通过编写简单的接口和插入注解，就可以定义好HTTP请求的参数、格式、地址等信息。而Feign则会完全代理HTTP请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理。Feign整合了Ribbon和Hystrix(关于Hystrix我们后面再讲)，可以让我们不再需要显式地使用这两个组件。 特点总起来说，Feign具有如下特性： 可插拔的注解支持，包括Feign注解和JAX-RS注解; 支持可插拔的HTTP编码器和解码器; 支持Hystrix和它的Fallback; 支持Ribbon的负载均衡; 支持HTTP请求和响应的压缩。 FeignClient注解的一些属性 快速开始1.引入Feign1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 2.@FeignClient注解SpringbootApplication启动类加上@FeignClient注解 12345678910111213141516import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableEurekaClient@EnableFeignClientspublic class ServiceFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceFeignApplication.class, args); &#125;&#125;&#x2F;&#x2F;@EnableDiscoveryClient 和@EnableEurekaClient是等效的 3.yaml配置123456789eureka: client: serviceUrl: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;server: port: 8765spring: application: name: service-feign 4.Feign的使用feign接口 123456@FeignClient(value &#x3D; &quot;service-hi&quot;)public interface SchedualServiceHi &#123; @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;, method &#x3D; RequestMethod.GET) String sayHiFromClientOne(@RequestParam(&quot;name&quot;) String name);&#125; 访问接口 123456789101112@RestControllerpublic class HiController &#123; @Autowired SchedualServiceHi schedualServiceHi; @GetMapping(value &#x3D; &quot;&#x2F;hi&quot;) public String sayHi(@RequestParam String name)&#123; return schedualServiceHi.sayHiFromClientOne(name); &#125;&#125; 实战1.创建项目创建一个Maven项目feign，新建2个module service-hi和service-feign 2.service-hi pom 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; yml 1234567891011server: port: 8763spring: application: name: service-hieureka: client: serviceUrl: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F; ServiceHiApplication 12345678910111213141516171819@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient@RestControllerpublic class ServiceHiApplication &#123; public static void main(String[] args) &#123; SpringApplication.run( ServiceHiApplication.class, args ); &#125; @Value(&quot;$&#123;server.port&#125;&quot;) String port; @RequestMapping(&quot;&#x2F;hi&quot;) public String home(@RequestParam(value &#x3D; &quot;name&quot;, defaultValue &#x3D; &quot;forezp&quot;) String name) &#123; return &quot;hi &quot; + name + &quot; ,i am from port:&quot; + port; &#125;&#125; 3.service-feignpom 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; yml 123456789eureka: client: serviceUrl: defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;server: port: 8765spring: application: name: service-feign ServiceFeignApplication 1234567891011@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient@EnableFeignClientspublic class ServiceFeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceFeignApplication.class, args); &#125;&#125; SchedualServiceHi 123456@FeignClient(value &#x3D; &quot;service-hi&quot;)public interface SchedualServiceHi &#123; @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;, method &#x3D; RequestMethod.GET) String sayHiFromClientOne(@RequestParam(&quot;name&quot;) String name);&#125; HiController 123456789101112@RestControllerpublic class HiController &#123; @Autowired SchedualServiceHi schedualServiceHi; @GetMapping(value &#x3D; &quot;&#x2F;hi&quot;) public String sayHi(@RequestParam String name)&#123; return schedualServiceHi.sayHiFromClientOne(name); &#125;&#125; 测试启动eureka访问http://localhost:8761/启动service-hi刷新http://localhost:8761/访问service-hihttp://localhost:8763/hi?name=kobe启动service-feign刷新http://localhost:8761/同过feign访问接口http://localhost:8765/hi?name=KG可以看到去到了service-hi服务，端口8763","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://www.lida1024.top/tags/SpringCloud/"}]},{"title":"java线程创建全家桶","slug":"Java线程创建全家桶","date":"2019-09-16T05:52:00.000Z","updated":"2020-04-11T00:49:45.703Z","comments":true,"path":"2019/09/16/Java线程创建全家桶/","link":"","permalink":"http://www.lida1024.top/2019/09/16/Java%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%85%A8%E5%AE%B6%E6%A1%B6/","excerpt":"","text":"继承Thread类12345678910111213141516171819&#x2F;&#x2F;继承Threadpublic class ExtendThread extends Thread&#123; &#x2F;&#x2F;线程执行体 @Override public void run() &#123; &#x2F;&#x2F;do something System.out.println(&quot;继承Thread创建线程&quot;); &#x2F;&#x2F;无返回值 &#125;&#125;public class ThreadCreateDemo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;创建一个线程 ExtendThread extendThread &#x3D; new ExtendThread(); &#x2F;&#x2F;调用start方法启动线程 extendThread.start(); &#x2F;&#x2F;没有返回值 &#125;&#125; 使用继承Thread类的方法来创建线程类时候，多个线程之间是无法共享线程类的实例变量的。 实现Runnable接口覆写Runnable接口实现多线程可以避免单继承局限， 当子类实现Runnable接口，此时子类和Thread的代理模式（子类负责真实业务的操作，thread负责资源调度与线程创建辅助真实业务）。 123456789101112131415161718&#x2F;&#x2F;实现Runnable接口public class ImplRunnable implements Runnable &#123; &#x2F;&#x2F;线程实行体 @Override public void run() &#123; &#x2F;&#x2F;do something System.out.println(&quot;实现Runnable创建线程&quot;); &#x2F;&#x2F;没有返回值 &#125;&#125;public class ThreadCreateDemo &#123; public static void main(String[] args) &#123; ImplRunnable implRunnable &#x3D; new ImplRunnable(); Thread thread &#x3D; new Thread(implRunnable); &#x2F;&#x2F;启动线程 thread.start(); &#125;&#125; Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run方法仅仅作为线程的执行体，而实际的线程对象依旧是Thread实例，只是该Thread线程负责执行器target的方法。 覆写Callable接口1234567891011121314151617181920&#x2F;&#x2F;实现Callable返回值类型为Integer类型public class ImplCallable implements Callable&lt;Integer&gt; &#123; &#x2F;&#x2F;该call()方法将作为线程执行体，并且有返回值 @Override public Integer call() throws Exception &#123; &#x2F;&#x2F;do something System.out.println(&quot;实现Callable接口创建线程，返回类型为Integer类型&quot;); return 999; &#125;&#125;public class ThreadCreateDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; Callable&lt;Integer&gt; callable &#x3D; new ImplCallable(); FutureTask&lt;Integer&gt; futureTask &#x3D; new FutureTask&lt;&gt;(callable); Thread thread &#x3D; new Thread(futureTask); thread.start(); &#x2F;&#x2F;获取返回值futureTask.get() System.out.println(futureTask.get()); &#125;&#125; Callable接口有泛型限制，Callable接口里的泛型形参类型与call方法返回值类型相同，而且Callable接口是函数式接口，因此可以使用Lambda表达式创建Callable对象。 三种方式的对比通过继承Thread类或者实现Runnable接口、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callabl接口里定义的方法返回值，可以声明抛出异常而已。因此将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。 采用实现Runnable、Callable接口的方式创建线程的优缺点优点线程类只是实现了Runnable或者Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想。缺点编程稍微复杂一些，如果需要访问当前线程，则必须使用Thread.currentThread()方法 采用继承Thread类的方式创建线程的优缺点缺点因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。 优点编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获取当前线程","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"http://www.lida1024.top/tags/Thread/"}]},{"title":"Java下载文件的几种方式 ","slug":"Java下载文件的几种方式","date":"2019-09-12T01:54:00.000Z","updated":"2020-04-11T00:49:51.498Z","comments":true,"path":"2019/09/12/Java下载文件的几种方式/","link":"","permalink":"http://www.lida1024.top/2019/09/12/Java%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"以流的方式下载1234567891011121314151617181920212223242526272829public HttpServletResponse download(String path, HttpServletResponse response) &#123; try &#123; &#x2F;&#x2F; path是指欲下载的文件的路径。 File file &#x3D; new File(path); &#x2F;&#x2F; 取得文件名。 String filename &#x3D; file.getName(); &#x2F;&#x2F; 取得文件的后缀名。 String ext &#x3D; filename.substring(filename.lastIndexOf(&quot;.&quot;) + 1).toUpperCase(); &#x2F;&#x2F; 以流的形式下载文件。 InputStream fis &#x3D; new BufferedInputStream(new FileInputStream(path)); byte[] buffer &#x3D; new byte[fis.available()]; fis.read(buffer); fis.close(); &#x2F;&#x2F; 清空response response.reset(); &#x2F;&#x2F; 设置response的Header response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename&#x3D;&quot; + new String(filename.getBytes())); response.addHeader(&quot;Content-Length&quot;, &quot;&quot; + file.length()); OutputStream toClient &#x3D; new BufferedOutputStream(response.getOutputStream()); response.setContentType(&quot;application&#x2F;octet-stream&quot;); toClient.write(buffer); toClient.flush(); toClient.close(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); &#125; return response; &#125; 下载本地文件1234567891011121314151617181920public void downloadLocal(HttpServletResponse response) throws FileNotFoundException &#123; &#x2F;&#x2F; 下载本地文件 String fileName &#x3D; &quot;Operator.doc&quot;.toString(); &#x2F;&#x2F; 文件的默认保存名 &#x2F;&#x2F; 读到流中 InputStream inStream &#x3D; new FileInputStream(&quot;c:&#x2F;Operator.doc&quot;);&#x2F;&#x2F; 文件的存放路径 &#x2F;&#x2F; 设置输出的格式 response.reset(); response.setContentType(&quot;bin&quot;); response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;\\&quot;&quot; + fileName + &quot;\\&quot;&quot;); &#x2F;&#x2F; 循环取出流中的数据 byte[] b &#x3D; new byte[100]; int len; try &#123; while ((len &#x3D; inStream.read(b)) &gt; 0) response.getOutputStream().write(b, 0, len); inStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 下载网络文件12345678910111213141516171819202122232425public void downloadNet(HttpServletResponse response) throws MalformedURLException &#123; &#x2F;&#x2F; 下载网络文件 int bytesum &#x3D; 0; int byteread &#x3D; 0; URL url &#x3D; new URL(&quot;windine.blogdriver.com&#x2F;logo.gif&quot;); try &#123; URLConnection conn &#x3D; url.openConnection(); InputStream inStream &#x3D; conn.getInputStream(); FileOutputStream fs &#x3D; new FileOutputStream(&quot;c:&#x2F;abc.gif&quot;); byte[] buffer &#x3D; new byte[1204]; int length; while ((byteread &#x3D; inStream.read(buffer)) !&#x3D; -1) &#123; bytesum +&#x3D; byteread; System.out.println(bytesum); fs.write(buffer, 0, byteread); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 支持在线打开的方式1234567891011121314151617181920212223242526public void downLoad(String filePath, HttpServletResponse response, boolean isOnLine) throws Exception &#123; File f &#x3D; new File(filePath); if (!f.exists()) &#123; response.sendError(404, &quot;File not found!&quot;); return; &#125; BufferedInputStream br &#x3D; new BufferedInputStream(new FileInputStream(f)); byte[] buf &#x3D; new byte[1024]; int len &#x3D; 0; response.reset(); &#x2F;&#x2F; 非常重要 if (isOnLine) &#123; &#x2F;&#x2F; 在线打开方式 URL u &#x3D; new URL(&quot;file:&#x2F;&#x2F;&#x2F;&quot; + filePath); response.setContentType(u.openConnection().getContentType()); response.setHeader(&quot;Content-Disposition&quot;, &quot;inline; filename&#x3D;&quot; + f.getName()); &#x2F;&#x2F; 文件名应该编码成UTF-8 &#125; else &#123; &#x2F;&#x2F; 纯下载方式 response.setContentType(&quot;application&#x2F;x-msdownload&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename&#x3D;&quot; + f.getName()); &#125; OutputStream out &#x3D; response.getOutputStream(); while ((len &#x3D; br.read(buf)) &gt; 0) out.write(buf, 0, len); br.close(); out.close(); &#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"File","slug":"File","permalink":"http://www.lida1024.top/tags/File/"}]},{"title":"SpringMVC请求参数获取的几种方法","slug":"SpringMVC请求参数获取的几种方法","date":"2019-08-15T03:08:00.000Z","updated":"2020-04-10T03:36:42.771Z","comments":true,"path":"2019/08/15/SpringMVC请求参数获取的几种方法/","link":"","permalink":"http://www.lida1024.top/2019/08/15/SpringMVC%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"SpringMVC请求参数获取的几种方法 通过@PathVariabl获取路径中的参数12345678@RequestMapping(value&#x3D;&quot;user&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&quot;,method&#x3D;RequestMethod.GET)public String printMessage1(@PathVariable String id,@PathVariable String name, ModelMap model) &#123; System.out.println(id); System.out.println(name); model.addAttribute(&quot;message&quot;, &quot;111111&quot;); return &quot;users&quot;;&#125; 例如，访问user/123/lei路径时，执行以上方法，其中，参数id=123，name=lei @ModelAttribute获取POST请求的FORM表单数据表单如下 12345&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;hao.do&quot;&gt; a: &lt;input id&#x3D;&quot;a&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;a&quot;&#x2F;&gt; b: &lt;input id&#x3D;&quot;b&quot; type&#x3D;&quot;text&quot; name&#x3D;&quot;b&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit&quot; &#x2F;&gt;&lt;&#x2F;form&gt; Java Pojo如下 1234public class Pojo&#123; private String a; private int b;&#125; Java Controller如下 12345@RequestMapping(method &#x3D; RequestMethod.POST) public String processSubmit(@ModelAttribute(&quot;pojo&quot;) Pojo pojo) &#123; return &quot;helloWorld&quot;; &#125; @RequestBody获取POST请求的FORM表单数据@RequestBody接收的是一个Json对象的字符串，而不是一个Json对象。然而在ajax请求往往传的都是Json对象，后来发现用 JSON.stringify(data)的方式就能将对象变成字符串。同时ajax请求的时候也要指定dataType: &quot;json&quot;,contentType:&quot;application/json&quot;这样就可以轻易的将一个对象或者List传到Java端，使用@RequestBody即可绑定对象或者List. js代码 123456789101112131415161718&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; $(document).ready(function()&#123; var saveDataAry&#x3D;[]; var data1&#x3D;&#123;&quot;userName&quot;:&quot;test&quot;,&quot;address&quot;:&quot;gz&quot;&#125;; var data2&#x3D;&#123;&quot;userName&quot;:&quot;ququ&quot;,&quot;address&quot;:&quot;gr&quot;&#125;; saveDataAry.push(data1); saveDataAry.push(data2); $.ajax(&#123; type:&quot;POST&quot;, url:&quot;user&#x2F;saveUser&quot;, dataType:&quot;json&quot;, contentType:&quot;application&#x2F;json&quot;, data:JSON.stringify(saveData), success:function(data)&#123; &#125; &#125;); &#125;); java代码 12345@RequestMapping(value &#x3D; &quot;saveUser&quot;, method &#x3D; &#123;RequestMethod.POST &#125;&#125;) @ResponseBody public void saveUser(@RequestBody List&lt;User&gt; users) &#123; userService.batchSave(users); &#125; @ModelAttribute和@RequestBody注解不同之处在于@ModelAttribute注解可以在前端直接获取返回值 123456789@Controllerpublic class Hello2ModelController extends BaseController &#123; @RequestMapping(value &#x3D; &quot;&#x2F;helloWorld2&quot;) public String helloWorld(@ModelAttribute(&quot;myUser&quot;) User user) &#123; user.setName(&quot;老王&quot;); return &quot;helloWorld&quot;; &#125; &#125; model中key为myUser ,前台可以直接通过${myUser.xx}获取user相应属性 直接用HttpServletRequest获取12345@RequestMapping(method &#x3D; RequestMethod.GET) public String get(HttpServletRequest request, HttpServletResponse response) &#123; System.out.println(request.getParameter(&quot;a&quot;)); return &quot;helloWorld&quot;; &#125; 用注解@RequestParam绑定请求参数用注解@RequestParam绑定请求参数a到变量a 当请求参数a不存在时会有异常发生,可以通过设置属性required=false解决, 例如: @RequestParam(value=&quot;a&quot;, required=false) Controller如下 12345@RequestMapping(value &#x3D; &quot;&#x2F;requestParam&quot;, method &#x3D; RequestMethod.GET) public String setupForm(@RequestParam(&quot;a&quot;) String a, ModelMap model) &#123; System.out.println(a); return &quot;helloWorld&quot;;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.lida1024.top/tags/Spring/"}]},{"title":"SpringBoot使用Undertow代替tomcat","slug":"SpringBoot使用Undertow代替tomcat","date":"2019-08-14T07:56:00.000Z","updated":"2020-04-10T03:44:09.917Z","comments":true,"path":"2019/08/14/SpringBoot使用Undertow代替tomcat/","link":"","permalink":"http://www.lida1024.top/2019/08/14/SpringBoot%E4%BD%BF%E7%94%A8Undertow%E4%BB%A3%E6%9B%BFtomcat/","excerpt":"","text":"Undertow 是基于java nio的web服务器，应用比较广泛，内置提供的PathResourceManager，可以用来直接访问文件系统；如果你有文件需要对外提供访问，除了ftp,nginx等，undertow 也是一个不错的选择，作为java开发，服务搭建非常简便 Undertow使用依赖spring boot内嵌容器默认为tomcat，想要换成undertow，非常容易，只需修改spring-boot-starter-web依赖，移除tomcat的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt; &lt;&#x2F;dependency&gt; 然后，添加undertow依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; 这样即可，使用默认参数启动undertow服务器。如果需要修改undertow参数，继续往下看。 undertow的参数设置：12345678910server: port: 8084 http2: enabled: true undertow: io-threads: 16 worker-threads: 256 buffer-size: 1024 buffers-per-region: 1024 direct-buffers: true io-threads：IO线程数, 它主要执行非阻塞的任务，它们会负责多个连接，默认设置每个CPU核心一个线程，不可设置过大，否则启动项目会报错：打开文件数过多。 worker-threads：阻塞任务线程池，当执行类似servlet请求阻塞IO操作，undertow会从这个线程池中取得线程。它的值取决于系统线程执行任务的阻塞系数，默认值是 io-threads*8 以下配置会影响buffer，这些buffer会用于服务器连接的IO操作，有点类似netty的池化内存管理。 buffer-size：每块buffer的空间大小，越小的空间被利用越充分，不要设置太大，以免影响其他应用，合适即可 buffers-per-region：每个区分配的buffer数量，所以pool的大小是buffer-size * buffers-per-region direct-buffers：是否分配的直接内存(NIO直接分配的堆外内存) File Server12345678910111213141516import java.io.File;import io.undertow.Handlers;import io.undertow.Undertow;import io.undertow.server.handlers.resource.PathResourceManager;public class FileServer &#123; public static void main(String[] args) &#123; File file &#x3D; new File(&quot;&#x2F;&quot;); Undertow server &#x3D; Undertow.builder().addHttpListener(8080, &quot;localhost&quot;) .setHandler(Handlers.resource(new PathResourceManager(file.toPath(), 100)) .setDirectoryListingEnabled(true)) .build(); server.start(); &#125;&#125; 好了！运行main函数，打开浏览器访问 http://localhost:8080","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Container","slug":"Dev/Container","permalink":"http://www.lida1024.top/categories/Dev/Container/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.lida1024.top/tags/SpringBoot/"}]},{"title":"Spring Boot - Undertow容器启动","slug":"Spring-Boot-Undertow容器启动","date":"2019-08-14T07:00:00.000Z","updated":"2020-04-10T03:43:45.599Z","comments":true,"path":"2019/08/14/Spring-Boot-Undertow容器启动/","link":"","permalink":"http://www.lida1024.top/2019/08/14/Spring-Boot-Undertow%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8/","excerpt":"","text":"Undertow简介 Undertow 是红帽公司开发的一款基于 NIO 的高性能 Web 嵌入式服务器 Untertow 的特点：轻量级：它是一个 Web 服务器，但不像传统的 Web 服务器有容器概念，它由两个核心 Jar 包组成，加载一个 Web 应 用可以小于 10MB 内存 Servlet3.1 支持：它提供了对 Servlet3.1 的支持 WebSocket 支持：对 Web Socket 完全支持，用以满足 Web 应用巨大数量的客户端 嵌套性：它不需要容器，只需通过 API 即可快速搭建 Web 服务器 默认情况下 Spring Cloud 使用 Tomcat 作为内嵌 Servlet 容器，可启动一个 Tomcat 的 Spring Boot 程序与一个 Undertow 的 Spring Boot 程序，通过 VisualVM 工具进行比较，可看到 Undertow 性能优于 Tomcat 使用 Undertow添加依赖1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt; &lt;&#x2F;exclusion&gt; &lt;&#x2F;exclusions&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 支持 HTTP21234567891011&#x2F;&#x2F; 在@Configuration的类中添加@bean@BeanUndertowEmbeddedServletContainerFactory embeddedServletContainerFactory() &#123; UndertowEmbeddedServletContainerFactory factory &#x3D; new UndertowEmbeddedServletContainerFactory(); &#x2F;&#x2F; 这里也可以做其他配置 factory.addBuilderCustomizers(builder -&gt; builder.setServerOption(UndertowOptions.ENABLE_HTTP2, true)); return factory;&#125; 配置 Undertow1234567891011121314151617181920212223# Undertow 日志存放目录server.undertow.accesslog.dir# 是否启动日志server.undertow.accesslog.enabled&#x3D;false # 日志格式server.undertow.accesslog.pattern&#x3D;common# 日志文件名前缀server.undertow.accesslog.prefix&#x3D;access_log# 日志文件名后缀server.undertow.accesslog.suffix&#x3D;log# HTTP POST请求最大的大小server.undertow.max-http-post-size&#x3D;0 # 设置IO线程数, 它主要执行非阻塞的任务,它们会负责多个连接, 默认设置每个CPU核心一个线程server.undertow.io-threads&#x3D;4# 阻塞任务线程池, 当执行类似servlet请求阻塞操作, undertow会从这个线程池中取得线程,它的值设置取决于系统的负载server.undertow.worker-threads&#x3D;20# 以下的配置会影响buffer,这些buffer会用于服务器连接的IO操作,有点类似netty的池化内存管理# 每块buffer的空间大小,越小的空间被利用越充分server.undertow.buffer-size&#x3D;1024# 每个区分配的buffer数量 , 所以pool的大小是buffer-size * buffers-per-regionserver.undertow.buffers-per-region&#x3D;1024# 是否分配的直接内存server.undertow.direct-buffers&#x3D;true","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.lida1024.top/tags/SpringBoot/"}]},{"title":"前后端分离后的优雅部署","slug":"后端分离后的优雅部署","date":"2019-08-12T01:34:00.000Z","updated":"2020-04-10T03:54:47.672Z","comments":true,"path":"2019/08/12/后端分离后的优雅部署/","link":"","permalink":"http://www.lida1024.top/2019/08/12/%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%90%8E%E7%9A%84%E4%BC%98%E9%9B%85%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Web项目部署容器的选取目前常用的部署Web项目的容器用Tomcat、Apache、Nginx等，那我们前后端分离后的前端Html静态项目到底部署在那个应用容器呢？我们先看看这几个应用容器的区别。 Nginx,Apache,Tomcat的区别： Nginx常用做静态内容服务和代理服务器，直接外来请求转发给后面的应用服务器（如tomcat）,而tomcat更多用来做一个应用容器。 Apache和nginx应该叫做HTTP Server，而tomcat是一个Application Server是一个Servlet/JSO应用的容器。 HTTP Server访问服务器上存储的资源（HTML文件，图片文件等），HTTP Server是中只是把服务器上的文件如实通过HTTP协议传输给客户端。 Application Server（应用服务器）往往是运行在HTTP Server的背后并执行应用，将动态的内容转化为静态的内容之后，通过HTTP Server分发到客户端。 Apache是同步多进程模型，一个连接对应一个进程，而nginx是一步的，多个连接（万级别）可以对应一个进程。nginx轻量级，抗并发，处理静态文件好。 根据对比，我们不难发现Nginx是较好的选择，它是由俄罗斯人（伊戈尔·赛索耶夫）开发的一款高性能的HTTP和反向代理web服务器。本身是轻量级、抗并发、能实现万级的连接等。同时它也是一个反向代理服务器。因此，我们不仅可以用它部署静态的html应用，还可以实现域名及访问地址的代理。 Nginx部署前端Web项目Nginx的安装这里不做介绍，只说配置及部署相关内容。首先进入linux系统中Nginx的安装录的conf目录下，找到nginx.config配置文件，vim nginx.config进入编辑模式，在http下的server对应的同级编辑或添加如下代码，然后在root对应的目录下上传对应的html今天项目文件。注意：这里上传的如果是压缩包就需要解压，目录下要有index.html。 12345678server &#123; listen 80; server_name www.xxxx.com; location &#x2F; &#123; root html&#x2F;; #html访问路径 index index.html; &#125;&#125; 但我们的实际项目中，经常有多个Web端需要部署，如前面图中的例子，Web端有PC商城和Web后台系统，甚至可能更多，这些多个Web静态项目我们都放在nginx的html目录下的不同文件夹里，然后通过域名或ip+port代理到对应目录。下面就是多个Web项目在Nginx里的配置。 123456789101112131415161718##商城Html页面server &#123; listen 80; server_name www.xxxx.com; location &#x2F; &#123; root html&#x2F;pc&#x2F;; #html访问路径 index index.html; &#125;&#125;##后台系统Html页面server &#123; listen 80; server_name admin.xxxx.com; location &#x2F; &#123; root html&#x2F;admin&#x2F;; #html访问路径 index index.html; &#125;&#125; 编辑完成后保存，并重启nginx服务 service nginx restart。注：server_name 这里可配置域名或ip+端口号。 后端项目的部署大家应该都知道，SpringBoot里集成了Tomcat容器，所有Springboot的项目部署，很是容易，根本不需要你还安装什么Tomcat、JBoss等应用。我们只需打成jar文件，上传到服务器，然后通过执行java -jar xxx.jar &amp;命令即可。但有没有人遇到过，你通过java -jar xxx.jar &amp;刚刚部署的服务，在你断开linux服务器的shell连接后服务就没了。大家有知道这是什么原因吗？这里给大家说说部署java jar文件命令的那点事。 java -jar xxx.jar &amp; 此命令可直接启动jar文件，是在当前会话进程中开启一个子进程来运行程序，这个子进程会随着会话进程的结束而结束。也就是说在你端口Shell连接回话结束，服务就跟着结束了。这种情况适合短时间测试用。 nohup java -jar xxx.jar &amp; 这里在说这个命令前先说两个名词，即：hangup (挂断)，终端退出时会发送 hangup 信号来通知关闭所有子进程。nohup(不挂断，忽略挂断信号) nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上”&amp;”来将命令同时放入后台运行，也可用”&gt;filename2&gt;&amp;1”来更改缺省的重定向文件名。这种情况适合在生产环境长时间运行。 在生产环境如果你只用简单的jar部署，那一定得用nohup java 命令启动应用。","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Container","slug":"Dev/Container","permalink":"http://www.lida1024.top/categories/Dev/Container/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://www.lida1024.top/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"springboot逆向工程","slug":"springboot逆向工程","date":"2019-07-27T01:45:00.000Z","updated":"2020-04-10T03:43:17.812Z","comments":true,"path":"2019/07/27/springboot逆向工程/","link":"","permalink":"http://www.lida1024.top/2019/07/27/springboot%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"通过逆向工程少写很多代码 generatorConfig.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--mysql 连接数据库jar 这里选择自己本地位置--&gt; &lt;classPathEntry location&#x3D;&quot;C:\\Users\\Administrator\\.m2\\repository\\mysql\\mysql-connector-java\\5.1.21\\mysql-connector-java-5.1.21.jar&quot; &#x2F;&gt; &lt;context id&#x3D;&quot;testTables&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name&#x3D;&quot;suppressAllComments&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass&#x3D;&quot;com.mysql.jdbc.Driver&quot; connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;oa&quot; userId&#x3D;&quot;root&quot; password&#x3D;&quot;&quot;&gt; &lt;&#x2F;jdbcConnection&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage&#x3D;&quot;com.yj.oa.project.po&quot; targetProject&#x3D;&quot;src&#x2F;test&#x2F;java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt; &lt;&#x2F;javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 如果maven工程只是单独的一个工程，targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot; 若果maven工程是分模块的工程，targetProject&#x3D;&quot;所属模块的名称&quot;，例如： targetProject&#x3D;&quot;ecps-manager-mapper&quot;，下同--&gt; &lt;sqlMapGenerator targetPackage&#x3D;&quot;mapper&quot; targetProject&#x3D;&quot;src&#x2F;test&#x2F;java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot; targetPackage&#x3D;&quot;com.yj.oa.project.mapper&quot; targetProject&#x3D;&quot;src&#x2F;test&#x2F;java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;false&quot; &#x2F;&gt; &lt;&#x2F;javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName&#x3D;&quot;t_overtimeform&quot; domainObjectName&#x3D;&quot;OvertimeForm&quot; enableCountByExample&#x3D;&quot;false&quot; enableUpdateByExample&#x3D;&quot;false&quot; enableDeleteByExample&#x3D;&quot;false&quot; enableSelectByExample&#x3D;&quot;false&quot; selectByExampleQueryId&#x3D;&quot;false&quot;&gt;&lt;&#x2F;table&gt; &lt;&#x2F;context&gt;&lt;&#x2F;generatorConfiguration&gt; pom.xml12345678910111213141516171819202122232425&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.2&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;src&#x2F;main&#x2F;resources&#x2F;generatorConfig.xml&lt;&#x2F;configurationFile&gt; &lt;verbose&gt;true&lt;&#x2F;verbose&gt; &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt; &lt;&#x2F;configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;&#x2F;id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;&#x2F;goal&gt; &lt;&#x2F;goals&gt; &lt;&#x2F;execution&gt; &lt;&#x2F;executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.2&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; &lt;&#x2F;plugin&gt;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.lida1024.top/tags/SpringBoot/"}]},{"title":"自己实现一个简单版的HashMap","slug":"自己实现一个简单版的HashMap","date":"2019-07-26T03:54:00.000Z","updated":"2020-04-10T03:45:53.463Z","comments":true,"path":"2019/07/26/自己实现一个简单版的HashMap/","link":"","permalink":"http://www.lida1024.top/2019/07/26/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%89%88%E7%9A%84HashMap/","excerpt":"","text":"HashMap简介HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 简单版，只实现put和get12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class MyHashMap&lt;K, V&gt; &#123; private static int default_length &#x3D; 16; private MyEntry&lt;K, V&gt;[] entries; public MyHashMap() &#123; super(); entries &#x3D; new MyEntry[default_length]; &#125; public V put(K key, V value) &#123; int index &#x3D; key.hashCode() % default_length;&#x2F;&#x2F; hascode值除map大小取余 MyEntry&lt;K, V&gt; prevoius &#x3D; entries[index]; for (MyEntry&lt;K, V&gt; entry &#x3D; entries[index]; entry !&#x3D; null; entry &#x3D; entry.next) &#123; if (entry.getKey().equals(key)) &#123; V oldValue &#x3D; (V) entry.getValue(); entry.setValue(value); return oldValue; &#125; &#125; MyEntry&lt;K, V&gt; entry &#x3D; new MyEntry&lt;&gt;(key, value); entry.next &#x3D; prevoius; entries[index] &#x3D; entry; return null; &#125; public K get(K key)&#123; int index&#x3D; key.hashCode()%default_length; for (MyEntry&lt;K,V&gt; entry&#x3D; entries[index];entry!&#x3D;null;entry&#x3D;entry.next)&#123; if(entry.getKey().equals(key))&#123; return (K)entry.getValue(); &#125; &#125; return null; &#125; private final class MyEntry&lt;K, V&gt; &#123; private K key; private V value; private MyEntry next; public MyEntry() &#123; super(); &#125; public MyEntry(K key, V value) &#123; super(); this.key &#x3D; key; this.value &#x3D; value; &#125; public MyEntry(K key, V value, MyEntry next) &#123; super(); this.key &#x3D; key; this.value &#x3D; value; this.next &#x3D; next; &#125; public K getKey() &#123; return key; &#125; public void setKey(K key) &#123; this.key &#x3D; key; &#125; public V getValue() &#123; return value; &#125; public void setValue(V value) &#123; this.value &#x3D; value; &#125; public MyEntry getNext() &#123; return next; &#125; public void setNext(MyEntry next) &#123; this.next &#x3D; next; &#125; &#125;&#125; 复杂版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178public class MyHashMap &#123; &#x2F;&#x2F;默认初始化大小 16 private static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16; &#x2F;&#x2F;默认负载因子 0.75 private static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f; &#x2F;&#x2F;临界值 private int threshold; &#x2F;&#x2F;元素个数 private int size; &#x2F;&#x2F;扩容次数 private int resize; private MyEntry[] table; public MyHashMap() &#123; table &#x3D; new MyEntry[DEFAULT_INITIAL_CAPACITY]; threshold &#x3D; (int) (DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); size &#x3D; 0; &#125; private int index(Object key) &#123; &#x2F;&#x2F;根据key的hashcode和entry长度取模计算key在entry中的位置 return key.hashCode() % table.length; &#125; public void put(Object key, Object value) &#123; &#x2F;&#x2F;key为null时需要特殊处理，为简化实现忽略null值 if (key &#x3D;&#x3D; null) return; int index &#x3D; index(key); &#x2F;&#x2F;遍历index位置的entry，若找到重复key则更新对应entry的值，然后返回 MyEntry entry &#x3D; table[index]; while (entry !&#x3D; null) &#123; if (entry.getKey().hashCode() &#x3D;&#x3D; key.hashCode() &amp;&amp; (entry.getKey() &#x3D;&#x3D; key || entry.getKey().equals(key))) &#123; entry.setValue(value); return; &#125; entry &#x3D; entry.getNext(); &#125; &#x2F;&#x2F;若index位置没有entry或者未找到重复的key，则将新key添加到table的index位置 add(index, key, value); &#125; private void add(int index, Object key, Object value) &#123; &#x2F;&#x2F;将新的entry放到table的index位置第一个，若原来有值则以链表形式存放 MyEntry entry &#x3D; new MyEntry(key, value, table[index]); table[index] &#x3D; entry; &#x2F;&#x2F;判断size是否达到临界值，若已达到则进行扩容，将table的capacicy翻倍 if (size++ &gt;&#x3D; threshold) &#123; resize(table.length * 2); &#125; &#125; private void resize(int capacity) &#123; if (capacity &lt;&#x3D; table.length) return; MyEntry[] newTable &#x3D; new MyEntry[capacity]; &#x2F;&#x2F;遍历原table，将每个entry都重新计算hash放入newTable中 for (int i &#x3D; 0; i &lt; table.length; i++) &#123; MyEntry old &#x3D; table[i]; while (old!&#x3D;null)&#123; MyEntry next &#x3D; old.getNext(); int index &#x3D; index(old.getKey()); old.setNext(newTable[index]); newTable[index] &#x3D; old; old&#x3D;next; &#125; &#125; &#x2F;&#x2F;用newTable替table table &#x3D; newTable; &#x2F;&#x2F;修改临界值 threshold &#x3D; (int) (table.length * DEFAULT_LOAD_FACTOR); resize++; &#125; public Object get(Object key)&#123; &#x2F;&#x2F;这里简化处理，忽略null值 if (key &#x3D;&#x3D; null) return null; MyEntry entry&#x3D; getEntry(key); return entry &#x3D;&#x3D; null ? null : entry.getValue(); &#125; public MyEntry getEntry(Object key)&#123; MyEntry entry &#x3D;table[index(key)]; while (entry!&#x3D;null)&#123; if (entry.getKey().hashCode()&#x3D;&#x3D;key.hashCode()&amp;&amp;(entry.getKey()&#x3D;&#x3D;key||entry.getKey().equals(key)))&#123; return entry; &#125; entry &#x3D; entry.getNext(); &#125; return entry; &#125; public void remove(Object key) &#123; if (key &#x3D;&#x3D; null) return; int index &#x3D; index(key); MyEntry pre &#x3D; null; MyEntry entry &#x3D; table[index]; while (entry !&#x3D; null) &#123; if (entry.getKey().hashCode() &#x3D;&#x3D; key.hashCode() &amp;&amp; (entry.getKey() &#x3D;&#x3D; key || entry.getKey().equals(key))) &#123; if (pre &#x3D;&#x3D; null) table[index] &#x3D; entry.getNext(); else pre.setNext(entry.getNext()); &#x2F;&#x2F;如果成功找到并删除，修改size size--; return; &#125; pre &#x3D; entry; entry &#x3D; entry.getNext(); &#125; &#125; public boolean containsKey(Object key) &#123; if (key &#x3D;&#x3D; null) return false; return getEntry(key) !&#x3D; null; &#125; public int size() &#123; return this.size; &#125; public void clear() &#123; for (int i &#x3D; 0; i &lt; table.length; i++) &#123; table[i] &#x3D; null; &#125; this.size &#x3D; 0; &#125; @Override public String toString() &#123; StringBuilder sb &#x3D; new StringBuilder(); sb.append(String.format(&quot;size:%s capacity:%s resize:%s\\n\\n&quot;, size, table.length, resize)); for (MyEntry entry : table) &#123; while (entry !&#x3D; null) &#123; sb.append(entry.getKey() + &quot;:&quot; + entry.getValue() + &quot;\\n&quot;); entry &#x3D; entry.getNext(); &#125; &#125; return sb.toString(); &#125;&#125; final class MyEntry &#123; private Object key; private Object value; private MyEntry next; public MyEntry(Object key, Object value, MyEntry next) &#123; this.key &#x3D; key; this.value &#x3D; value; this.next &#x3D; next; &#125; public Object getKey() &#123; return key; &#125; public void setKey(Object key) &#123; this.key &#x3D; key; &#125; public Object getValue() &#123; return value; &#125; public void setValue(Object value) &#123; this.value &#x3D; value; &#125; public MyEntry getNext() &#123; return next; &#125; public void setNext(MyEntry next) &#123; this.next &#x3D; next; &#125; &#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"HashMap","slug":"HashMap","permalink":"http://www.lida1024.top/tags/HashMap/"}]},{"title":"GSON搞定任何JSON数据","slug":"GSON搞定任何JSON数据","date":"2019-07-26T03:41:00.000Z","updated":"2020-04-11T00:27:44.224Z","comments":true,"path":"2019/07/26/GSON搞定任何JSON数据/","link":"","permalink":"http://www.lida1024.top/2019/07/26/GSON%E6%90%9E%E5%AE%9A%E4%BB%BB%E4%BD%95JSON%E6%95%B0%E6%8D%AE/","excerpt":"","text":"一、Gson介绍GSON是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个Json字符转成一个Java对象，或者将一个Java转化为Json字符串。 特点: 快速、高效 代码量少、简洁 面向对象 数据传递和解析 二、Gson的pom依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;&#x2F;groupId&gt; &lt;artifactId&gt;gson&lt;&#x2F;artifactId&gt; &lt;version&gt;2.8.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 三、Gson的创建方式 Gson gson = new gson(); 通过GsonBuilder()，可以配置多种配置。 1234567Gson gson &#x3D; new GsonBuilder() .setLenient()&#x2F;&#x2F; json宽松 .enableComplexMapKeySerialization()&#x2F;&#x2F;支持Map的key为复杂对象的形式 .serializeNulls() &#x2F;&#x2F;智能null .setPrettyPrinting()&#x2F;&#x2F; 调教格式 .disableHtmlEscaping() &#x2F;&#x2F;默认是GSON把HTML 转义的 .create(); 四、Gson的基本用法之前写过一个获取天气参数的API,就需要去解析返回的json数据，就以此为例。 12String url &#x3D; &quot;http:&#x2F;&#x2F;t.weather.sojson.com&#x2F;api&#x2F;weather&#x2F;city&#x2F;101010100&quot;;String resultStr &#x3D; HttpClientUtil.sendGetRequest(url, &quot;UTF-8&quot;); 五、进行解析123Gson gson &#x3D;new Gson();Map m&#x3D; gson.fromJson(resultStr,Map.class);System.out.println(m.get(&quot;data&quot;)); 结果 123456789101112131415&#123;shidu&#x3D;15%, pm25&#x3D;15.0, pm10&#x3D;35.0, quality&#x3D;优, wendu&#x3D;3, ganmao&#x3D;各类人群可自由活动, yesterday&#x3D;&#123;date&#x3D;06, sunrise&#x3D;07:36, high&#x3D;高温 3.0℃, low&#x3D;低温 -7.0℃, sunset&#x3D;17:03, aqi&#x3D;58.0, ymd&#x3D;2019-01-06, week&#x3D;星期日, fx&#x3D;西南风, fl&#x3D;&lt;3级, type&#x3D;晴, notice&#x3D;愿你拥有比阳光明媚的心情&#125;, forecast&#x3D;[&#123;date&#x3D;07, sunrise&#x3D;07:36, high&#x3D;高温 2.0℃, low&#x3D;低温 -7.0℃, sunset&#x3D;17:04, aqi&#x3D;48.0, ymd&#x3D;2019-01-07, week&#x3D;星期一, fx&#x3D;北风, fl&#x3D;3-4级, type&#x3D;多云, notice&#x3D;阴晴之间，谨防紫外线侵扰&#125;, &#123;date&#x3D;08, sunrise&#x3D;07:36, high&#x3D;高温 1.0℃, low&#x3D;低温 -9.0℃, sunset&#x3D;17:05, aqi&#x3D;28.0, ymd&#x3D;2019-01-08, week&#x3D;星期二, fx&#x3D;北风, fl&#x3D;3-4级, type&#x3D;晴, notice&#x3D;愿你拥有比阳光明媚的心情&#125;, &#123;date&#x3D;09, sunrise&#x3D;07:36, high&#x3D;高温 2.0℃, low&#x3D;低温 -8.0℃, sunset&#x3D;17:06, aqi&#x3D;83.0, ymd&#x3D;2019-01-09, week&#x3D;星期三, fx&#x3D;西南风, fl&#x3D;&lt;3级, type&#x3D;多云, notice&#x3D;阴晴之间，谨防紫外线侵扰&#125;, &#123;date&#x3D;10, sunrise&#x3D;07:36, high&#x3D;高温 4.0℃, low&#x3D;低温 -7.0℃, sunset&#x3D;17:07, aqi&#x3D;128.0, ymd&#x3D;2019-01-10, week&#x3D;星期四, fx&#x3D;西南风, fl&#x3D;&lt;3级, type&#x3D;晴, notice&#x3D;愿你拥有比阳光明媚的心情&#125;, &#123;date&#x3D;11, sunrise&#x3D;07:36, high&#x3D;高温 5.0℃, low&#x3D;低温 -6.0℃, sunset&#x3D;17:08, aqi&#x3D;238.0, ymd&#x3D;2019-01-11, week&#x3D;星期五, fx&#x3D;西南风, fl&#x3D;&lt;3级, type&#x3D;多云, notice&#x3D;阴晴之间，谨防紫外线侵扰&#125;]&#125;可以新建一个天气的Bean，将返回的json数据转换成对象 六、GSON直接解析成对象1ResultBean resultBean &#x3D; new Gson().fromJson(resultStr,ResultBean.class); 七、解析简单的json1234567891011data:&#123; shidu &#x3D; 15 % , pm25 &#x3D; 15.0, pm10 &#x3D; 35.0, quality &#x3D; 优, wendu &#x3D; 3, ganmao &#x3D; 各类人群可自由活动, &#125;JsonObject jsonObject &#x3D;(JsonObject) new JsonParser().parse(resultStr);Int wendu &#x3D; jsonObject.get(&quot;data&quot;).getAsJsonObject().get(&quot;wendu&quot;).getAsInt();String quality&#x3D; jsonObject.get(&quot;data&quot;).getAsJsonObject().get(&quot;quality&quot;).getAsString(); 八、解析多层对象1234567891011121314151617181920212223242526 data:&#123; shidu &#x3D; 15 % , pm25 &#x3D; 15.0, pm10 &#x3D; 35.0, quality &#x3D; 优, wendu &#x3D; 3, ganmao &#x3D; 各类人群可自由活动, yesterday :&#123; date &#x3D; 06, sunrise &#x3D; 07: 36, high &#x3D; 高温 3.0℃, low &#x3D; 低温 - 7.0℃, sunset &#x3D; 17: 03, aqi &#x3D; 58.0, ymd &#x3D; 2019 - 01 - 06, week &#x3D; 星期日, fx &#x3D; 西南风, fl &#x3D; &lt; 3 级, type &#x3D; 晴, notice &#x3D; 愿你拥有比阳光明媚的心情 &#125; &#125;JsonObject jsonObject &#x3D; (JsonObject) new JsonParser().parse(resultStr);JsonObject yesterday &#x3D; jsonObject.get(&quot;data&quot;).getAsJsonObject().get(&quot;yesterday &quot;).getAsJsonObject();String type &#x3D; yesterday.get(&quot;type&quot;).getAsString(); 九、解析带数组的json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&#123;shidu &#x3D; 15 % , pm25 &#x3D; 15.0, pm10 &#x3D; 35.0, quality &#x3D; 优, wendu &#x3D; 3, ganmao &#x3D; 各类人群可自由活动, yesterday &#x3D; &#123; date &#x3D; 06, sunrise &#x3D; 07: 36, high &#x3D; 高温 3.0℃, low &#x3D; 低温 - 7.0℃, sunset &#x3D; 17: 03, aqi &#x3D; 58.0, ymd &#x3D; 2019 - 01 - 06, week &#x3D; 星期日, fx &#x3D; 西南风, fl &#x3D; &lt; 3 级, type &#x3D; 晴, notice &#x3D; 愿你拥有比阳光明媚的心情 &#125;, forecast &#x3D; [&#123; date &#x3D; 07, sunrise &#x3D; 07: 36, high &#x3D; 高温 2.0℃, low &#x3D; 低温 - 7.0℃, sunset &#x3D; 17: 04, aqi &#x3D; 48.0, ymd &#x3D; 2019 - 01 - 07, week &#x3D; 星期一, fx &#x3D; 北风, fl &#x3D; 3 - 4 级, type &#x3D; 多云, notice &#x3D; 阴晴之间， 谨防紫外线侵扰 &#125;, &#123; date &#x3D; 08, sunrise &#x3D; 07: 36, high &#x3D; 高温 1.0℃, low &#x3D; 低温 - 9.0℃, sunset &#x3D; 17: 05, aqi &#x3D; 28.0, ymd &#x3D; 2019 - 01 - 08, week &#x3D; 星期二, fx &#x3D; 北风, fl &#x3D; 3 - 4 级, type &#x3D; 晴, notice &#x3D; 愿你拥有比阳光明媚的心情 &#125;, &#123; date &#x3D; 09, sunrise &#x3D; 07: 36, high &#x3D; 高温 2.0℃, low &#x3D; 低温 - 8.0℃, sunset &#x3D; 17: 06, aqi &#x3D; 83.0, ymd &#x3D; 2019 - 01 - 09, week &#x3D; 星期三, fx &#x3D; 西南风, fl &#x3D; &lt; 3 级, type &#x3D; 多云, notice &#x3D; 阴晴之间， 谨防紫外线侵扰 &#125;, &#123; date &#x3D; 10, sunrise &#x3D; 07: 36, high &#x3D; 高温 4.0℃, low &#x3D; 低温 - 7.0℃, sunset &#x3D; 17: 07, aqi &#x3D; 128.0, ymd &#x3D; 2019 - 01 - 10, week &#x3D; 星期四, fx &#x3D; 西南风, fl &#x3D; &lt; 3 级, type &#x3D; 晴, notice &#x3D; 愿你拥有比阳光明媚的心情 &#125;, &#123; date &#x3D; 11, sunrise &#x3D; 07: 36, high &#x3D; 高温 5.0℃, low &#x3D; 低温 - 6.0℃, sunset &#x3D; 17: 08, aqi &#x3D; 238.0, ymd &#x3D; 2019 - 01 - 11, week &#x3D; 星期五, fx &#x3D; 西南风, fl &#x3D; &lt; 3 级, type &#x3D; 多云, notice &#x3D; 阴晴之间， 谨防紫外线侵扰 &#125;]&#125;JsonObject jsonObject &#x3D;(JsonObject) new JsonParser().parse(resultStr);&#x2F;&#x2F;获取dataJsonObject data &#x3D; jsonObject.get(&quot;data&quot;).getAsJsonObject();&#x2F;&#x2F;获取数组JsonArray forecast &#x3D; data.getAsJsonObject().get(&quot;forecast&quot;).getAsJsonArray();String type &#x3D; forecast.get(0).getAsJsonObject().get(&quot;type&quot;).getAsString();","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"Json","slug":"Json","permalink":"http://www.lida1024.top/tags/Json/"}]},{"title":"开发中常用的 25 个JavaScript 单行代码","slug":"开发中常用的-25-个JavaScript-单行代码","date":"2019-07-26T03:34:00.000Z","updated":"2020-04-10T03:52:56.956Z","comments":true,"path":"2019/07/26/开发中常用的-25-个JavaScript-单行代码/","link":"","permalink":"http://www.lida1024.top/2019/07/26/%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84-25-%E4%B8%AAJavaScript-%E5%8D%95%E8%A1%8C%E4%BB%A3%E7%A0%81/","excerpt":"","text":"1.强制布尔值要将变量强制转换为布尔值而不更改其值： 1const myBoolean &#x3D; !! myVariable;!!null &#x2F;&#x2F; false !!undefined &#x2F;&#x2F; false !!false &#x2F;&#x2F; false !!ture &#x2F;&#x2F; ture !!&quot;&quot; &#x2F;&#x2F; false !!&quot;string&quot; &#x2F;&#x2F; true !!0 &#x2F;&#x2F; false !!1 &#x2F;&#x2F; true !!&#123;&#125; &#x2F;&#x2F; true !![] &#x2F;&#x2F; true 2.基于某个条件为对象设置属性要使用spread运算符有条件地在对象上设置属性： 123456const myObject &#x3D; &#123;... myProperty &amp;&amp; &#123;propName：myPoperty&#125;&#125;;let myProperty &#x3D; &#39;Jhon&#39; const myObject &#x3D; &#123;...myProperty &amp;&amp; &#123;propName: myProperty&#125;&#125;; &#x2F;&#x2F; &#123;propName: &quot;Jhon&quot;&#125; let myProperty &#x3D; &#39;&#39; const myObject &#x3D; &#123;...myProperty &amp;&amp; &#123;propName: myProperty&#125;&#125;; &#x2F;&#x2F; &#123;&#125; 如果myProperty结果为false，则 &amp;&amp; 失败并且不设置新属性; 否则，如果不为空，&amp;&amp; 将设置新属性并覆盖原来的值。 3.合并对象12345const mergedObject &#x3D; &#123; ...objectOne, ...objectTwo &#125;; const mergedObject &#x3D; &#123; ...&#123;name: &#39;Jhon&#39;, age: &#39;18&#39;&#125;, ...&#123;name1: &#39;jhon1&#39;, age1: &#39;12&#39;&#125;&#125;; &#x2F;&#x2F; &#123;name: &quot;Jhon&quot;, age: &quot;18&quot;, name1: &quot;jhon1&quot;, age1: &quot;12&quot;&#125; const mergedObject &#x3D; &#123; ...&#123;name: &#39;Jhon&#39;, age: &#39;18&#39;&#125;, ...&#123;name: &#39;jhon1&#39;, age:&#39;12&#39;&#125;&#125;; &#x2F;&#x2F; &#123;name: &quot;jhon1&quot;, age: &quot;12&quot;&#125; 支持无限制合并，但如果对象之间存在相同属性，则后面属性会覆盖前面属性。*请注意，这仅适用于浅层合并。 4.交换变量要在不使用中间变量的情况下交换两个变量的值 123[varA，varB] &#x3D; [varB，varA]; let a &#x3D; 1; let b &#x3D; 2; [a, b] &#x3D; [b, a] &#x2F;&#x2F; a &#x3D; 2 b &#x3D; 1 5.删除Boolean 为 false 值12const clean &#x3D; dirty.filter(Boolean); const clean &#x3D; [0, false, true, undefined, null, &#39;&#39;, 12, 15].filter(Boolean); &#x2F;&#x2F; [true, 12, 15] 这将删除值等于：null，undefined，false，0 和空字符串(‘’)。 6.转换元素类型要将Number元素转换为String元素： 12const stringArray &#x3D; numberArray.map(String); const stringArray &#x3D; [1, 2, 3].map(String); [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] 如果数组包含字符串，字符串原样保留。 这也可以用于将String元素转换为Number类型： 12const numberArray &#x3D; stringArray.map(Number); const stringArray &#x3D; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(String); &#x2F;&#x2F; [1, 2, 3] 7.格式化对象为JSON代码要以可读的格式显示JSON代码： 123const formatted &#x3D; JSON.stringify(myObj, null, 4); const formatted &#x3D; JSON.stringify(&#123;name: &#39;Jhon&#39;, age: 18, address: &#39;sz&#39;&#125;, null, 4); &#x2F;* &#123; &quot;name&quot;: &quot;Jhon&quot;, &quot;age&quot;: 18, &quot;address&quot;: &quot;sz&quot; &#125; *&#x2F; 该字符串化命令有三个参数。第一个是Javascript对象。第二个是可选函数，可用于在JSON进行字符串化时对其执行操作。最后一个参数指示要添加多少空格作为缩进以格式化JSON。省略最后一个参数，JSON将返回一个长行。如果myObj中存在循环引用，则会格式失败。 8.快速创建数字数组要创建一个数组并用数字填充它，索引为零： 12const numArray &#x3D; Array.from(new Array(10), (x, i)&#x3D;&gt; i); &#x2F;&#x2F; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 9.随机生成六位数字验证码12const code &#x3D; Math.floor(Math.random() * 1000000).toString().padStart(6, &quot;0&quot;); &#x2F;&#x2F; 942377 10.身份证正则1234const IDReg&#x3D; &#x2F;(^[1-9]d&#123;5&#125;(18|19| ([23]d))d&#123;2&#125;((0[1-9])| (10|11|12))(([0-2][1-9])|10|20|30|31)d&#123;3&#125;[0-9Xx]$)| (^[1-9]d&#123;5&#125;d&#123;2&#125;((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)d&#123;2&#125;[0-9Xx]$)&#x2F;; 11.window.location.search 转 JS 对象有时候我们会对url的查询参数即从问号 (?)后 开始的 URL（查询部分）进行转换 1234567891011const searchObj &#x3D; search &#x3D;&gt; JSON.parse( &#96;&#123;&quot;$&#123;decodeURIComponent(search .substring(1)) .replace(&#x2F;&quot;&#x2F;g, &#39;\\&quot;&#39;) .replace(&#x2F;&amp;&#x2F;g,&#39;&quot;,&quot;&#39;) .replace(&#x2F;&#x3D;&#x2F;g, &#39;&quot;:&quot;&#39;) &#125;&quot;&#125;&#96; ); &#x2F;&#x2F; 假如请求url为 &#x2F;&#x2F; &#39;https:&#x2F;&#x2F;www.baidu.com?ie&#x3D;utf-8&amp;f&#x3D;8&amp;rsv_bp&#x3D;1&amp;rsv_idx&#x3D;1&amp;tn&#x3D;baidu&amp;wd&#x3D;js&amp;rsv_pq&#x3D;a86b5e5f0007bceb&amp;rsv_t&#x3D;1e1fAVan%2BVlnkhJHFB0BIGLdLM2slszYMJBTTfFkmyyBUzBpw0ggeuVDE50&amp;rqlang&#x3D;cn&amp;rsv_enter&#x3D;0&amp;inputT&#x3D;1287&amp;rsv_sug3&#x3D;5&amp;rsv_sug1&#x3D;3&amp;rsv_sug7&#x3D;101&amp;rsv_sug2&#x3D;0&amp;rsv_sug4&#x3D;1907&#39; &#x2F;&#x2F; 那么 window.location.search 就为： let search &#x3D; &#39;?ie&#x3D;utf-8&amp;f&#x3D;8&amp;rsv_bp&#x3D;1&amp;rsv_idx&#x3D;1&amp;tn&#x3D;baidu&amp;wd&#x3D;js&amp;rsv_pq&#x3D;a86b5e5f0007bceb&amp;rsv_t&#x3D;1e1fAVan%2BVlnkhJHFB0BIGLdLM2slszYMJBTTfFkmyyBUzBpw0ggeuVDE50&amp;rqlang&#x3D;cn&amp;rsv_enter&#x3D;0&amp;inputT&#x3D;1287&amp;rsv_sug3&#x3D;5&amp;rsv_sug1&#x3D;3&amp;rsv_sug7&#x3D;101&amp;rsv_sug2&#x3D;0&amp;rsv_sug4&#x3D;1907&#39; searchObj(search) 12.JS 对象转 url 查询字符串123456const objectToQueryString &#x3D; (obj) &#x3D;&gt; Object.keys(obj).map((key) &#x3D;&gt;&#96;$&#123;encodeURIComponent(key)&#125; &#x3D;$&#123;encodeURIComponent(obj[key])&#125;&#96;).join(&#39;&amp;&#39;); objectToQueryString(&#123;name: &#39;Jhon&#39;, age: 18, address: &#39;beijing&#39;&#125;) &#x2F;&#x2F; name&#x3D;Jhon&amp;age&#x3D;18&amp;address&#x3D;beijing 13.获取数组交集123const similarity &#x3D; (arr, values) &#x3D;&gt; arr.filter(v &#x3D;&gt; values.includes(v)); similarity([1, 2, 3], [1, 2, 4]); &#x2F;&#x2F; [1,2] 14.检测设备类型使用正则表达式来检测 navigator.userAgent 属性判断设备是在移动设备还是在台式机/笔记本电脑打开。 123const detectDeviceType &#x3D; () &#x3D;&gt;&#x2F;Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile| OperaMini&#x2F;i.test(navigator.userAgent) ? &#39;Mobile&#39; : &#39;Desktop&#39;; 15.将数字转化为千分位格式123const toDecimalMark &#x3D; num &#x3D;&gt; num.toLocaleString(&#39;en-US&#39;); toDecimalMark(12305030388.9087); &#x2F;&#x2F; &quot;12,305,030,388.909&quot; 16.多维数组转一维数组12345const deepFlatten &#x3D; arr &#x3D;&gt; [].concat( ...arr.map( v &#x3D;&gt; (Array.isArray(v) ? deepFlatten(v) : v))); deepFlatten([1, [2], [[3], 4], 5]); &#x2F;&#x2F; [1,2,3,4,5] 17.过滤对象数组123456789const reducedFilter &#x3D; (data, keys, fn) &#x3D;&gt;data.filter(fn) .map( el &#x3D;&gt;keys.reduce( (acc, key) &#x3D;&gt; &#123;acc[key] &#x3D;el[key];return acc;&#125;, &#123;&#125;) );const data &#x3D; [ &#123; id: 1, name: &#39;john&#39;, age: 24 &#125;, &#123; id: 2, name: &#39;mike&#39;, age: 50 &#125; ]; let a &#x3D; reducedFilter(data, [&#39;id&#39;, &#39;name&#39;], item &#x3D;&gt; item.age &gt; 24); &#x2F;&#x2F; [&#123; id: 2, name: &#39;mike&#39;&#125;] 18.驼峰字字符串格式化转换驼峰拼写的字符串为特定格式。 使用 String.replace() 去除下划线，连字符和空格，并将驼峰拼写格式的单词转换为全小写。省略第二个参数 separator ，默认使用 _ 分隔符。 123456const fromCamelCase &#x3D; (str, separator &#x3D; &#39;_&#39;) &#x3D;&gt;str.replace(&#x2F;([a-zd])([A-Z])&#x2F;g, &#39;$1&#39; + separator + &#39;$2&#39;).replace(&#x2F;([A-Z]+)([A-Z][a-zd]+)&#x2F;g, &#39;$1&#39; + separator + &#39;$2&#39;).toLowerCase();fromCamelCase(&#39;someDatabaseFieldName&#39;, &#39; &#39;);&#x2F;&#x2F; &#39;some database field name&#39; fromCamelCase(&#39;someLabelThatNeedsToBeCamelized&#39;, &#39;-&#39;); &#x2F;&#x2F; &#39;some-label-that-needs-to-be-camelized&#39; fromCamelCase(&#39;someJavascriptProperty&#39;, &#39;_&#39;);&#x2F;&#x2F; &#39;some_javascript_property&#39; 19.是否为绝对地址1234const isAbsoluteURL &#x3D; str &#x3D;&gt; &#x2F;^[a-z][a-z0-9+.-]*:&#x2F;.test(str); isAbsoluteURL(&#39;https:&#x2F;&#x2F;google.com&#39;); &#x2F;&#x2F; true isAbsoluteURL(&#39;ftp:&#x2F;&#x2F;www.myserver.net&#39;);&#x2F;&#x2F; true isAbsoluteURL(&#39;&#x2F;foo&#x2F;bar&#39;); &#x2F;&#x2F; false 20.获取两个日期相差天数123const getDaysDiffBetweenDates &#x3D; (dateInitial, dateFinal) &#x3D;&gt; (dateFinal - dateInitial) &#x2F; (1000 * 3600 * 24); getDaysDiffBetweenDates(new Date(&#39;2017-12-13&#39;), new Date(&#39;2017-12-22&#39;)); &#x2F;&#x2F; 9 21.数组去重12const deDupe &#x3D; (myArray) &#x3D;&gt; [... new Set(myArray)]; deDupe([1, 1, 2, 1, 3, 3, 4]) &#x2F;&#x2F; [1, 2, 3, 4] 22.数组对象去重1234567891011const uniqueElementsBy &#x3D; (arr, fn) &#x3D;&gt;arr.reduce((acc, v) &#x3D;&gt; &#123; if (!acc.some(x &#x3D;&gt; fn(v, x))) acc.push(v); return acc; &#125;, []); uniqueElementsBy([&#123;id: 1, name: &#39;Jhon&#39;&#125;, &#123;id: 2, name: &#39;sss&#39;&#125;, &#123;id: 1, name: &#39;Jhon&#39;&#125;], (a, b) &#x3D;&gt; a.id &#x3D;&#x3D; b.id) &#x2F;&#x2F; [&#123;id: 1, name: &#39;Jhon&#39;&#125;, &#123;id: 2, name: &#39;sss&#39;&#125;] 23.RGB 颜色转 16进制颜色123const RGBToHex &#x3D; (r, g, b) &#x3D;&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, &#39;0&#39;); RGBToHex(255, 165, 1); &#x2F;&#x2F; &#39;ffa501&#39; 24.常用密码组合正则12const passwordReg &#x3D; &#x2F;(?!^(d+|[a-zA-Z]+|[~!@#$%^&amp;*?]+)$)^[w~!@#$%^&amp;*?]&#123;8,20&#125;$&#x2F;; &#x2F;&#x2F; -长度8~20位字符，支持大小写字母、数字、符号三种字符中任意两种字符的组合 25.判断dom元素是否具有某个className12const hasClass &#x3D; (el, className) &#x3D;&gt; new RegExp(&#96;(^|\\s)$&#123;className&#125;(\\s|$)&#96;).test(el.className);","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Front","slug":"Dev/Front","permalink":"http://www.lida1024.top/categories/Dev/Front/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://www.lida1024.top/tags/javaScript/"}]},{"title":"shiro 加密登录 密码加盐处理","slug":"shiro-加密登录-密码加盐处理","date":"2019-07-26T03:25:00.000Z","updated":"2020-03-11T12:20:38.306Z","comments":true,"path":"2019/07/26/shiro-加密登录-密码加盐处理/","link":"","permalink":"http://www.lida1024.top/2019/07/26/shiro-%E5%8A%A0%E5%AF%86%E7%99%BB%E5%BD%95-%E5%AF%86%E7%A0%81%E5%8A%A0%E7%9B%90%E5%A4%84%E7%90%86/","excerpt":"","text":"密码加密登录是为了提高系统安全性，即使是管理员查看数据库也得不到密码使用shiro可以很轻松的完成加密及登录操作 1.加密工具此工具用于注册时对密码进行加密 123456789101112public static final String md5(String password, String salt)&#123; &#x2F;&#x2F;加密方式 String hashAlgorithmName &#x3D; &quot;MD5&quot;; &#x2F;&#x2F;盐：为了即使相同的密码不同的盐加密后的结果也不同 ByteSource byteSalt &#x3D; ByteSource.Util.bytes(salt); &#x2F;&#x2F;密码 Object source &#x3D; password; &#x2F;&#x2F;加密次数 int hashIterations &#x3D; 1024; SimpleHash result &#x3D; new SimpleHash(hashAlgorithmName, source, byteSalt, hashIterations); return result.toString();&#125; 测试一下 123456public static void main(String[] args) &#123; String password &#x3D; md5(&quot;123456&quot;, &quot;WHLH&quot;); System.out.println(password); &#x2F;&#x2F;加密后的结果 &#x2F;&#x2F;3bcbb857c763d1429a24959cb8de2593&#125; 2.使用shiro登录Realm类 12345678910@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) &#123; UsernamePasswordToken token&#x3D;(UsernamePasswordToken) authenticationToken; String username &#x3D; token.getUsername(); &#x2F;&#x2F;查询用户信息 User user&#x3D;userService.findByUsername(username); &#x2F;&#x2F;取出盐并编码 ByteSource salt &#x3D; ByteSource.Util.bytes(user.getSalt()); return new SimpleAuthenticationInfo(username, user.getPassword(),salt, getName());&#125; 3.修改自定义realm配置加密算法和加密次数要和加密工具参数保持一致 12345678910&lt;bean id&#x3D;&quot;myRealm&quot; class&#x3D;&quot;cn.jaffreyen.web.shiro.MyRealm&quot;&gt; &lt;property name&#x3D;&quot;credentialsMatcher&quot;&gt; &lt;bean class&#x3D;&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt; &lt;!-- 加密算法 --&gt; &lt;property name&#x3D;&quot;hashAlgorithmName&quot; value&#x3D;&quot;MD5&quot;&gt;&lt;&#x2F;property&gt; &lt;!-- 加密次数 --&gt; &lt;property name&#x3D;&quot;hashIterations&quot; value&#x3D;&quot;1024&quot;&gt;&lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Frame","slug":"Dev/Frame","permalink":"http://www.lida1024.top/categories/Dev/Frame/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"http://www.lida1024.top/tags/Shiro/"}]},{"title":"记一次jsoup的使用","slug":"记一次jsoup的使用","date":"2019-07-06T07:46:00.000Z","updated":"2020-04-10T03:54:57.320Z","comments":true,"path":"2019/07/06/记一次jsoup的使用/","link":"","permalink":"http://www.lida1024.top/2019/07/06/%E8%AE%B0%E4%B8%80%E6%AC%A1jsoup%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Jsoup是用于解析HTML，就类似XML解析器用于解析XML。 Jsoup它解析HTML成为真实世界的HTML。 它与jquery选择器的语法非常相似，并且非常灵活容易使用以获得所需的结果。 安装依赖123456&lt;dependency&gt; &lt;!-- jsoup HTML parser library @ http:&#x2F;&#x2F;jsoup.org&#x2F; --&gt; &lt;groupId&gt;org.jsoup&lt;&#x2F;groupId&gt; &lt;artifactId&gt;jsoup&lt;&#x2F;artifactId&gt; &lt;version&gt;1.10.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 应用从URL获取HTML来解析12Document doc &#x3D; Jsoup.connect(&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;).get();String title &#x3D; doc.title(); connect(String url) 方法创建一个新的 Connection, 和 get() 取得和解析一个HTML文件。如果从该URL获取HTML时发生错误，便会抛出 IOException，应适当处理。Connection 接口还提供一个方法链来解决特殊请求，具体如下 123456Document doc &#x3D; Jsoup.connect(&quot;http:&#x2F;&#x2F;example.com&quot;;).data(&quot;query&quot;, &quot;Java&quot;).userAgent(&quot;Mozilla&quot;).cookie(&quot;auth&quot;, &quot;token&quot;).timeout(3000).post(); 查看元素123456getElementById(String id);getElementsByTag(String tag);getElementsByClass(String className);getElementsByAttribute(String key) (and related methods);Element siblings: siblingElements(), firstElementSibling(), lastElementSibling(); nextElementSibling(), previousElementSibling();Graph: parent(), children(), child(int index); 元素数据12345678attr(String key)获取属性attr(String key, String value)设置属性attributes()获取所有属性id(), className() and classNames()text()获取文本内容text(String value) 设置文本内容html()获取元素内HTMLhtml(String value)设置元素内的HTML内容outerHtml()获取元素外HTML内容data()获取数据内容（例如：script和style标签)tag() and tagName() 操作HTML和文本1234append(String html), prepend(String html)appendText(String text), prependText(String text)appendElement(String tagName), prependElement(String tagName)html(String value) 通过类似于css或jQuery的选择器来查找元素1234567891011Elements trs &#x3D; doc.select(&quot;.kuang&quot;).select(&quot;tbody&quot;).get(5).select(&quot;tr&quot;); StringBuilder controlTarget &#x3D; new StringBuilder(); for (int i &#x3D; 0; i &lt; trs.size(); i++) &#123; if (i &gt;&#x3D; 1 &amp;&amp; i &lt; trs.size() - 1) &#123; Elements tds &#x3D; trs.get(i).select(&quot;td&quot;); res.setCropRange(tds.get(0).text()); res.setDosage(tds.get(2).text()); res.setMethod(tds.get(3).text()); controlTarget.append(tds.get(1).text()).append(&quot; &quot;); &#125; &#125; Selector选择器概述12345678910tagname: 通过标签查找元素，比如：a;ns|tag: 通过标签在命名空间查找元素，比如：可以用 fb|name 语法来查找 &lt;fb:name&gt; 元素;&#39;#id&#39;: 通过ID查找元素，比如：#logo;.class: 通过class名称查找元素，比如：.masthead;[attribute]: 利用属性查找元素，比如：[href];[^attr]: 利用属性名前缀来查找元素，比如：可以用[^data-] 来查找带有HTML5 Dataset属性的元素;[attr&#x3D;value]: 利用属性值来查找元素，比如：[width&#x3D;500];[attr^&#x3D;value], [attr$&#x3D;value], [attr*&#x3D;value]: 利用匹配属性值开头、结尾或包含属性值来查找元素，比如：[href*&#x3D;&#x2F;path&#x2F;];[attr~&#x3D;regex]: 利用属性值匹配正则表达式来查找元素，比如： img[src~&#x3D;(?i)\\.(png|jpe?g)];*: 这个符号将匹配所有元素; Selector选择器组合使用123456789el#id: 元素+ID，比如： div#logo;el.class: 元素+class，比如： div.masthead;el[attr]: 元素+class，比如： a[href];任意组合，比如：a[href].highlight;ancestor child: 查找某个元素下子元素，比如：可以用.body p 查找在&quot;body&quot;元素下的所有 p元素;parent &gt; child: 查找某个父元素下的直接子元素，比如：可以用div.content &gt; p 查找 p 元素，也可以用body &gt; * 查找body标签下所有直接子元素;siblingA + siblingB: 查找在A元素之前第一个同级元素B，比如：div.head + div;siblingA ~ siblingX: 查找A元素之前的同级X元素，比如：h1 ~ p;el, el, el:多个选择器组合，查找匹配任一选择器的唯一元素，例如：div.masthead, div.logo; 伪选择器selectors123456789:lt(n): 查找哪些元素的同级索引值（它的位置在DOM树中是相对于它的父节点）小于n，比如：td:lt(3) 表示小 于三列的元素 :gt(n):查找哪些元素的同级索引值大于n，比如： div p:gt(2)表示哪些div中有包含2个以上的p元素 :eq(n): 查找哪些元素的同级索引值与n相等，比如：form input:eq(1)表示包含一个input标签的Form元素 :has(seletor): 查找匹配选择器包含元素的元素，比如：div:has(p)表示哪些div包含了p元素 :not(selector): 查找与选择器不匹配的元素，比如： div:not(.logo) 表示不包含 class&#x3D;&quot;logo&quot; 元素的所有 div 列表 :contains(text): 查找包含给定文本的元素，搜索不区分大不写，比如： p:contains(jsoup) :containsOwn(text): 查找直接包含给定文本的元素 :matches(regex): 查找哪些元素的文本匹配指定的正则表达式，比如：div:matches((?i)login) :matchesOwn(regex): 查找自身包含文本匹配指定正则表达式的元素 提取给定URL中的链接123456Document doc &#x3D; Jsoup.connect(&quot;http:&#x2F;&#x2F;www.yiibai.com&quot;).get(); Elements links &#x3D; doc.select(&quot;a[href]&quot;); for (Element link : links) &#123; System.out.println(&quot;\\nlink : &quot; + link.attr(&quot;href&quot;)); System.out.println(&quot;text : &quot; + link.text()); &#125; 提取URL中的元数据12345Document doc &#x3D; Jsoup.connect(&quot;http:&#x2F;&#x2F;www.yiibai.com&quot;).get(); String keywords &#x3D; doc.select(&quot;meta[name&#x3D;keywords]&quot;).first().attr(&quot;content&quot;); System.out.println(&quot;Meta keyword : &quot; + keywords); String description &#x3D; doc.select(&quot;meta[name&#x3D;description]&quot;).get(0).attr(&quot;content&quot;); System.out.println(&quot;Meta description : &quot; + description); 提取URL中的图像12345678Document doc &#x3D; Jsoup.connect(&quot;http:&#x2F;&#x2F;www.yiibai.com&quot;).get(); Elements images &#x3D; doc.select(&quot;img[src~&#x3D;(?i)\\\\.(png|jpe?g|gif)]&quot;); for (Element image : images) &#123; System.out.println(&quot;src : &quot; + image.attr(&quot;src&quot;)); System.out.println(&quot;height : &quot; + image.attr(&quot;height&quot;)); System.out.println(&quot;width : &quot; + image.attr(&quot;width&quot;)); System.out.println(&quot;alt : &quot; + image.attr(&quot;alt&quot;)); &#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://www.lida1024.top/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://www.lida1024.top/categories/Dev/Java/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.lida1024.top/tags/%E7%88%AC%E8%99%AB/"}]}]}