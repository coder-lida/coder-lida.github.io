<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一觉睡到小时候</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.lida1024.top/"/>
  <updated>2020-04-29T03:01:21.965Z</updated>
  <id>http://www.lida1024.top/</id>
  
  <author>
    <name>少年闰土</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK中的timer正确的打开与关闭</title>
    <link href="http://www.lida1024.top/2020/04/29/JDK%E4%B8%AD%E7%9A%84timer%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD/"/>
    <id>http://www.lida1024.top/2020/04/29/JDK%E4%B8%AD%E7%9A%84timer%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD/</id>
    <published>2020-04-29T02:59:00.000Z</published>
    <updated>2020-04-29T03:01:21.965Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/timer.png" alt=""></p><a id="more"></a><h2 id="Timer和TimerTask"><a href="#Timer和TimerTask" class="headerlink" title="Timer和TimerTask"></a>Timer和TimerTask</h2><p>Timer是jdk中提供的一个定时器工具，使用的时候会在主线程之外起一个单独的线程执行指定的计划任务，可以指定执行一次或者反复执行多次。</p><p>TimerTask是一个实现了Runnable接口的抽象类，代表一个可以被Timer执行的任务。</p><h2 id="Timer的调度"><a href="#Timer的调度" class="headerlink" title="Timer的调度"></a>Timer的调度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Timer;</span><br><span class="line">import java.util.TimerTask;</span><br><span class="line"></span><br><span class="line">public class TestTimer &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        new Reminder(3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static class Reminder&#123;</span><br><span class="line">        Timer timer;</span><br><span class="line">        </span><br><span class="line">        public Reminder(int sec)&#123;</span><br><span class="line">            timer &#x3D; new Timer();</span><br><span class="line">            timer.schedule(new TimerTask()&#123;</span><br><span class="line">                public void run()&#123;</span><br><span class="line">                    System.out.println(&quot;Time&#39;s up!&quot;);</span><br><span class="line">                    timer.cancel();</span><br><span class="line">                    System.out.println(&quot;Time&#39;s shutdown!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, sec*1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time&#39;s up!</span><br><span class="line">Time&#39;s shutdown!</span><br></pre></td></tr></table></figure><p>从这个例子可以看出一个典型的利用timer执行计划任务的过程如下：</p><ul><li>new一个TimerTask的子类，重写run方法来指定具体的任务，在这个例子里，我用匿名内部类的方式来实现了一个TimerTask的子类</li><li>new一个Timer类，Timer的构造函数里会起一个单独的线程来执行计划任务。</li></ul><p>jdk的实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Timer() &#123;</span><br><span class="line">        this(&quot;Timer-&quot; + serialNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Timer(String name) &#123;</span><br><span class="line">        thread.setName(name);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Timer的关闭"><a href="#Timer的关闭" class="headerlink" title="Timer的关闭"></a>Timer的关闭</h2><p>在JDK1.5以后，文档中有这么一句话：<br>对 Timer 对象最后的引用完成后，并且 所有未处理的任务都已执行完成后，计时器的任务执行线程会正常终止（并且成为垃圾回收的对象）。但是这可能要很长时间后才发生。</p><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><p>系统默认当Timer运行结束后，如果没有手动终止，那么则只有当系统的垃圾收集被调用的时候才会对其进行回收终止。<br>因此，可以手动System.gc();<br>但是Sytem.gc()在一个项目中是不能随便调用的。因为一个tomcat只启动一个进程，而JVM的垃圾处理器也只有一个，所以在一个工程里运行System.gc也会影响到其他工程。 </p><h3 id="cancle"><a href="#cancle" class="headerlink" title="cancle()"></a>cancle()</h3><p>首先看cancle方法的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void cancel() &#123;</span><br><span class="line">        synchronized(queue) &#123;</span><br><span class="line">            thread.newTasksMayBeScheduled &#x3D; false;</span><br><span class="line">            queue.clear();</span><br><span class="line">            queue.notify();  &#x2F;&#x2F; In case queue was already empty.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没有显式的线程stop方法，而是调用了queue的clear方法和queue的notify方法，clear是个自定义方法，notify是Objec自带的方法，很明显是去唤醒wait方法的。</p><p>clear方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * Removes all elements from the priority queue.</span><br><span class="line">  *&#x2F;</span><br><span class="line">void clear() &#123;</span><br><span class="line">        &#x2F;&#x2F; Null out task references to prevent memory leak</span><br><span class="line">        for (int i&#x3D;1; i&lt;&#x3D;size; i++)</span><br><span class="line">            queue[i] &#x3D; null;</span><br><span class="line"></span><br><span class="line">        size &#x3D; 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>clear方法很简单，就是去清空queue，queue是一个TimerTask的数组，然后把queue的size重置成0，变成empty.还是没有看到显式的停止线程方法，回到最开始new Timer的时候，看看new Timer代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Timer() &#123;</span><br><span class="line">        this(&quot;Timer-&quot; + serialNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">     * Creates a new timer whose associated thread has the specified name.</span><br><span class="line">     * The associated thread does &lt;i&gt;not&lt;&#x2F;i&gt;</span><br><span class="line">     * &#123;@linkplain Thread#setDaemon run as a daemon&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param name the name of the associated thread</span><br><span class="line">     * @throws NullPointerException if &#123;@code name&#125; is null</span><br><span class="line">     * @since 1.5</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Timer(String name) &#123;</span><br><span class="line">        thread.setName(name);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看看这个内部变量thread:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The timer thread.</span><br><span class="line">*&#x2F;</span><br><span class="line">private TimerThread thread &#x3D; new TimerThread(queue);</span><br></pre></td></tr></table></figure><p>不是原生的Thread,是自定义的类TimerThread.这个类实现了Thread类，重写了run方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mainLoop();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; Someone killed this Thread, behave as if Timer cancelled</span><br><span class="line">            synchronized(queue) &#123;</span><br><span class="line">                newTasksMayBeScheduled &#x3D; false;</span><br><span class="line">                queue.clear();  &#x2F;&#x2F; Eliminate obsolete references</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后是这个mainLoop方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">   &#x2F;**</span><br><span class="line">     * The main timer loop.  (See class comment.)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private void mainLoop() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimerTask task;</span><br><span class="line">                boolean taskFired;</span><br><span class="line">                synchronized(queue) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Wait for queue to become non-empty</span><br><span class="line">                    while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    if (queue.isEmpty())</span><br><span class="line">                        break; &#x2F;&#x2F; Queue is empty and will forever remain; die</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Queue nonempty; look at first evt and do the right thing</span><br><span class="line">                    long currentTime, executionTime;</span><br><span class="line">                    task &#x3D; queue.getMin();</span><br><span class="line">                    synchronized(task.lock) &#123;</span><br><span class="line">                        if (task.state &#x3D;&#x3D; TimerTask.CANCELLED) &#123;</span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            continue;  &#x2F;&#x2F; No action required, poll queue again</span><br><span class="line">                        &#125;</span><br><span class="line">                        currentTime &#x3D; System.currentTimeMillis();</span><br><span class="line">                        executionTime &#x3D; task.nextExecutionTime;</span><br><span class="line">                        if (taskFired &#x3D; (executionTime&lt;&#x3D;currentTime)) &#123;</span><br><span class="line">                            if (task.period &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; Non-repeating, remove</span><br><span class="line">                                queue.removeMin();</span><br><span class="line">                                task.state &#x3D; TimerTask.EXECUTED;</span><br><span class="line">                            &#125; else &#123; &#x2F;&#x2F; Repeating task, reschedule</span><br><span class="line">                                queue.rescheduleMin(</span><br><span class="line">                                  task.period&lt;0 ? currentTime   - task.period</span><br><span class="line">                                                : executionTime + task.period);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!taskFired) &#x2F;&#x2F; Task hasn&#39;t yet fired; wait</span><br><span class="line">                        queue.wait(executionTime - currentTime);</span><br><span class="line">                &#125;</span><br><span class="line">                if (taskFired)  &#x2F;&#x2F; Task fired; run it, holding no locks</span><br><span class="line">                    task.run();</span><br><span class="line">            &#125; catch(InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到wait方法，之前的notify就是通知到这个wait，然后clear方法在notify之前做了清空数组的操作，所以会break，线程执行结束，退出。</p><h2 id="Listener中的Timer"><a href="#Listener中的Timer" class="headerlink" title="Listener中的Timer"></a>Listener中的Timer</h2><p>很多业务中需要Timer一直执行，不会执行一次后就关闭，上面的例子中，timer调用cancel方法后，该timer就被关闭了。</p><p>监听器的实现方式有多种，这里我们说一下实现<code>ServletContextListener</code>接口。<br>该接口中有2个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface ServletContextListener extends EventListener &#123;</span><br><span class="line">    void contextInitialized(ServletContextEvent var1);</span><br><span class="line"></span><br><span class="line">    void contextDestroyed(ServletContextEvent var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即上下文的初始化和销毁。</p><p>我们来看一个实例<br>Listener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyListener implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">    private Log log &#x3D; LogFactory.getLog(MyListener.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;</span><br><span class="line">        Timer timer &#x3D; new Timer();</span><br><span class="line">        timer.schedule(new MyTask(),5000,5000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Task</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyTask extends TimerTask &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;timer 正在执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当程序启动的时候，在监听器的初始化中，timer会梅5秒执行一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer 正在执行</span><br><span class="line">timer 正在执行</span><br><span class="line">timer 正在执行</span><br><span class="line">timer 正在执行</span><br></pre></td></tr></table></figure><p>此次程序中我们没有去调用timer的cancel方法，这样会存在一个问题，就是产生的timer一直不会被关闭，就像上面说的只有当系统的垃圾收集被调用的时候才会对其进行回收终止。</p><p>同时tomcat日志会打印错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">28-Apr-2020 14:23:24.892 警告 [http-nio-8080-exec-23] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads Web应用程序[nyzft]似乎启动了一个名为[Timer-3]的线程，但未能停止它。这很可能会造成内存泄漏。线程的堆栈跟踪：[</span><br><span class="line"> java.lang.Object.wait(Native Method)</span><br><span class="line"> java.lang.Object.wait(Object.java:502)</span><br><span class="line"> java.util.TimerThread.mainLoop(Timer.java:526)</span><br><span class="line"> java.util.TimerThread.run(Timer.java:505)]</span><br></pre></td></tr></table></figure><p>问题的原因就是我们没有手动去关闭timer，但是如果去调用cancel方法，真实的场景timer只会被执行一次，不符合业务要求。<br>因此可以通过listener的contextDestroyed去关闭timer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyListener implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">    private Log log &#x3D; LogFactory.getLog(MyListener.class);</span><br><span class="line"></span><br><span class="line">    private Timer timer;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;</span><br><span class="line">        timer &#x3D; new Timer();</span><br><span class="line">        timer.schedule(new MyTask(),5000,5000);</span><br><span class="line">        System.out.println(&quot;执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;</span><br><span class="line">        timer.cancel();</span><br><span class="line">        System.out.println(&quot;关闭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，过几秒钟后再关闭程序，查看控制台输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">执行</span><br><span class="line">timer 正在执行</span><br><span class="line">timer 正在执行</span><br><span class="line">[2020-04-29 09:44:19,609] Artifact ssm-nyzft:war exploded: Artifact is deployed successfully</span><br><span class="line">[2020-04-29 09:44:19,609] Artifact ssm-nyzft:war exploded: Deploy took 38,550 milliseconds</span><br><span class="line">timer 正在执行</span><br><span class="line">timer 正在执行</span><br><span class="line">timer 正在执行</span><br><span class="line">timer 正在执行</span><br><span class="line">E:\Kit\Tomcat\tomcat8\apache-tomcat-8.5.39\bin\catalina.bat stop</span><br><span class="line">Disconnected from the target VM, address: &#39;127.0.0.1:52706&#39;, transport: &#39;socket&#39;</span><br><span class="line">Using CATALINA_BASE:   &quot;C:\Users\Administrator\.IntelliJIdea2019.1\system\tomcat\Unnamed_ssm-nyzft_2&quot;</span><br><span class="line">Using CATALINA_HOME:   &quot;E:\Kit\Tomcat\tomcat8\apache-tomcat-8.5.39&quot;</span><br><span class="line">Using CATALINA_TMPDIR: &quot;E:\Kit\Tomcat\tomcat8\apache-tomcat-8.5.39\temp&quot;</span><br><span class="line">Using JRE_HOME:        &quot;E:\Kit\JDK\JDK&quot;</span><br><span class="line">Using CLASSPATH:       &quot;E:\Kit\Tomcat\tomcat8\apache-tomcat-8.5.39\bin\bootstrap.jar;E:\Kit\Tomcat\tomcat8\apache-tomcat-8.5.39\bin\tomcat-juli.jar&quot;</span><br><span class="line">29-Apr-2020 09:44:40.511 淇℃伅 [main] org.apache.catalina.core.StandardServer.await A valid shutdown command was received via the shutdown port. Stopping the Server instance.</span><br><span class="line">29-Apr-2020 09:44:40.512 淇℃伅 [main] org.apache.coyote.AbstractProtocol.pause Pausing ProtocolHandler [&quot;http-nio-8081&quot;]</span><br><span class="line">29-Apr-2020 09:44:40.638 淇℃伅 [main] org.apache.coyote.AbstractProtocol.pause Pausing ProtocolHandler [&quot;ajp-nio-8009&quot;]</span><br><span class="line">29-Apr-2020 09:44:40.750 淇℃伅 [main] org.apache.catalina.core.StandardService.stopInternal Stopping service [Catalina]</span><br><span class="line">关闭</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/timer.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="Timer" scheme="http://www.lida1024.top/tags/Timer/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程图谱</title>
    <link href="http://www.lida1024.top/2020/04/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9B%BE%E8%B0%B1/"/>
    <id>http://www.lida1024.top/2020/04/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9B%BE%E8%B0%B1/</id>
    <published>2020-04-20T02:20:00.000Z</published>
    <updated>2020-04-29T03:04:52.867Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/bingfa.png" alt=""></p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/synchronization-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/bingfa.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="并发" scheme="http://www.lida1024.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程(一)CAS</title>
    <link href="http://www.lida1024.top/2020/04/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%80-CAS/"/>
    <id>http://www.lida1024.top/2020/04/20/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E4%B8%80-CAS/</id>
    <published>2020-04-20T00:06:00.000Z</published>
    <updated>2020-04-29T03:05:14.120Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/bingfa.png" alt=""></p><a id="more"></a><h2 id="CAS-是什么"><a href="#CAS-是什么" class="headerlink" title="CAS 是什么"></a>CAS 是什么</h2><p>CAS 的全称 Compare-And-Swap，它是一条 CPU 并发。</p><p>它的功能是判断内存某一个位置的值是否为预期，如果是则更改这个值，这个过程就是原子的。</p><p>CAS 并发原体现在 JAVA 语言中就是 <code>sun.misc.Unsafe</code> 类中的各个方法。调用 <code>UnSafe</code> 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令。这是一种完全依赖硬件的功能，通过它实现了原子操作。由于 CAS 是一种系统源语，源语属于操作系统用语范畴，是由若干条指令组成，用于完成某一个功能的过程，并且原语的执行必须是连续的，在执行的过程中不允许被中断，也就是说 CAS 是一条原子指令，不会造成所谓的数据不一致的问题。 </p><h2 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h2><p>CAS的意思就是比较并交换。上面说到，这个比较过程是原子的。我们新建一个测试类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CASDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       checkCAS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void checkCAS()&#123;</span><br><span class="line">        AtomicInteger atomicInteger &#x3D; new AtomicInteger(5);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(5, 2019) + &quot;\t current data is </span><br><span class="line">        &quot; + atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(5, 2020) + &quot;\t current data is </span><br><span class="line">        &quot; + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">    atomicInteger.getAndIncrement();</span><br><span class="line">    System.out.println(&quot;current data is &quot; + atomicInteger.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看返回结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true current data is 2019</span><br><span class="line">false current data is 2019</span><br><span class="line">current data is 2020</span><br></pre></td></tr></table></figure><p>原子整型类的初始值是5，当第一次调用compareAndSet的时候期望值是5，更新值是2019，此时的期望值和atomicInteger 值相等，则替换为更新值，输出为2019；第二次调用compareAndSet的时候期望值还是5，此时atomicInteger的值已经更新为2019，期望值和原始值不想等，不做更新操作，所以此时的atomicInteger值还是2019。</p><p>compareAndSet是AtomicInteger的一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Atomically sets the value to the given updated value</span><br><span class="line">     * if the current value &#123;@code &#x3D;&#x3D;&#125; the expected value.</span><br><span class="line">     *</span><br><span class="line">     * @param expect the expected value</span><br><span class="line">     * @param update the new value</span><br><span class="line">     * @return &#123;@code true&#125; if successful. False return indicates that</span><br><span class="line">     * the actual value was not equal to the expected value.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>他调用的是unsafe类的<code>compareAndSwapInt</code>方法，this表示当前值对象，valueOffset是当前对象在内存中的偏移量，expect为期望值，update为更新值。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>需要说到 <code>atomicInteger.getAndIncrement();</code>这个方法，类似于i++。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Atomically increments by one the current value.</span><br><span class="line"> *</span><br><span class="line"> * @return the previous value</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final int getAndIncrement() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是调用的unsafe类的方法。<br>来看一下<code>getAndAddInt</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var1为当前对象，var2为当前对象在内存中的偏移量，var4为1，var5为<code>getIntVolatile(var1, var2)</code>的返回值，<code>getIntVolatile</code>方法的意思是当前对象var1且内存偏移量为var2时的值是多少。</p><p>在while循环中，同样调用了<code>compareAndSwapInt</code>方法，此时的var5为期望值，var5+var4为更新值。直到比较成功。</p><h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><p>unsafe类是CAS的核心类，由于java无法直接访问底层系统，需要通过本地（native）方法来访问，基于unsafe类可直接操作特定内存的数据unsafe类存在于sun.mics包中，其内部方法可以像c的指针一样直接操作内存。因为 Java 中 CAS 操作执行依赖于 Unsafe 类。 </p><p>变量 vauleOffset，表示该变量值在内存中的偏移量，因为 Unsafe 就是根据内存偏移量来获取数据的。</p><p>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 6214790243416807050L;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; setup to use Unsafe.compareAndSwapInt for updates</span><br><span class="line">    private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取下面 value 的地址偏移量</span><br><span class="line">            valueOffset &#x3D; unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile int value;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h2><ul><li>循环时间长开销很大<ul><li>如果 CAS 失败，会一直尝试，如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销（比如线程数很多，每次比较都是失败，就会一直循环），所以希望是线程数比较小的场景。</li></ul></li><li>只能保证一个共享变量的原子操作<ul><li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性。</li></ul></li><li>引出 ABA 问题</li></ul><h2 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h2><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicRefrenceDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User z3 &#x3D; new User(&quot;张三&quot;, 22);</span><br><span class="line">        User l4 &#x3D; new User(&quot;李四&quot;, 23);</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference &#x3D; new AtomicReference&lt;&gt;();</span><br><span class="line">        atomicReference.set(z3);</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + &quot;\t&quot; + atomicReference.get().toString());</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(z3, l4) + &quot;\t&quot; + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Getter</span><br><span class="line">@ToString</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">class User &#123;</span><br><span class="line">    String userName;</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ABA-问题是怎么产生的"><a href="#ABA-问题是怎么产生的" class="headerlink" title="ABA 问题是怎么产生的"></a>ABA 问题是怎么产生的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ABADemo &#123;</span><br><span class="line">    private static AtomicReference&lt;Integer&gt; atomicReference &#x3D; new AtomicReference&lt;&gt;(100);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(100, 101);</span><br><span class="line">            atomicReference.compareAndSet(101, 100);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 保证上面线程先执行</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicReference.compareAndSet(100, 2019);</span><br><span class="line">            System.out.println(atomicReference.get()); &#x2F;&#x2F; 2019</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有一个值从 A 改为 B 又改为 A，这就是 ABA 问题。</p><h3 id="ABA-问题解决"><a href="#ABA-问题解决" class="headerlink" title="ABA 问题解决"></a>ABA 问题解决</h3><p>时间戳原子引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ABADemo2 &#123;</span><br><span class="line">    private static AtomicStampedReference&lt;Integer&gt; atomicStampedReference &#x3D; new AtomicStampedReference&lt;&gt;(100, 1);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            int stamp &#x3D; atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; 的版本号为：&quot; + stamp);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1 );</span><br><span class="line">            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1 );</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            int stamp &#x3D; atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; 的版本号为：&quot; + stamp);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            boolean b &#x3D; atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1);</span><br><span class="line">            System.out.println(b); &#x2F;&#x2F; false</span><br><span class="line">            System.out.println(atomicStampedReference.getReference()); &#x2F;&#x2F; 100</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 的版本号为：1</span><br><span class="line">Thread-1 的版本号为：1</span><br><span class="line">false</span><br><span class="line">100</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/bingfa.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="并发" scheme="http://www.lida1024.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CAS" scheme="http://www.lida1024.top/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>JVM&amp;GC(一)java引用</title>
    <link href="http://www.lida1024.top/2020/04/16/JVM-GC-%E4%B8%80-java%E5%BC%95%E7%94%A8/"/>
    <id>http://www.lida1024.top/2020/04/16/JVM-GC-%E4%B8%80-java%E5%BC%95%E7%94%A8/</id>
    <published>2020-04-16T09:39:00.000Z</published>
    <updated>2020-04-16T09:44:17.660Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/jvm.jpg" alt=""></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中的引用有点像C++中的指针，通过引用可以对堆中的对象进行操作。在Java程序中最常见的引用类型是<code>强引用</code>，也是默认的引用类型。当在Java语言中使用New操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><h2 id="Jva中的引用"><a href="#Jva中的引用" class="headerlink" title="Jva中的引用"></a>Jva中的引用</h2><p>Java中提供了四个级别的引用，强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>在一个线程内，无需引用直接可以使用的对象，除非引用不存在了，否则强引用不会被GC清理。JVM即使抛出OOM异常，也不会回收强引用所指向的对象。强引用可能导致内存泄漏问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; &quot;hello&quot;;</span><br><span class="line">String str1 &#x3D; str;</span><br><span class="line">System.out.println(str&#x3D;&#x3D;str1);</span><br></pre></td></tr></table></figure><p>str变量将被分配到栈内，而“hello”对象则被分配在java堆中。局部变量str指向“hello”实例所在的堆空间，通过str可以操作该实例。此时str就是该实例的引用。<br><code>str1 = str</code>此时，str所指向的对象也被str1所指向，同时会在局部栈空间上分配空间存放str1变量。<br>对引用使用<code>==</code>比较的是两个引用所指向的堆空间的地址是否相同。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用是除了强引用外，最强的引用类型。用来描述一些还有用但是并非必须的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf &#x3D; new SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;</span><br><span class="line">sf.get();&#x2F;&#x2F;有时候会返回null</span><br><span class="line">&#x2F;&#x2F;sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当这个对象被标记为需要回收的对象时，则返回null；</span><br></pre></td></tr></table></figure><p>SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。一旦垃圾线程回收该Java对象之后，get()方法将返回null。</p><p>软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。使用软引用能防止内存泄露，增强程序的健壮性。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。当调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。在任何时候，都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，可以检查哪个SoftReference所软引用的对象已经被回收，于是可以把这些失去所软引用的对象的SoftReference对象清除掉。</p><p>Java虚拟机会尽量让软引用存活的时间长一些，迫不得以才清理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.SoftReference;</span><br><span class="line"> </span><br><span class="line">public class TestRef &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        SoftReference&lt;String&gt; str &#x3D; new SoftReference&lt;String&gt;(new String(&quot;abc&quot;));</span><br><span class="line">        System.out.println(str.get());</span><br><span class="line">        &#x2F;&#x2F;通知JVM进行内存回收</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(str.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/jvm-2.png" alt=""></p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>在java中，可以用java.lang.ref.WeakReference实例来保存对一个Java对象的弱引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf &#x3D; new WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj &#x3D; null;</span><br><span class="line">wf.get();&#x2F;&#x2F;有时候会返回null</span><br><span class="line">wf.isEnQueued();&#x2F;&#x2F;返回是否被垃圾回收器标记为即将回收的垃圾</span><br></pre></td></tr></table></figure><p>当GC进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易，更快的被GC回收。弱引用对象尝尝用于Map结构中，引用数据量比较大的对象，一旦该对象的强引用为null时，GC能够快速的回收该对象空间。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line"> </span><br><span class="line">public class TestRef &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        WeakReference&lt;String&gt; str &#x3D; new WeakReference&lt;String&gt;(new String(&quot;abc&quot;));</span><br><span class="line">        System.out.println(str.get());</span><br><span class="line">        &#x2F;&#x2F;通知JVM进行内存回收</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(str.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/jvm-3.png" alt=""></p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>又称为幽灵引用，主要目的是在一个对象所占的内存被实际回收之前的到通知，从而可以进行一些相关的清理工作。幽灵引用在创建是必须提供一个引用队列作为参数，它的作用在于检测对象是否已经从内存中删除，跟踪垃圾回收过程。其次幽灵引用对象的get方法总是返回null，因此无法通过幽灵引用来获取被引用的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj &#x3D; new Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf &#x3D; new PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj&#x3D;null;</span><br><span class="line">pf.get();&#x2F;&#x2F;永远返回null</span><br><span class="line">pf.isEnQueued();&#x2F;&#x2F;返回是否从内存中已经删除</span><br></pre></td></tr></table></figure><p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.ref.PhantomReference;</span><br><span class="line">import java.lang.ref.ReferenceQueue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class TestRef &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        ReferenceQueue&lt;String&gt; queue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line">        PhantomReference&lt;String&gt; str &#x3D; new PhantomReference&lt;String&gt;(&quot;abc&quot;, queue);</span><br><span class="line">        System.out.println(str.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/jvm-4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/jvm.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="JVM" scheme="http://www.lida1024.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Nginx实现负载均衡</title>
    <link href="http://www.lida1024.top/2020/04/11/Nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://www.lida1024.top/2020/04/11/Nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2020-04-11T05:47:00.000Z</published>
    <updated>2020-04-11T06:06:36.931Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/nginx.png" alt=""></p><a id="more"></a><p>负载均衡即是代理服务器将接收的请求均衡的分发到各服务器中。</p><p>负载均衡的优势在访问量少或并发小的时候可能并不明显，且不说淘宝双11、铁道部抢票这种级别的访问量、高并发，就是一般网站的抢购活动时，也会给服务器造成很大压力，可能会造成服务器崩溃。而负载均衡可以很明显的减少甚至消除这种情况的出现，下面我们说说实现方法。</p><p>准备工作</p><p>首先下载安装Nginx。</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-1.png" alt=""></p><p>下载完成解压到本地盘符。解压后是这样的</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-2.png" alt=""></p><p>注意：nginx.exe是启动的程序，为了方便我们可以手写两个bat文件：</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-3.png" alt=""></p><p>我将nginx解压到了我本地的E盘</p><p>reload.bat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:</span><br><span class="line">cd kit\nginx-1.14.0\</span><br><span class="line">nginx  -s reload</span><br></pre></td></tr></table></figure><p>stop.bat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:</span><br><span class="line">cd  kit\nginx-1.14.0\</span><br><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure><p>我们双击nginx.exe就可以启动nginx，我们启动一下，打开任务 管理器看到</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-4.png" alt=""></p><p>就说明启动成功。</p><p>接下来配置两个tomcat来进行测试，下面是我本地的tomcat，存放在E盘中。</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-5.png" alt=""></p><p>拷贝一份放到我的D盘中，并修改端口号，默认 为8080，我们将D盘中的tomcat端口号修改为8082，将E盘中的tomcat端口号修改为8081。</p><p>端口号的修改：</p><p>找到conf</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-6.png" alt=""></p><p>修改</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-7.png" alt=""></p><p>修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server port&#x3D;&quot;8006&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt;  </span><br><span class="line">&lt;Listener className&#x3D;&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine&#x3D;&quot;on&quot; &#x2F;&gt;  </span><br><span class="line">&lt;Listener className&#x3D;&quot;org.apache.catalina.core.JasperListener&quot; &#x2F;&gt;  </span><br><span class="line">&lt;Listener className&#x3D;&quot;org.apache.catalina.mbeans.ServerLifecycleListener&quot; &#x2F;&gt;  </span><br><span class="line">&lt;Listener className&#x3D;&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; &#x2F;&gt;  </span><br><span class="line">&lt;GlobalNamingResources&gt;    </span><br><span class="line"> &lt;Resource name&#x3D;&quot;UserDatabase&quot;</span><br><span class="line">                   auth&#x3D;&quot;Container&quot;             </span><br><span class="line">                   type&#x3D;&quot;org.apache.catalina.UserDatabase&quot;              </span><br><span class="line">                  description&#x3D;&quot;User database that can be updated and saved&quot;              </span><br><span class="line">                  factory&#x3D;&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;              </span><br><span class="line">                 pathname&#x3D;&quot;conf&#x2F;tomcat-users.xml&quot; &#x2F;&gt;  </span><br><span class="line">&lt;&#x2F;GlobalNamingResources&gt;  </span><br><span class="line">&lt;Service name&#x3D;&quot;Catalina&quot;&gt;    </span><br><span class="line">&lt;Connector port&#x3D;&quot;8082&quot; </span><br><span class="line">                   protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;                </span><br><span class="line">                   connectionTimeout&#x3D;&quot;20000&quot;                </span><br><span class="line">                   redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;            </span><br><span class="line">&lt;Connector port&#x3D;&quot;8010&quot; </span><br><span class="line">                    protocol&#x3D;&quot;AJP&#x2F;1.3&quot; </span><br><span class="line">                    redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;    </span><br><span class="line">&lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt;      </span><br><span class="line">&lt;Realm className&#x3D;&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;             </span><br><span class="line">             resourceName&#x3D;&quot;UserDatabase&quot;&#x2F;&gt;      </span><br><span class="line">&lt;Host name&#x3D;&quot;localhost&quot;  </span><br><span class="line">          appBase&#x3D;&quot;webapps&quot;            </span><br><span class="line">          unpackWARs&#x3D;&quot;true&quot; </span><br><span class="line">          autoDeploy&#x3D;&quot;true&quot;            </span><br><span class="line">          xmlValidation&#x3D;&quot;false&quot; </span><br><span class="line">          xmlNamespaceAware&#x3D;&quot;false&quot;&gt;     </span><br><span class="line"> &lt;&#x2F;Host&gt;    </span><br><span class="line">&lt;&#x2F;Engine&gt;  </span><br><span class="line">&lt;&#x2F;Service&gt;</span><br><span class="line">&lt;&#x2F;Server&gt;</span><br></pre></td></tr></table></figure><p>将E盘中的tomcat端口号修改为8081；只需修改默认文件中的一点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8081&quot; </span><br><span class="line">                   protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;               </span><br><span class="line">                   connectionTimeout&#x3D;&quot;20000&quot;              </span><br><span class="line">                  redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>配置nginx的配置文件：</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-8.png" alt=""></p><p>找到文件中的server节点，然后再上面添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream local_tomcat_test &#123;          </span><br><span class="line">          server localhost:8082 weight&#x3D;8 max_fails&#x3D;3 fail_timeout&#x3D;30s;           </span><br><span class="line">          server localhost:8081 weight&#x3D;2 max_fails&#x3D;3 fail_timeout&#x3D;30s;    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后修改server:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream local_tomcat_test &#123;          </span><br><span class="line">       server localhost:8082 weight&#x3D;8 max_fails&#x3D;3 fail_timeout&#x3D;30s;          </span><br><span class="line">       server localhost:8081 weight&#x3D;2 max_fails&#x3D;3 fail_timeout&#x3D;30s;    </span><br><span class="line"> &#125;      </span><br><span class="line">server &#123;        </span><br><span class="line">      listen       80;        </span><br><span class="line">      server_name  localhost;        </span><br><span class="line">location &#x2F; &#123;            </span><br><span class="line">     proxy_pass http:&#x2F;&#x2F;local_tomcat_test;            </span><br><span class="line">     #root html;           </span><br><span class="line">     #index index.html index.htm       </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>配置完成后，启动两个tomcat，为了区分是哪个tomcat，我把tomcat的默认访问页进行了修改。</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-9.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-10.png" alt=""></p><p>然后我们再地址栏输入localhost,试试效果：</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-11.png" alt=""></p><p>访问了tomcat-8082,刷新一下：</p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/nginx-12.png" alt=""></p><p>可以看到访问了tomcat-8081</p><p>各参数的含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">worker_processes：工作进程个数，可配置多个</span><br><span class="line">worker_connections:单个进程最大连接数</span><br><span class="line">server:每一个server相当于一个代理服务器</span><br><span class="line">lister:监听端口，默认80</span><br><span class="line">server_name:当前服务的域名，可以有多个，用空格分隔(我们是本地所以是localhost)</span><br><span class="line">location：表示匹配的路径，这时配置了&#x2F;表示所有请求都被匹配到这里</span><br><span class="line">index：当没有指定主页时，默认会选择这个指定的文件，可多个，空格分隔</span><br><span class="line">proxy_pass：请求转向自定义的服务器列表</span><br><span class="line">upstream name&#123; &#125;:服务器集群名称</span><br></pre></td></tr></table></figure><p>小结</p><p>nginx作为一个反向代理服务器，能缓存我们项目的静态文件，并实现反向代理与均衡负载，可以有效减少服务器压力，即使项目不大，也可以使用。</p><p>大家另外应该都还发现了个问题，虽然这样请求能分别请求到两个tomcat上，如果是一般不需身份校检的或什么认证的方法尚可，但如果出现这类情况：</p><p>我们在tomcat1上进行了登录，这时用户session当然是存在tomcat1上的，而这时进入个人中心的请求请求到tomcat2上了，这时就会出现问题了。tomcat2会告诉你还未登录，这显然不是我们想看到的。</p><p>这就涉及到session共享了，如何让两个服务器上的session共用。我这里放到下次再说，可能要过个好几天。</p><p>感谢大家支持。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/nginx.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Tools" scheme="http://www.lida1024.top/categories/Dev/Tools/"/>
    
    
      <category term="Nginx" scheme="http://www.lida1024.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>MySql中InnoDB表为什么要建议用自增列做主键</title>
    <link href="http://www.lida1024.top/2020/04/10/MySql%E4%B8%ADInnoDB%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BB%BA%E8%AE%AE%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E5%81%9A%E4%B8%BB%E9%94%AE/"/>
    <id>http://www.lida1024.top/2020/04/10/MySql%E4%B8%ADInnoDB%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BB%BA%E8%AE%AE%E7%94%A8%E8%87%AA%E5%A2%9E%E5%88%97%E5%81%9A%E4%B8%BB%E9%94%AE/</id>
    <published>2020-04-10T05:55:00.000Z</published>
    <updated>2020-04-11T09:10:44.173Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/sql.png" alt=""></p><a id="more"></a><h2 id="InnoDB引擎表的特点"><a href="#InnoDB引擎表的特点" class="headerlink" title="InnoDB引擎表的特点"></a>InnoDB引擎表的特点</h2><h3 id="1、InnoDB引擎表是基于B-树的索引组织表-IOT"><a href="#1、InnoDB引擎表是基于B-树的索引组织表-IOT" class="headerlink" title="1、InnoDB引擎表是基于B+树的索引组织表(IOT)"></a>1、InnoDB引擎表是基于B+树的索引组织表(IOT)</h3><p>关于B+树<br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/mysql-1.png" alt=""></p><p>B+ 树的特点:</p><ul><li>所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的;</li><li>不可能在非叶子结点命中;</li><li>非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层;</li></ul><h3 id="2、主键-PRIMARY-KEY"><a href="#2、主键-PRIMARY-KEY" class="headerlink" title="2、主键(PRIMARY KEY)"></a>2、主键(PRIMARY KEY)</h3><p>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</p><h3 id="3、主索引"><a href="#3、主索引" class="headerlink" title="3、主索引"></a>3、主索引</h3><p>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</p><h3 id="4、自增主键"><a href="#4、自增主键" class="headerlink" title="4、自增主键"></a>4、自增主键</h3><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</p><h3 id="5、非自增主键"><a href="#5、非自增主键" class="headerlink" title="5、非自增主键"></a>5、非自增主键</h3><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的，也就是下面这几种情况的存取效率最高：<br>1、使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致；</p><p>2、该表不指定自增列做主键，同时也没有可以被选为主键的唯一索引(上面的条件)，这时候InnoDB会选择内置的ROWID作为主键，写入顺序和ROWID增长顺序一致；<br>除此以外，如果一个InnoDB表又没有显示主键，又有可以被选择为主键的唯一索引，但该唯一索引可能不是递增关系时(例如字符串、UUID、多字段联合唯一索引的情况)，该表的存取效率就会比较差。</p><p>《高性能MySQL》中的原话<br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/mysql-2.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/mysql-3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/sql.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="DataBase" scheme="http://www.lida1024.top/categories/Dev/DataBase/"/>
    
    
      <category term="Mysql" scheme="http://www.lida1024.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel入门</title>
    <link href="http://www.lida1024.top/2020/04/01/Sentinel%E5%85%A5%E9%97%A8/"/>
    <id>http://www.lida1024.top/2020/04/01/Sentinel%E5%85%A5%E9%97%A8/</id>
    <published>2020-04-01T07:39:00.000Z</published>
    <updated>2020-04-10T02:28:24.252Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/sentinel.png" alt=""></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="Sentinel-是什么？"><a href="#Sentinel-是什么？" class="headerlink" title="Sentinel 是什么？"></a>Sentinel 是什么？</h3><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><h3 id="Sentinel-的历史"><a href="#Sentinel-的历史" class="headerlink" title="Sentinel 的历史"></a>Sentinel 的历史</h3><ul><li>2012 年，Sentinel 诞生，主要功能为入口流量控制。</li><li>2013-2017 年，Sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。Sentinel 也因此积累了大量的流量归整场景以及生产实践。</li><li>2018 年，Sentinel 开源，并持续演进。</li><li>2019 年，Sentinel 朝着多语言扩展的方向不断探索，推出 <a href="https://github.com/alibaba/sentinel-cpp" target="_blank" rel="noopener">C++ 原生版本</a>，同时针对 Service Mesh 场景也推出了 <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-cluster/sentinel-cluster-server-envoy-rls" target="_blank" rel="noopener">Envoy 集群流量控制支持</a>，以解决 Service Mesh 架构下多语言限流的问题。</li><li>2020 年，推出 <a href="https://github.com/alibaba/sentinel-golang" target="_blank" rel="noopener">Sentinel Go 版本</a>，继续朝着云原生方向演进。</li></ul><h3 id="Sentinel-特征"><a href="#Sentinel-特征" class="headerlink" title="Sentinel 特征"></a>Sentinel 特征</h3><ul><li>丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li>完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li>广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li>完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="Sentinel-的主要特性"><a href="#Sentinel-的主要特性" class="headerlink" title="Sentinel 的主要特性"></a>Sentinel 的主要特性</h3><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/Sentinel-1.png" alt=""></p><h3 id="Sentinel-的开源生态"><a href="#Sentinel-的开源生态" class="headerlink" title="Sentinel 的开源生态"></a>Sentinel 的开源生态</h3><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/Sentinel-2.png" alt=""></p><h3 id="Sentinel-分为两个部分"><a href="#Sentinel-分为两个部分" class="headerlink" title="Sentinel 分为两个部分"></a>Sentinel 分为两个部分</h3><ul><li>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li><li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li></ul><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="1-添加pom依赖"><a href="#1-添加pom依赖" class="headerlink" title="1.添加pom依赖"></a>1.添加pom依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 从 Sentinel 1.5.0 开始仅支持 JDK 1.7 或者以上版本。Sentinel 1.5.0 之前的版本最低支持 JDK 1.6。</p></blockquote><h3 id="2-定义资源"><a href="#2-定义资源" class="headerlink" title="2.定义资源"></a>2.定义资源</h3><p>接下来，我们把需要控制流量的代码用 Sentinel API SphU.entry(“HelloWorld”) 和 entry.exit() 包围起来即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; 配置规则.</span><br><span class="line">    initFlowRules();</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        Entry entry &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">    entry &#x3D; SphU.entry(&quot;HelloWorld&quot;);</span><br><span class="line">            &#x2F;*您的业务逻辑 - 开始*&#x2F;</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">            &#x2F;*您的业务逻辑 - 结束*&#x2F;</span><br><span class="line">&#125; catch (BlockException e1) &#123;</span><br><span class="line">            &#x2F;*流控逻辑处理 - 开始*&#x2F;</span><br><span class="line">    System.out.println(&quot;block!&quot;);</span><br><span class="line">            &#x2F;*流控逻辑处理 - 结束*&#x2F;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   if (entry !&#x3D; null) &#123;</span><br><span class="line">       entry.exit();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-定义规则"><a href="#3-定义规则" class="headerlink" title="3.定义规则"></a>3.定义规则</h3><p>接下来，通过规则来指定允许该资源通过的请求次数，例如下面的代码定义了资源 HelloWorld 每秒最多只能通过 20 个请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static void initFlowRules()&#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    FlowRule rule &#x3D; new FlowRule();</span><br><span class="line">    rule.setResource(&quot;HelloWorld&quot;);</span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    &#x2F;&#x2F; Set limit QPS to 20.</span><br><span class="line">    rule.setCount(20);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解支持"><a href="#注解支持" class="headerlink" title="注解支持"></a>注解支持</h2><p>Sentinel 提供了 <code>@SentinelResource</code> 注解用于定义资源，并提供了 AspectJ 的扩展用于自动定义资源、处理 <code>BlockException</code> 等。使用 <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-annotation-aspectj" target="_blank" rel="noopener">Sentinel Annotation AspectJ Extension</a> 的时候需要引入以下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-annotation-aspectj&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;x.y.z&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>将 SentinelResourceAspect 注册为一个 Spring Bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SentinelAspectConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SentinelResourceAspect sentinelResourceAspect() &#123;</span><br><span class="line">        return new SentinelResourceAspect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TestService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对应的 &#96;handleException&#96; 函数需要位于 &#96;ExceptionUtil&#96; 类中，并且必须为 static 函数.</span><br><span class="line">    @SentinelResource(value &#x3D; &quot;test&quot;, blockHandler &#x3D; &quot;handleException&quot;, blockHandlerClass &#x3D; &#123;ExceptionUtil.class&#125;)</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(&quot;Test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 原函数</span><br><span class="line">    @SentinelResource(value &#x3D; &quot;hello&quot;, blockHandler &#x3D; &quot;exceptionHandler&quot;, fallback &#x3D; &quot;helloFallback&quot;)</span><br><span class="line">    public String hello(long s) &#123;</span><br><span class="line">        return String.format(&quot;Hello at %d&quot;, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Fallback 函数，函数签名与原函数一致或加一个 Throwable 类型的参数.</span><br><span class="line">    public String helloFallback(long s) &#123;</span><br><span class="line">        return String.format(&quot;Halooooo %d&quot;, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Block 异常处理函数，参数最后多一个 BlockException，其余与原函数一致.</span><br><span class="line">    public String exceptionHandler(long s, BlockException ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; Do some log here.</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        return &quot;Oops, error occurred at &quot; + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h2><p>新建一个SpringBoot的项目</p><h3 id="1-pom依赖"><a href="#1-pom依赖" class="headerlink" title="1.pom依赖"></a>1.pom依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.example.sentinel&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-demo&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;sentinel-demo&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;sentinel demo&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">        &lt;spring.boot.version&gt;2.2.1.RELEASE&lt;&#x2F;spring.boot.version&gt;</span><br><span class="line">        &lt;sentinel.version&gt;1.7.0&lt;&#x2F;sentinel.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.boot.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.boot.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;spring.boot.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;sentinel-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;sentinel.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;sentinel-annotation-aspectj&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;sentinel.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;sentinel-transport-simple-http&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;sentinel.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><h3 id="2-Controller"><a href="#2-Controller" class="headerlink" title="2.Controller"></a>2.Controller</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">package com.example.sentinel.sentineldemo.controller;</span><br><span class="line"></span><br><span class="line">import com.alibaba.csp.sentinel.Entry;</span><br><span class="line">import com.alibaba.csp.sentinel.SphU;</span><br><span class="line">import com.alibaba.csp.sentinel.annotation.SentinelResource;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line">import com.example.sentinel.sentineldemo.service.TestSentinelService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: Monday</span><br><span class="line"> * @Date: 2020&#x2F;4&#x2F;1 0001 上午 11:44</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;test&quot;)</span><br><span class="line">public class TestSentinelController &#123;</span><br><span class="line"></span><br><span class="line">    private static final String KEY &#x3D; &quot;queryOne&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TestSentinelService testSentinelService;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 代码不加任何限流 熔断</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;getValue_0&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @SentinelResource(&quot;queryZero&quot;)</span><br><span class="line">    public String getValue_0(@RequestParam(&quot;key&quot;) String key) &#123;</span><br><span class="line">        return testSentinelService.getValue_0(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 限流实现方式一: 抛出异常的方式定义资源</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;getValue_1&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String getValue_1(@RequestParam(&quot;key&quot;) String key) &#123;</span><br><span class="line">        Entry entry &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 资源名</span><br><span class="line">        String resourceName &#x3D; KEY;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; entry可以理解成入口登记</span><br><span class="line">            entry &#x3D; SphU.entry(resourceName);</span><br><span class="line">            &#x2F;&#x2F; 被保护的逻辑, 这里为查询接口</span><br><span class="line">            return testSentinelService.getValue_1(key);</span><br><span class="line">        &#125; catch (BlockException blockException) &#123;</span><br><span class="line">            &#x2F;&#x2F; 接口被限流的时候, 会进入到这里</span><br><span class="line">            return &quot;接口限流, 返回空&quot;;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; SphU.entry(xxx) 需要与 entry.exit() 成对出现,否则会导致调用链记录异常</span><br><span class="line">            if (entry !&#x3D; null) &#123;</span><br><span class="line">                entry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 限流实现方式二: 注解定义资源</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(&quot;&#x2F;getValue_2&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String getValue_2(@RequestParam(&quot;key&quot;) String key) &#123;</span><br><span class="line">        String res &#x3D; testSentinelService.getValue_2(key);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Service"><a href="#3-Service" class="headerlink" title="3.Service"></a>3.Service</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">package com.example.sentinel.sentineldemo.service;</span><br><span class="line"></span><br><span class="line">import com.alibaba.csp.sentinel.annotation.SentinelResource;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.RuleConstant;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRule;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.degrade.DegradeRuleManager;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import javax.annotation.PostConstruct;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author: Monday</span><br><span class="line"> * @Date: 2020&#x2F;4&#x2F;1 0001 上午 11:45</span><br><span class="line"> * @Description: 商品查询接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class TestSentinelService &#123;</span><br><span class="line"></span><br><span class="line">    private static final String KEY &#x3D; &quot;queryTwo&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 代码不加任何限流 熔断</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getValue_0(String key) &#123;</span><br><span class="line">        System.out.println(&quot;获取Value:&quot; + key);</span><br><span class="line">        return &quot;return value :&quot; + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 抛出异常的方式定义资源</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getValue_1(String key) &#123;</span><br><span class="line">        System.out.println(&quot;获取Value:&quot; + key);</span><br><span class="line">        return &quot;return value :&quot; + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 注解定义资源</span><br><span class="line">     *</span><br><span class="line">     * @param key</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @SentinelResource(value &#x3D; KEY, blockHandler &#x3D; &quot;blockHandlerMethod&quot;, fallback &#x3D; &quot;queryFallback&quot;)</span><br><span class="line">    public String getValue_2(String key) &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟调用服务出现异常</span><br><span class="line">        if (&quot;0&quot;.equals(key)) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;query value success, &quot; + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String blockHandlerMethod(String key, BlockException e) &#123;</span><br><span class="line">        return &quot;queryValue error, blockHandlerMethod res: &quot; + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String queryFallback(String key, Throwable e) &#123;</span><br><span class="line">        return &quot;queryValue error, return fallback res: &quot; + key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 初始化限流配置</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void initDegradeRule() &#123;</span><br><span class="line">        List&lt;FlowRule&gt; rules &#x3D; new ArrayList&lt;FlowRule&gt;();</span><br><span class="line">        FlowRule rule1 &#x3D; new FlowRule();</span><br><span class="line">        rule1.setResource(KEY);</span><br><span class="line">        &#x2F;&#x2F; QPS控制在2以内</span><br><span class="line">        rule1.setCount(2);</span><br><span class="line">        &#x2F;&#x2F; QPS限流</span><br><span class="line">        rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">        rule1.setLimitApp(&quot;default&quot;);</span><br><span class="line">        rules.add(rule1);</span><br><span class="line">        FlowRuleManager.loadRules(rules);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-控制台"><a href="#4-控制台" class="headerlink" title="4.控制台"></a>4.控制台</h3><h4 id="4-1下载"><a href="#4-1下载" class="headerlink" title="4.1下载"></a>4.1下载</h4><p>从 <a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener">release 页面</a> 下载截止目前为止最新版本的控制台 jar 包<br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/Sentinel-3.png" alt=""></p><blockquote><p>注意：<br>启动 Sentinel 控制台需要 JDK 版本为 1.8 及以上版本<br>  从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的 登录 功能，默认用户名和密码都是 sentinel</p></blockquote><p>用户可以通过如下参数进行配置</p><ul><li><code>-Dsentinel.dashboard.auth.username=sentinel</code> 用于指定控制台的登录用户名为 sentinel</li><li><code>-Dsentinel.dashboard.auth.password=123456</code> 用于指定控制台的登录密码为 123456；如果省略这两个参数，默认用户和密码均为 sentinel</li><li><code>-Dserver.servlet.session.timeout=7200</code> 用于指定 Spring Boot 服务端 session 的过期时间，如 7200 表示 7200 秒；60m 表示 60 分钟，默认为 30 分钟</li></ul><h4 id="4-2启动"><a href="#4-2启动" class="headerlink" title="4.2启动"></a>4.2启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.7.1.jar</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/Sentinel-4.png" alt=""></p><h4 id="4-3登录"><a href="#4-3登录" class="headerlink" title="4.3登录"></a>4.3登录</h4><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/Sentinel-5.png" alt=""><br>可以看到当前控制台中没有任何的应用，因为还没有应用接入。</p><h3 id="5-客户端接入"><a href="#5-客户端接入" class="headerlink" title="5.客户端接入"></a>5.客户端接入</h3><p>启动了控制台模块后，控制台页面都是空的，需要接入客户端。</p><h4 id="5-1导入与控制台通信的jar包"><a href="#5-1导入与控制台通信的jar包" class="headerlink" title="5.1导入与控制台通信的jar包"></a>5.1导入与控制台通信的jar包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-transport-simple-http&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;sentinel.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="5-2-配置应用启动参数"><a href="#5-2-配置应用启动参数" class="headerlink" title="5.2 配置应用启动参数"></a>5.2 配置应用启动参数</h4><p>引入了依赖之后，接着就是在我们的应用中配置 JVM 启动参数，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dproject.name&#x3D;xxx -Dcsp.sentinel.dashboard.server&#x3D;consoleIp:port</span><br></pre></td></tr></table></figure><p>其中的consoleIp和port对应的就是我们部署的 sentinel dashboard 的ip和port，我这里对应的是 127.0.0.1 和 8080，按照实际情况来配置 dashboard 的ip和port就好了，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/Sentinel-6.png" alt=""></p><h4 id="5-3-启动应用"><a href="#5-3-启动应用" class="headerlink" title="5.3 启动应用"></a>5.3 启动应用</h4><p>启动上边的springboot项目</p><h4 id="5-4-测试效果"><a href="#5-4-测试效果" class="headerlink" title="5.4 测试效果"></a>5.4 测试效果</h4><p>本demo中<a href="http://localhost:8083/test/getValue_2?key=kobe接口执行多次，会触发限流操作，这时候再去看控制台：" target="_blank" rel="noopener">http://localhost:8083/test/getValue_2?key=kobe接口执行多次，会触发限流操作，这时候再去看控制台：</a><br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/Sentinel-7.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/Sentinel-8.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/Sentinel-9.png" alt=""></p><p>详细说明请参考 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Falibaba%2FSentinel%2Fwiki" target="_blank" rel="noopener">官方 Sentinel Wiki</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/sentinel.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Frame" scheme="http://www.lida1024.top/categories/Dev/Frame/"/>
    
    
      <category term="微服务" scheme="http://www.lida1024.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Sentinel" scheme="http://www.lida1024.top/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>基于CentOS安装Maven</title>
    <link href="http://www.lida1024.top/2020/03/28/%E5%9F%BA%E4%BA%8ECentOS%E5%AE%89%E8%A3%85Maven/"/>
    <id>http://www.lida1024.top/2020/03/28/%E5%9F%BA%E4%BA%8ECentOS%E5%AE%89%E8%A3%85Maven/</id>
    <published>2020-03-28T07:05:00.000Z</published>
    <updated>2020-04-10T03:38:13.994Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/maven.jpg" alt=""></p><a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="1-通过官网下载"><a href="#1-通过官网下载" class="headerlink" title="1.通过官网下载"></a>1.通过官网下载</h3><p>Maven官网：<a href="http://maven.apache.org/" target="_blank" rel="noopener">http://maven.apache.org/</a></p><p>Maven下载地址：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></p><p>将下载好的包通过ftp上传到服务器。</p><h3 id="2-wget下载"><a href="#2-wget下载" class="headerlink" title="2.wget下载"></a>2.wget下载</h3><p>这里使用了<a href="http://mirrors.hust.edu.cn/" target="_blank" rel="noopener">华中科技大学开源镜像站</a>,网上有很多，自行选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# wget http:&#x2F;&#x2F;mirrors.hust.edu.cn&#x2F;apache&#x2F;maven&#x2F;maven-3&#x2F;3.5.4&#x2F;binaries&#x2F;apache-maven-3.5.4-bin.tar.gz</span><br><span class="line">--2020-03-28 09:04:47--  http:&#x2F;&#x2F;mirrors.hust.edu.cn&#x2F;apache&#x2F;maven&#x2F;maven-3&#x2F;3.5.4&#x2F;binaries&#x2F;apache-maven-3.5.4-bin.tar.gz</span><br><span class="line">正在解析主机 mirrors.hust.edu.cn (mirrors.hust.edu.cn)... 202.114.18.160</span><br><span class="line">正在连接 mirrors.hust.edu.cn (mirrors.hust.edu.cn)|202.114.18.160|:80... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：8842660 (8.4M) [application&#x2F;octet-stream]</span><br><span class="line">正在保存至: “apache-maven-3.5.4-bin.tar.gz”</span><br><span class="line"></span><br><span class="line">100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 8,842,660   5.30MB&#x2F;s 用时 1.6s   </span><br><span class="line"></span><br><span class="line">2020-03-28 09:04:49 (5.30 MB&#x2F;s) - 已保存 “apache-maven-3.5.4-bin.tar.gz” [8842660&#x2F;8842660])</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxf apache-maven-3.5.4-bin.tar.gz</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;etc</span><br><span class="line">ll</span><br><span class="line">vi profile</span><br><span class="line">#按i进入编辑状态</span><br><span class="line">#添加maven的环境变量</span><br><span class="line">export M2_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4</span><br><span class="line">export PATH&#x3D;$PATH:$M2_HOME&#x2F;bin</span><br><span class="line">#编辑完成按Esc退出编辑状态，然后按:wq保存退出。</span><br><span class="line">#保存退出后运行下面的命令使配置生效</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost etc]# mvn -v</span><br><span class="line">Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)</span><br><span class="line">Maven home: &#x2F;usr&#x2F;local&#x2F;apache-maven-3.5.4</span><br><span class="line">Java version: 1.8.0_241, vendor: Oracle Corporation, runtime: &#x2F;usr&#x2F;local&#x2F;jdk1.8.0_241&#x2F;jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;3.10.0-957.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure><p>配置成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/maven.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Tools" scheme="http://www.lida1024.top/categories/Dev/Tools/"/>
    
    
      <category term="Maven" scheme="http://www.lida1024.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建 Git 服务器[Linux版]</title>
    <link href="http://www.lida1024.top/2020/03/27/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA-Git-%E6%9C%8D%E5%8A%A1%E5%99%A8-Linux%E7%89%88/"/>
    <id>http://www.lida1024.top/2020/03/27/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA-Git-%E6%9C%8D%E5%8A%A1%E5%99%A8-Linux%E7%89%88/</id>
    <published>2020-03-27T07:25:00.000Z</published>
    <updated>2020-04-11T08:01:52.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/git.png" alt=""></p><a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>如果未安装wget,则先安装wget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><p>安装完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# yum install wget</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * epel: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">正在解决依赖关系</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 wget.x86_64.0.1.14-18.el7_6.1 将被 安装</span><br><span class="line">--&gt; 解决依赖关系完成</span><br><span class="line"></span><br><span class="line">依赖关系解决</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> Package                                                架构                                                     版本                                                               源                                                      大小</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">正在安装:</span><br><span class="line"> wget                                                   x86_64                                                   1.14-18.el7_6.1                                                    base                                                   547 k</span><br><span class="line"></span><br><span class="line">事务概要</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">安装  1 软件包</span><br><span class="line"></span><br><span class="line">总下载量：547 k</span><br><span class="line">安装大小：2.0 M</span><br><span class="line">Is this ok [y&#x2F;d&#x2F;N]: y</span><br><span class="line">Downloading packages:</span><br><span class="line">wget-1.14-18.el7_6.1.x86_64.rpm                                                                                                                                                                                           | 547 kB  00:00:00     </span><br><span class="line">Running transaction check</span><br><span class="line">Running transaction test</span><br><span class="line">Transaction test succeeded</span><br><span class="line">Running transaction</span><br><span class="line">  正在安装    : wget-1.14-18.el7_6.1.x86_64                                                                                                                                                                                                  1&#x2F;1 </span><br><span class="line">  验证中      : wget-1.14-18.el7_6.1.x86_64                                                                                                                                                                                                  1&#x2F;1 </span><br><span class="line"></span><br><span class="line">已安装:</span><br><span class="line">  wget.x86_64 0:1.14-18.el7_6.1                                                                                                                                                                                                                  </span><br><span class="line"></span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure><p>下载gitblit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;dl.bintray.com&#x2F;gitblit&#x2F;releases&#x2F;gitblit-1.8.0.tar.gz</span><br></pre></td></tr></table></figure><p>下载完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# wget http:&#x2F;&#x2F;dl.bintray.com&#x2F;gitblit&#x2F;releases&#x2F;gitblit-1.8.0.tar.gz</span><br><span class="line">--2020-03-27 11:59:22--  http:&#x2F;&#x2F;dl.bintray.com&#x2F;gitblit&#x2F;releases&#x2F;gitblit-1.8.0.tar.gz</span><br><span class="line">正在解析主机 dl.bintray.com (dl.bintray.com)... 52.41.180.114, 54.191.3.105</span><br><span class="line">正在连接 dl.bintray.com (dl.bintray.com)|52.41.180.114|:80... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 302 </span><br><span class="line">位置：http:&#x2F;&#x2F;d29vzk4ow07wi7.cloudfront.net&#x2F;d23f30c1fe7d28648d682f387f9a16bfd05cd000da418489d00f04e10279776f?response-content-disposition&#x3D;attachment%3Bfilename%3D%22gitblit-1.8.0.tar.gz%22&amp;Policy&#x3D;eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvZDIzZjMwYzFmZTdkMjg2NDhkNjgyZjM4N2Y5YTE2YmZkMDVjZDAwMGRhNDE4NDg5ZDAwZjA0ZTEwMjc5Nzc2Zj9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmdpdGJsaXQtMS44LjAudGFyLmd6JTIyIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNTg1MjgyMjgzfSwiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjAuMC4wLjAvMCJ9fX1dfQ__&amp;Signature&#x3D;kLEsE2~0a-gSiDvvEPDNqjAuOO8ab7-aqqzuZjDm2sRBZGtPmrkGINTxHEJn~-2hGeQkxX61okj5uV2sq92xSnkPXxSuw9WKJvRPYB35HLdXUTEj2aMbNtKV8J-Dq3eSkQEnLWv7SBOAFn07nrHJE8PpuIy0lKC~ulCXnM1WBmOvr6AWjf3Nla0kLpdBV3HtpCTeTgPNwbCSZYHyqrFtaNI~CQCW8aHQVji-wOLYsy~wyrQ0jjywB8r~P-jSCCAzcyFH7OVqMbJuDsFl63Mw7lK4OVU9jHKKZly6M8GcZXIhqBKS-Ddz9CZ9jHhuoPo5kVhn8jxGsbKHkunv1Zs-Fw__&amp;Key-Pair-Id&#x3D;APKAIFKFWOMXM2UMTSFA [跟随至新的 URL]</span><br><span class="line">--2020-03-27 11:59:24--  http:&#x2F;&#x2F;d29vzk4ow07wi7.cloudfront.net&#x2F;d23f30c1fe7d28648d682f387f9a16bfd05cd000da418489d00f04e10279776f?response-content-disposition&#x3D;attachment%3Bfilename%3D%22gitblit-1.8.0.tar.gz%22&amp;Policy&#x3D;eyJTdGF0ZW1lbnQiOiBbeyJSZXNvdXJjZSI6Imh0dHAqOi8vZDI5dnprNG93MDd3aTcuY2xvdWRmcm9udC5uZXQvZDIzZjMwYzFmZTdkMjg2NDhkNjgyZjM4N2Y5YTE2YmZkMDVjZDAwMGRhNDE4NDg5ZDAwZjA0ZTEwMjc5Nzc2Zj9yZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uPWF0dGFjaG1lbnQlM0JmaWxlbmFtZSUzRCUyMmdpdGJsaXQtMS44LjAudGFyLmd6JTIyIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxNTg1MjgyMjgzfSwiSXBBZGRyZXNzIjp7IkFXUzpTb3VyY2VJcCI6IjAuMC4wLjAvMCJ9fX1dfQ__&amp;Signature&#x3D;kLEsE2~0a-gSiDvvEPDNqjAuOO8ab7-aqqzuZjDm2sRBZGtPmrkGINTxHEJn~-2hGeQkxX61okj5uV2sq92xSnkPXxSuw9WKJvRPYB35HLdXUTEj2aMbNtKV8J-Dq3eSkQEnLWv7SBOAFn07nrHJE8PpuIy0lKC~ulCXnM1WBmOvr6AWjf3Nla0kLpdBV3HtpCTeTgPNwbCSZYHyqrFtaNI~CQCW8aHQVji-wOLYsy~wyrQ0jjywB8r~P-jSCCAzcyFH7OVqMbJuDsFl63Mw7lK4OVU9jHKKZly6M8GcZXIhqBKS-Ddz9CZ9jHhuoPo5kVhn8jxGsbKHkunv1Zs-Fw__&amp;Key-Pair-Id&#x3D;APKAIFKFWOMXM2UMTSFA</span><br><span class="line">正在解析主机 d29vzk4ow07wi7.cloudfront.net (d29vzk4ow07wi7.cloudfront.net)... 13.35.127.69, 13.35.127.111, 13.35.127.37, ...</span><br><span class="line">正在连接 d29vzk4ow07wi7.cloudfront.net (d29vzk4ow07wi7.cloudfront.net)|13.35.127.69|:80... 已连接。</span><br><span class="line">已发出 HTTP 请求，正在等待回应... 200 OK</span><br><span class="line">长度：42063149 (40M) [application&#x2F;gzip]</span><br><span class="line">正在保存至: “gitblit-1.8.0.tar.gz”</span><br><span class="line"></span><br><span class="line">100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 42,063,149  3.57MB&#x2F;s 用时 13s    </span><br><span class="line"></span><br><span class="line">2020-03-27 11:59:38 (3.07 MB&#x2F;s) - 已保存 “gitblit-1.8.0.tar.gz” [42063149&#x2F;42063149])</span><br></pre></td></tr></table></figure><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>我的目录放在<code>/usr/local/</code>下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd usr&#x2F;local</span><br><span class="line">tar -xf gitblit-1.8.0.tar.gz</span><br></pre></td></tr></table></figure><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h3 id="1-更改端口配置"><a href="#1-更改端口配置" class="headerlink" title="1.更改端口配置"></a>1.更改端口配置</h3><blockquote><p>cd gitblit-1.8.0<br>ll<br>cd data<br>vi defaults.properties<br>设置修改编辑完成后按ESC 输入:wq 保存退出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# cd gitblit-1.8.0</span><br><span class="line">[root@localhost gitblit-1.8.0]# ll</span><br><span class="line">总用量 3680</span><br><span class="line">-rwxr-xr-x. 1 root root     984 5月  15 2014 add-indexed-branch.sh</span><br><span class="line">-rwxr-xr-x. 1 root root      82 4月  20 2014 authority.sh</span><br><span class="line">drwxr-xr-x. 6 root root     153 3月  27 14:27 data</span><br><span class="line">drwxr-xr-x. 5 root root    4096 3月  27 14:27 docs</span><br><span class="line">drwxr-xr-x. 2 root root    4096 3月  27 14:27 ext</span><br><span class="line">-rw-r--r--. 1 root root 3685177 6月  23 2016 gitblit.jar</span><br><span class="line">-rwxr-xr-x. 1 root root      52 4月  20 2014 gitblit.sh</span><br><span class="line">-rwxr-xr-x. 1 root root      59 4月  20 2014 gitblit-stop.sh</span><br><span class="line">-rwxr-xr-x. 1 root root      87 4月  20 2014 install-service-centos.sh</span><br><span class="line">-rwxr-xr-x. 1 root root    1249 11月 23 2015 install-service-fedora.sh</span><br><span class="line">-rwxr-xr-x. 1 root root      92 4月  20 2014 install-service-ubuntu.sh</span><br><span class="line">-rwxr-xr-x. 1 root root     997 2月  26 2015 java-proxy-config.sh</span><br><span class="line">-rw-r--r--. 1 root root   11556 1月  18 2016 LICENSE</span><br><span class="line">-rwxr-xr-x. 1 root root     599 6月  17 2014 migrate-tickets.sh</span><br><span class="line">-rw-r--r--. 1 root root   12237 1月  18 2016 NOTICE</span><br><span class="line">-rwxr-xr-x. 1 root root     641 6月  17 2014 reindex-tickets.sh</span><br><span class="line">-rwxr-xr-x. 1 root root    1224 2月  26 2015 service-centos.sh</span><br><span class="line">-rwxr-xr-x. 1 root root    1512 5月  15 2014 service-ubuntu.sh</span><br><span class="line">[root@localhost gitblit-1.8.0]# cd data</span><br><span class="line">[root@localhost data]# ll</span><br><span class="line">总用量 88</span><br><span class="line">drwxr-xr-x. 2 root root    70 3月  27 14:27 certs</span><br><span class="line">-rw-r--r--. 1 root root 65818 6月  23 2016 defaults.properties</span><br><span class="line">drwxr-xr-x. 2 root root    25 3月  27 14:27 git</span><br><span class="line">-rw-r--r--. 1 root root   535 6月  23 2016 gitblit.properties</span><br><span class="line">drwxr-xr-x. 2 root root  4096 3月  27 14:27 gitignore</span><br><span class="line">drwxr-xr-x. 2 root root   274 3月  27 14:27 groovy</span><br><span class="line">-rw-r--r--. 1 root root    87 6月  23 2016 projects.conf</span><br><span class="line">-rw-r--r--. 1 root root    74 6月  23 2016 users.conf</span><br><span class="line">[root@localhost data]# vi defaults.properties</span><br></pre></td></tr></table></figure><p>找到<code>server.httpPort</code>，设定http协议的端口号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Standard http port to serve.  &lt;&#x3D; 0 disables this connector.</span><br><span class="line"># On Unix&#x2F;Linux systems, ports &lt; 1024 require root permissions.</span><br><span class="line"># Recommended value: 80 or 8080</span><br><span class="line">#</span><br><span class="line"># SINCE 0.5.0</span><br><span class="line"># RESTART REQUIRED</span><br><span class="line">server.httpPort &#x3D; 7070</span><br></pre></td></tr></table></figure><p>找到<code>server.httpBindInterface</code>，设定服务器的IP地址。这里就设定你的服务器IP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Specify the interface for Jetty to bind the standard connector.</span><br><span class="line"># You may specify an ip or an empty value to bind to all interfaces.</span><br><span class="line"># Specifying localhost will result in Gitblit ONLY listening to requests to</span><br><span class="line"># localhost.</span><br><span class="line">#</span><br><span class="line"># SINCE 0.5.0</span><br><span class="line"># RESTART REQUIRED</span><br><span class="line">server.httpBindInterface &#x3D; 192.168.1.70</span><br></pre></td></tr></table></figure><p>找到<code>server.httpsBindInterface</code>，设定为本机的ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Specify the interface for Jetty to bind the secure connector.</span><br><span class="line"># You may specify an ip or an empty value to bind to all interfaces.</span><br><span class="line"># Specifying localhost will result in Gitblit ONLY listening to requests to</span><br><span class="line"># localhost.</span><br><span class="line">#</span><br><span class="line"># SINCE 0.5.0</span><br><span class="line"># RESTART REQUIRED</span><br><span class="line">server.httpsBindInterface &#x3D; 192.168.1.70</span><br></pre></td></tr></table></figure><p><code>server.httpsPort = 8443</code> 保持默认不用修改</p><h3 id="2-改变路径配置"><a href="#2-改变路径配置" class="headerlink" title="2.改变路径配置"></a>2.改变路径配置</h3><blockquote><p>vi service-centos.sh<br>设置修改编辑完成后按ESC 输入:wq 保存退出</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GITBLIT_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;gitblit-1.8.0</span><br><span class="line">GITBLIT_BASE_FOLDER&#x3D;&#x2F;usr&#x2F;local&#x2F;gitblit-1.8.0&#x2F;data</span><br><span class="line">GITBLIT_HTTP_PORT&#x3D;7070</span><br><span class="line">GITBLIT_HTTPS_PORT&#x3D;8443</span><br><span class="line">GITBLIT_LOG&#x3D;&#x2F;var&#x2F;log&#x2F;gitblit.log</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="1-jar包启动"><a href="#1-jar包启动" class="headerlink" title="1.jar包启动"></a>1.jar包启动</h3><p><code>java  -jar gitblit.jar</code> 即可手动启动gitblit<br>当按ctrl+c或者退出终端时则该进程会关闭，服务也会关闭，因此这里必须要将该jar程序放到后台运行，这里需要对gitblit.sh文件进行修改，<code>vi gitblit.sh</code>修改成如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">java -jar gitblit.jar --baseFolder data &gt;&#x2F;dev&#x2F;null    &amp;</span><br></pre></td></tr></table></figure><h3 id="2-服务启动"><a href="#2-服务启动" class="headerlink" title="2.服务启动"></a>2.服务启动</h3><p>将gitblit添加为服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install-service-centos.sh</span><br><span class="line">service gitblit  start</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>用户名：admin<br>密码：admin<br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/gitblit-6.png" alt="图片.png"></p><h2 id="额外依赖库"><a href="#额外依赖库" class="headerlink" title="额外依赖库"></a>额外依赖库</h2><p>如果需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++ curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class="line">yum install lsof</span><br><span class="line">yum install net-tools</span><br></pre></td></tr></table></figure><blockquote><p>lsof -i:8888 - 查看端口<br>kill -9 pid - 杀死服务</p></blockquote><h2 id="设置防火墙"><a href="#设置防火墙" class="headerlink" title="设置防火墙"></a>设置防火墙</h2><p>如果需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;7070&#x2F;tcp --permanent 开启端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;7071&#x2F;tcp --permanent 开启端口</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8443&#x2F;tcp --permanent 开启端口</span><br><span class="line">firewall-cmd --reload 重启防火墙后生效</span><br></pre></td></tr></table></figure><p>也可以全部开启http和https端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --zone&#x3D;public --add-service&#x3D;http</span><br><span class="line">sudo firewall-cmd --permanent --zone&#x3D;public --add-service&#x3D;https</span><br><span class="line">sudo firewall-cmd --reload</span><br><span class="line">sudo systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/git.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Tools" scheme="http://www.lida1024.top/categories/Dev/Tools/"/>
    
    
      <category term="Git" scheme="http://www.lida1024.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建 Git 服务器[Windows版]</title>
    <link href="http://www.lida1024.top/2020/03/25/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA-Git-%E6%9C%8D%E5%8A%A1%E5%99%A8-Windows%E7%89%88/"/>
    <id>http://www.lida1024.top/2020/03/25/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA-Git-%E6%9C%8D%E5%8A%A1%E5%99%A8-Windows%E7%89%88/</id>
    <published>2020-03-25T05:57:00.000Z</published>
    <updated>2020-04-11T08:02:30.321Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/git.png" alt=""></p><a id="more"></a><h2 id="服务器搭建"><a href="#服务器搭建" class="headerlink" title="服务器搭建"></a>服务器搭建</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li>下载 JDK：<a href="https://www.oracle.com/technetwork/java/javase/downloads/" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/</a></li><li>下载 Gitblit：<a href="http://gitblit.com/" target="_blank" rel="noopener">http://gitblit.com/</a><br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/gitblit-4.png" alt="图片.png"></li></ul><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>解压缩下载的压缩包即可，无需安装。<br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/gitblit-5.png" alt="图片.png"></p><h3 id="创建本地存储文件夹"><a href="#创建本地存储文件夹" class="headerlink" title="创建本地存储文件夹"></a>创建本地存储文件夹</h3><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/gitblit-3.png" alt="图片.png"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>打开data文件夹下的<code>gitblit.properties</code><br>在第17行可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &#x3D; defaults.properties</span><br></pre></td></tr></table></figure><p>同文件夹下找到<code>defaults.properties</code><br>将上边配置的本地存储文件夹的路径复制过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#git.repositoriesFolder &#x3D; $&#123;baseFolder&#125;&#x2F;git</span><br><span class="line">git.repositoriesFolder &#x3D; E:\GitBlit\Repository</span><br></pre></td></tr></table></figure><p>找到server.httpPort，设定http协议的端口号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Standard http port to serve.  &lt;&#x3D; 0 disables this connector.</span><br><span class="line"># On Unix&#x2F;Linux systems, ports &lt; 1024 require root permissions.</span><br><span class="line"># Recommended value: 80 or 8080</span><br><span class="line">#</span><br><span class="line"># SINCE 0.5.0</span><br><span class="line"># RESTART REQUIRED</span><br><span class="line">server.httpPort &#x3D; 1024</span><br></pre></td></tr></table></figure><p>找到server.httpBindInterface，设定服务器的IP地址。这里就设定你的服务器IP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Specify the interface for Jetty to bind the standard connector.</span><br><span class="line"># You may specify an ip or an empty value to bind to all interfaces.</span><br><span class="line"># Specifying localhost will result in Gitblit ONLY listening to requests to</span><br><span class="line"># localhost.</span><br><span class="line">#</span><br><span class="line"># SINCE 0.5.0</span><br><span class="line"># RESTART REQUIRED</span><br><span class="line">server.httpBindInterface &#x3D; localhost</span><br></pre></td></tr></table></figure><p>找到server.httpsBindInterface，设定为localhost</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Specify the interface for Jetty to bind the secure connector.</span><br><span class="line"># You may specify an ip or an empty value to bind to all interfaces.</span><br><span class="line"># Specifying localhost will result in Gitblit ONLY listening to requests to</span><br><span class="line"># localhost.</span><br><span class="line">#</span><br><span class="line"># SINCE 0.5.0</span><br><span class="line"># RESTART REQUIRED</span><br><span class="line">server.httpsBindInterface &#x3D; localhost</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行gitblit.cmd<br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/gitblit-1.png" alt="图片.png"><br>如上图则运行成功<br>在浏览器中打开,现在就可以使用GitBlit了。默认用户名密码都是 admin<br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/gitblit-2.png" alt="图片.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/git.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Tools" scheme="http://www.lida1024.top/categories/Dev/Tools/"/>
    
    
      <category term="Git" scheme="http://www.lida1024.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MD5 到底是不是加密算法？</title>
    <link href="http://www.lida1024.top/2020/03/21/MD5-%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F/"/>
    <id>http://www.lida1024.top/2020/03/21/MD5-%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9F/</id>
    <published>2020-03-21T06:01:00.000Z</published>
    <updated>2020-04-10T06:34:38.457Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/MD5.jpg" alt=""></p><a id="more"></a><p>在回答这个问题之前，我们先分别来了解一下两个知识点：</p><ul><li>什么是 MD5 算法？</li><li>什么是加密算法？</li></ul><h2 id="一、MD5算法"><a href="#一、MD5算法" class="headerlink" title="一、MD5算法"></a>一、MD5算法</h2><p>MD5 即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一，主流编程语言普遍已有 MD5 实现。</p><p>将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5 的前身有 MD2 、MD3 和 MD4 。</p><p>MD5 是输入不定长度信息，输出固定长度 128-bits 的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个 128-bits 散列。</p><p>基本方式为，求余、取余、调整长度、与链接变量进行循环运算，得出结果。</p><p>MD5 计算广泛应用于错误检查。在一些 BitTorrent 下载中，软件通过计算 MD5 来检验下载到的碎片的完整性。</p><h2 id="二、加密算法"><a href="#二、加密算法" class="headerlink" title="二、加密算法"></a>二、加密算法</h2><h3 id="百度百科"><a href="#百度百科" class="headerlink" title="百度百科"></a>百度百科</h3><p>加密，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。</p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>在密码学中，加密（英语：Encryption）是将明文信息改变为难以读取的密文内容，使之不可读的过程。只有拥有解密方法的对象，经由解密过程，才能将密文还原为正常可读的内容。</p><h2 id="三、对比"><a href="#三、对比" class="headerlink" title="三、对比"></a>三、对比</h2><p>也就是说，MD5 算法和加密算法都可以将信息转换为另外一种内容。</p><p>但是，MD5 算法对比 加密算法 缺少了解密过程。</p><p>事实上，使用 加密算法 加密后的消息是完整的，并且基于解密算法后，可以恢复原始数据。</p><p>而 MD5 算法 得到的消息是不完整的，并且通过摘要的数据也无法得到原始数据。</p><p>所以，MD5 算法不是加密算法！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/MD5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="加密解密" scheme="http://www.lida1024.top/tags/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>几个Git仓库开源软件的比较</title>
    <link href="http://www.lida1024.top/2020/03/20/%E5%87%A0%E4%B8%AAGit%E4%BB%93%E5%BA%93%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>http://www.lida1024.top/2020/03/20/%E5%87%A0%E4%B8%AAGit%E4%BB%93%E5%BA%93%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-03-20T06:59:00.000Z</published>
    <updated>2020-04-11T08:04:20.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/git.png" alt=""></p><a id="more"></a><table><thead><tr><th>特性</th><th>gitlab</th><th>gitblit</th><th>gitbucket</th><th>gogs</th><th>gitolite</th></tr></thead><tbody><tr><td>公开库</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>私有库</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>在线编辑</td><td>√</td><td>×</td><td>√</td><td>×</td><td>×</td></tr><tr><td>wiki</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>issue</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>fork</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>pull request</td><td>√</td><td>×</td><td>√</td><td>√</td><td>×</td></tr><tr><td>支持ssh</td><td>√</td><td>√</td><td>×</td><td>√</td><td>？</td></tr><tr><td>邮件通知</td><td>√</td><td>？</td><td>√</td><td>√</td><td>？</td></tr><tr><td>项目统计</td><td>√</td><td>×</td><td>√</td><td>√</td><td>×</td></tr><tr><td>组织管理</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>中文支持</td><td>×</td><td>√</td><td>×</td><td>√</td><td>×</td></tr><tr><td>权限控制</td><td>√</td><td>√</td><td>×</td><td>×</td><td>√</td></tr><tr><td>插件机制</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>系统资源要求</td><td>高</td><td>高</td><td>高</td><td>很低</td><td>低</td></tr><tr><td>方便安装</td><td>巨大不方便</td><td>单文件部署</td><td>单文件部署</td><td>单文件部署</td><td>未知</td></tr><tr><td>开发语言</td><td>ruby</td><td>java</td><td>scala</td><td>go</td><td>perl</td></tr><tr><td>项目历史（年）</td><td>？</td><td>5</td><td>3</td><td>2</td><td>？</td></tr><tr><td>开发者数量</td><td>？</td><td>97</td><td>80</td><td>196</td><td>？</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/git.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Tools" scheme="http://www.lida1024.top/categories/Dev/Tools/"/>
    
    
      <category term="Git" scheme="http://www.lida1024.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>什么是 开发环境、测试环境、生产环境、UAT环境、仿真环境</title>
    <link href="http://www.lida1024.top/2020/03/19/%E4%BB%80%E4%B9%88%E6%98%AF-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%81%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E3%80%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E3%80%81UAT%E7%8E%AF%E5%A2%83%E3%80%81%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.lida1024.top/2020/03/19/%E4%BB%80%E4%B9%88%E6%98%AF-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E3%80%81%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E3%80%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E3%80%81UAT%E7%8E%AF%E5%A2%83%E3%80%81%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2020-03-19T07:00:00.000Z</published>
    <updated>2020-04-10T02:47:12.407Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>开发环境</strong>：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意， 为了开发调试方便，一般打开全部错误报告。</p><p><strong>测试环境</strong>：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。</p><p><strong>生产环境</strong>：是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。可以理解为包含所有的功能的环境，任何项目所使用的环境都以这个为基础，然后根据客户的个性化需求来做调整或者修改。</p><p>三个环境也可以说是系统开发的三个阶段：开发-&gt;测试-&gt;上线，其中生产环境也就是通常说的真实环境。</p><p><strong>UAT环境</strong>：UAT，(User Acceptance Test),用户接受度测试 即验收测试，所以UAT环境主要是用来作为客户体验的环境。</p><p><strong>仿真环境</strong>：顾名思义是和真正使用的环境一样的环境（即已经出售给客户的系统所在环境，也成为商用环境），所有的配置，页面展示等都应该和商家正在使用的一样，差别只在环境的性能方面。</p><p>系统内部<a href="https://www.baidu.com/s?wd=%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLnWnLnAcsmWTvmHKbrHmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHnLnHTznHDL" target="_blank" rel="noopener">集成测试</a>(System Integration Testing) SIT<br>用户<a href="https://www.baidu.com/s?wd=%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLnWnLnAcsmWTvmHKbrHmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHnLnHTznHDL" target="_blank" rel="noopener">验收测试</a>(User Acceptance Testing) UAT<br>SIT在前，UAT在后，UAT测完才可以上线。</p><p>SIT是<a href="https://www.baidu.com/s?wd=%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLnWnLnAcsmWTvmHKbrHmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHnLnHTznHDL" target="_blank" rel="noopener">集成测试</a>UAT是<a href="https://www.baidu.com/s?wd=%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLnWnLnAcsmWTvmHKbrHmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHnLnHTznHDL" target="_blank" rel="noopener">验收测试</a>从时间上看，UAT要在SIT后面，<a href="https://www.baidu.com/s?wd=UAT%E6%B5%8B%E8%AF%95&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLnWnLnAcsmWTvmHKbrHmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHnLnHTznHDL" target="_blank" rel="noopener">UAT测试</a>要在<a href="https://www.baidu.com/s?wd=%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1YLnWnLnAcsmWTvmHKbrHmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPHnLnHTznHDL" target="_blank" rel="noopener">系统测试</a>完成后才开始。从测试人员看，SIT由公司的测试员来测试，而UAT一般是由用户来测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;开发环境&lt;/strong&gt;：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意， 为了开发调试方便，一般打开全部错误报告。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;：一般是克隆一份生产环境的配置，一个
      
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="规范" scheme="http://www.lida1024.top/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis if标签判断数字大小</title>
    <link href="http://www.lida1024.top/2020/03/18/Mybatis%20if%E6%A0%87%E7%AD%BE%E5%88%A4%E6%96%AD%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/"/>
    <id>http://www.lida1024.top/2020/03/18/Mybatis%20if%E6%A0%87%E7%AD%BE%E5%88%A4%E6%96%AD%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/</id>
    <published>2020-03-18T06:01:00.000Z</published>
    <updated>2020-04-10T03:35:22.782Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/mybatis.png" alt=""></p><a id="more"></a><h2 id="if标签语法"><a href="#if标签语法" class="headerlink" title="if标签语法"></a>if标签语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select...&gt;</span><br><span class="line">  SQL语句1</span><br><span class="line">  &lt;if test&#x3D;&quot;条件表达式&quot;&gt;</span><br><span class="line">     SQL语句2</span><br><span class="line">  &lt;&#x2F;if&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h2 id="条件表达式中大于号小于号用-gt-lt"><a href="#条件表达式中大于号小于号用-gt-lt" class="headerlink" title="条件表达式中大于号小于号用 gt,lt"></a>条件表达式中大于号小于号用 gt,lt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;if test&#x3D;&quot;num gt 0&quot;&gt;...&lt;&#x2F;if&gt;</span><br><span class="line"></span><br><span class="line">&lt;if test&#x3D;&quot;num lt 0&quot;&gt;...&lt;&#x2F;if&gt;</span><br></pre></td></tr></table></figure><h2 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ZftjHalf&gt; selectByAreaIdAndYear(@Param(&quot;areaId&quot;) String areaId,</span><br><span class="line">                                     @Param(&quot;year&quot;) String year,</span><br><span class="line">                                     @Param(&quot;level&quot;) int level);</span><br></pre></td></tr></table></figure><p>##xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id&#x3D;&quot;selectByAreaIdAndYear&quot; resultType&#x3D;&quot;com.zftdata.nyzft.entity.ZftjHalf&quot;&gt;</span><br><span class="line">  select * from ZFTJ_HALF</span><br><span class="line">  where FILLING_TIME LIKE CONCAT(#&#123;year&#125;,&#39;%&#39;)</span><br><span class="line">  &lt;if test&#x3D;&quot;level lt 3&quot;&gt;</span><br><span class="line">    and AREA_ID_PID &#x3D;#&#123;areaId&#125;</span><br><span class="line">  &lt;&#x2F;if&gt;</span><br><span class="line">  &lt;if test&#x3D;&quot;level gt 2&quot;&gt;</span><br><span class="line">    and AREA_ID &#x3D;#&#123;areaId&#125;</span><br><span class="line">  &lt;&#x2F;if&gt;</span><br><span class="line">  &lt;if test&#x3D;&quot;level &#x3D;&#x3D; 4&quot;&gt;</span><br><span class="line">    and AREA_ID &#x3D;#&#123;areaId&#125;</span><br><span class="line">  &lt;&#x2F;if&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/mybatis.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="MyBatis" scheme="http://www.lida1024.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Java14新特性：Switch表达式</title>
    <link href="http://www.lida1024.top/2020/03/16/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ASwitch%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.lida1024.top/2020/03/16/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9ASwitch%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-03-16T06:36:00.000Z</published>
    <updated>2020-04-11T00:51:41.132Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png" alt=""></p><a id="more"></a><blockquote><p>Java 14正式发布switch表达式特性。在之前的两个 Java 版本Java12，Java13，switch特性只是预览版。<br>新的switch表达式有助于避免一些bug，因为它的表达和组合方式更容易编写。</p></blockquote><p>switch新的表达式有两个特点：</p><ul><li>支持箭头表达式返回。</li><li>支持yied和return返回值。<h2 id="Java-14之前switch语法"><a href="#Java-14之前switch语法" class="headerlink" title="Java 14之前switch语法"></a>Java 14之前switch语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch (season) &#123;</span><br><span class="line">    case SPRING:</span><br><span class="line">    case AUTUMN:</span><br><span class="line">        System.out.println(&quot;温暖&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case SUMMER:</span><br><span class="line">        System.out.println(&quot;炎热&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case WINTER:</span><br><span class="line">        System.out.println(&quot;寒冷&quot;);</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Java-14-switch表达式"><a href="#Java-14-switch表达式" class="headerlink" title="Java 14 switch表达式"></a>Java 14 switch表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch (season) &#123;</span><br><span class="line">    case SPRING, AUTUMN -&gt; System.out.println(&quot;温暖&quot;);</span><br><span class="line">    case SUMMER         -&gt; System.out.println(&quot;炎热&quot;);</span><br><span class="line">    case WINTER         -&gt; System.out.println(&quot;寒冷&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 14的switch表达式使用箭头表达时，不需要我们在每一个case后都加上break，减少我们出错的机会。</p><h2 id="Java14之前switch语法返回值"><a href="#Java14之前switch语法返回值" class="headerlink" title="Java14之前switch语法返回值"></a>Java14之前switch语法返回值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String temperature &#x3D;&quot;&quot;;</span><br><span class="line">switch (season) &#123;</span><br><span class="line">    case SPRING:</span><br><span class="line">    case AUTUMN:</span><br><span class="line">        temperature  &#x3D; &quot;温暖&quot;;</span><br><span class="line">        break;</span><br><span class="line">    case SUMMER:</span><br><span class="line">        temperature  &#x3D; &quot;炎热&quot;;</span><br><span class="line">        break;</span><br><span class="line">    case WINTER:</span><br><span class="line">        temperature  &#x3D; &quot;寒冷&quot;;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">       temperature  &#x3D; &quot;忽冷忽热&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它不支持返回值，需要通过一个中间变量来返回。</p><h2 id="Java14-switch表达式返回值"><a href="#Java14-switch表达式返回值" class="headerlink" title="Java14 switch表达式返回值"></a>Java14 switch表达式返回值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String temperature &#x3D; switch (season) &#123;</span><br><span class="line">    case SPRING, AUTUMN -&gt; &quot;温暖&quot;;</span><br><span class="line">    case SUMMER         -&gt; &quot;炎热&quot;;</span><br><span class="line">    case WINTER         -&gt; &quot;寒冷&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="java14" scheme="http://www.lida1024.top/tags/java14/"/>
    
  </entry>
  
  <entry>
    <title>Java14新特性：字符串块</title>
    <link href="http://www.lida1024.top/2020/03/15/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9D%97/"/>
    <id>http://www.lida1024.top/2020/03/15/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9D%97/</id>
    <published>2020-03-15T06:04:00.000Z</published>
    <updated>2020-04-11T00:51:34.083Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png" alt=""></p><a id="more"></a><p>java1之前写字符串拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; &quot;&lt;html&gt;&quot; +</span><br><span class="line">               &quot;&lt;header&gt;&quot; +</span><br><span class="line">               &quot;&lt;&#x2F;header&gt;&quot; +</span><br><span class="line">               &quot;&lt;body&gt;&quot; +</span><br><span class="line">               &quot;&lt;div&gt;body&lt;&#x2F;div&gt;&quot; +</span><br><span class="line">               &quot;&lt;&#x2F;body&gt;&quot; +</span><br><span class="line">               &quot;&lt;&#x2F;html&gt;&quot;;</span><br></pre></td></tr></table></figure><p>内容短的时候还算可以，当需要拼接的内容很多的时候就会显得很乱</p><p>java14后，引进了三个引号作为字符串块，类似python中的字符串块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意 &quot;&quot;&quot; 之后必须换行</span><br><span class="line">String str &#x3D; &quot;&quot;&quot;</span><br><span class="line">        &lt;html&gt;</span><br><span class="line">                &lt;header&gt;</span><br><span class="line">                &lt;&#x2F;header&gt;</span><br><span class="line">            &lt;body&gt;</span><br><span class="line">                &lt;div&gt;&quot;body&quot;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;body&gt;</span><br><span class="line">        &lt;&#x2F;html&gt;</span><br><span class="line">        &quot;&quot;&quot;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="java14" scheme="http://www.lida1024.top/tags/java14/"/>
    
  </entry>
  
  <entry>
    <title>Java14新特性：增强 instanceOf 类型推断</title>
    <link href="http://www.lida1024.top/2020/03/14/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%A2%9E%E5%BC%BA-instanceOf-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/"/>
    <id>http://www.lida1024.top/2020/03/14/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%A2%9E%E5%BC%BA-instanceOf-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/</id>
    <published>2020-03-14T00:17:00.000Z</published>
    <updated>2020-04-11T00:51:26.510Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png" alt=""></p><a id="more"></a><blockquote><p>Java中instanceof是用来判断对象的类型是否是目标类型。如果是返回true，不是返回false。</p></blockquote><p>在Java 14之前，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (obj instanceof String) &#123;</span><br><span class="line">    String str &#x3D; (String) obj; </span><br><span class="line">    str.contains(&quot;A&quot;) ;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">     str &#x3D; &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>obj instanceof String已经为true，在后面的代码里，我们还是要清晰的定义一个新变量，并且要做类型强转换。</p><p>Java 14对instanceof引入了模式匹配，修改后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!(obj instanceof String str)) &#123;</span><br><span class="line">     str.contains(&quot;A&quot;) ;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">     str &#x3D; &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了str，就可以在后续代码使用，不在需要显式做类型转换了。</p><p>还能继续加入判断条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (obj instanceof String str &amp;&amp; str.contains(&quot;A&quot;)) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">if (obj instanceof String str || str.contains(&quot;A&quot;)) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="java14" scheme="http://www.lida1024.top/tags/java14/"/>
    
  </entry>
  
  <entry>
    <title>Java14新特性：增强NPE NullPointerException 错误推断</title>
    <link href="http://www.lida1024.top/2020/03/13/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%A2%9E%E5%BC%BANPE-NullPointerException-%E9%94%99%E8%AF%AF%E6%8E%A8%E6%96%AD/"/>
    <id>http://www.lida1024.top/2020/03/13/Java14%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%A2%9E%E5%BC%BANPE-NullPointerException-%E9%94%99%E8%AF%AF%E6%8E%A8%E6%96%AD/</id>
    <published>2020-03-13T00:41:00.000Z</published>
    <updated>2020-04-11T00:51:17.418Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png" alt=""></p><a id="more"></a><blockquote><p>改进 NullPointerExceptions，通过准确描述哪些变量为 null 来提高 JVM 生成的异常的可用性。该提案的作者希望为开发人员和支持人员提供有关程序为何异常终止的有用信息，并通过更清楚地将动态异常与静态程序代码相关联来提高对程序的理解。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name &#x3D; user.getLocation().getCity().getName();</span><br></pre></td></tr></table></figure><p>在Java 14之前，你可能会得到如下的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerExceptionat NullPointerExample.main(NullPointerExample.java:2)</span><br></pre></td></tr></table></figure><p>不幸的是，如果在第2行是一个包含了多个方法调用的赋值语句（如getLocation()和getCity()），那么任何一个都可能会返回null。实际上，变量user也可能是null。因此，无法判断是谁导致了NullPointerException。</p><p>在Java 14中，新的JVM特性可以显示更详细的诊断信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;Location.getCity()&quot; </span><br><span class="line">because the return value of &quot;User.getLocation()&quot; is null at NullPointerExample.main(NullPointerExample.java:2)</span><br></pre></td></tr></table></figure><p>该消息包含两个明确的组成部分：</p><ul><li>后果：<code>Location.getCity()</code>无法被调用</li><li>原因：<code>User.getLocation()</code>的返回值为null</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="java14" scheme="http://www.lida1024.top/tags/java14/"/>
    
  </entry>
  
  <entry>
    <title>Java 中 IO 流</title>
    <link href="http://www.lida1024.top/2020/03/12/Java-%E4%B8%AD-IO-%E6%B5%81/"/>
    <id>http://www.lida1024.top/2020/03/12/Java-%E4%B8%AD-IO-%E6%B5%81/</id>
    <published>2020-03-12T00:52:00.000Z</published>
    <updated>2020-04-11T00:50:34.436Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png" alt=""></p><a id="more"></a><h2 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h2><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：<br><img src="http://q6rnahf7l.bkt.clouddn.com/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.png.jpeg" alt=""></p><p>按操作对象分类结构图：<br><img src="http://q6rnahf7l.bkt.clouddn.com/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.png.jpeg" alt=""></p><h2 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h2><p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h2 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h2><ul><li>BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li>NIO (New I/O): NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="IO" scheme="http://www.lida1024.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>java基础知识汇总(三)</title>
    <link href="http://www.lida1024.top/2020/03/11/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-%E4%B8%89/"/>
    <id>http://www.lida1024.top/2020/03/11/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB-%E4%B8%89/</id>
    <published>2020-03-11T04:12:00.000Z</published>
    <updated>2020-04-11T00:50:51.900Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png" alt=""></p><a id="more"></a><h2 id="21-静态方法和实例方法有何不同"><a href="#21-静态方法和实例方法有何不同" class="headerlink" title="21.静态方法和实例方法有何不同"></a>21.静态方法和实例方法有何不同</h2><ul><li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p></li><li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p></li></ul><h2 id="22-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#22-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="22.对象的相等与指向他们的引用相等,两者有什么不同?"></a>22.对象的相等与指向他们的引用相等,两者有什么不同?</h2><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><h2 id="23-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#23-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="23.在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>23.在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h2><p>帮助子类做初始化工作。</p><h2 id="24-与-equals-重要"><a href="#24-与-equals-重要" class="headerlink" title="24.== 与 equals(重要)"></a>24.== 与 equals(重要)</h2><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; a 为一个引用</span><br><span class="line">        String b &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; b为另一个引用,对象的内容一样</span><br><span class="line">        String aa &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 放在常量池中</span><br><span class="line">        String bb &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 从常量池中查找</span><br><span class="line">        if (aa &#x3D;&#x3D; bb) &#x2F;&#x2F; true</span><br><span class="line">            System.out.println(&quot;aa&#x3D;&#x3D;bb&quot;);</span><br><span class="line">        if (a &#x3D;&#x3D; b) &#x2F;&#x2F; false，非同一对象</span><br><span class="line">            System.out.println(&quot;a&#x3D;&#x3D;b&quot;);</span><br><span class="line">        if (a.equals(b)) &#x2F;&#x2F; true</span><br><span class="line">            System.out.println(&quot;aEQb&quot;);</span><br><span class="line">        if (42 &#x3D;&#x3D; 42.0) &#123; &#x2F;&#x2F; true</span><br><span class="line">            System.out.println(&quot;true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><h2 id="25-hashCode-与-equals-重要"><a href="#25-hashCode-与-equals-重要" class="headerlink" title="25.hashCode 与 equals (重要)"></a>25.hashCode 与 equals (重要)</h2><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”</p><h3 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><p>通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其它情况下没用。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><h3 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h3><ul><li>如果两个对象相等，则 hashcode 一定也是相同的</li><li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li><li>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ul><h2 id="26-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#26-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="26.简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>26.简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h2><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h2 id="27-线程有哪些基本状态"><a href="#27-线程有哪些基本状态" class="headerlink" title="27.线程有哪些基本状态?"></a>27.线程有哪些基本状态?</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。<br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/java-base-3.png" alt="图片.png"><br>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：<br><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/java-base-4.png" alt="图片.png"></p><p>由上图可以看出：</p><p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><blockquote><p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/java-base-5.png" alt="图片.png"></p><p>当线程执行 wait()方法之后，线程进入 WAITING（等待）状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。</p><h2 id="28-关于-final-关键字的一些总结"><a href="#28-关于-final-关键字的一些总结" class="headerlink" title="28.关于 final 关键字的一些总结"></a>28.关于 final 关键字的一些总结</h2><p>final 关键字主要用在三个地方：变量、方法、类。</p><ul><li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li><li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li></ul><h2 id="29-Java-中的异常处理"><a href="#29-Java-中的异常处理" class="headerlink" title="29.Java 中的异常处理"></a>29.Java 中的异常处理</h2><h3 id="Java-异常类层次结构图"><a href="#Java-异常类层次结构图" class="headerlink" title="Java 异常类层次结构图"></a>Java 异常类层次结构图</h3><p><img src="https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/assert/java-base-6.png" alt="图片.png"><br>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><p>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p><p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。</p><p>Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由 Java 虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。</p><p>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</p><h3 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h3><ul><li>public string getMessage():返回异常发生时的简要描述</li><li>public string toString():返回异常发生时的详细信息</li><li>public string getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同</li><li>public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息</li></ul><h3 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h3><ul><li>try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li><li>catch 块： 用于处理 try 捕获到的异常。</li><li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li></ul><p><strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></p><ol><li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li><li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/issues/190</a>。</p><p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int f(int value) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return value * value;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (value &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用 f(2)，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p><h2 id="30-java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#30-java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="30.java 序列化中如果有些字段不想进行序列化，怎么办？"></a>30.java 序列化中如果有些字段不想进行序列化，怎么办？</h2><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p><p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/coder-lida/CDN/img/java.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dev" scheme="http://www.lida1024.top/categories/Dev/"/>
    
      <category term="Java" scheme="http://www.lida1024.top/categories/Dev/Java/"/>
    
    
      <category term="Java基础" scheme="http://www.lida1024.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
