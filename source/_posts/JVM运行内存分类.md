title: JVM运行内存分类
tags:
  - JVM
categories:
  - Dev
  - Java
date: 2020-03-04 20:58:00

---

<!-- more -->

![图片.png](http://q6pznk9ej.bkt.clouddn.com/jvm.png)

## 一、程序计数器

　　java线程私有的，类似于操作系统里的PC计数器，可以看做是当前线程所执行的字节码的行号指示器。

　　如果线程正在执行的是一个java方法，这个计数器记录的正在执行的虚拟机字节码指令的地址。

　　如果正在执行的是native方法，这个计数器值则为空。 undefined

　　此内存区域是唯一一个在java虚拟规范中没有规定任何OutOfMemoryError情况的区域

## 二、虚拟机栈（栈内存）

　　java线程私有，虚拟机栈描述的是java方法执行的内存模型。

　　每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。

　　每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程。

## 三、本地方法栈

　　和java虚拟机栈的作用类似。区别是该区域为JVM提供使用Native方法的服务。

## 四、堆内存

　　所有线程共享的一块区域，垃圾回收器管理的主要区域。

　　目前主要垃圾回收算法都是分代收集算法，所以java堆中还可以细分为：新生代和老年代，再细致一点的还有eden区，from survivor、to survivor，默认情况下是8：1：1的比例。

　　根据java虚拟机规范的规定，java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。

## 五、方法区

　　各个线程共享的一个区域，用于存储虚拟机加载的类信息，常量、静态变量，即时编译器编译后的代码等数据。

　　虽然虚拟机规范中把方法区描述成堆的一个逻辑部分，但是他却有一个别名叫Non-heap 非堆，目的是为了与java堆区分开来。

　　运行时常量池。是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。　　

 

## 直接内存

 　　direct memory，并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。在1.4中新加入的NIO类，引入了一种基于通道Channel与缓冲区Buffer的IO方式，它可以使用native函数库直接分配堆外内存，

然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在java堆和Nativa堆中来回复制数据。

　　本机直接内存的分配不会受到Java堆大小的限制，受到本机总内存的大小限制。配置虚拟机参数时，不要忽略直接内存，防止出现OOM异常。

 

## 比较

　　直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。

　　直接内存IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。

 

## 后续发展

　  JDK7：

　　　　存储在永久代的部分数据转移到了JVM heap或者是Native heap中。

　　JDK8：

　　　　废弃了永久代PermGen，新增Metaspace元数据区

　　　　方法区在Metaspace中了。

　　　　MetaSpace大小默认没有限制，一般根据系统内存的大小，jvm会动态改变此值。

　　　　可以通过jvm参数配置：

　　　  -XX：MetaspaceSize 分配给类元数据空间(以字节计算)的初始大小。MetaspaceSize的值设置的太大会延长垃圾回收时间，垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。

　　　　-XX:MaxMteaspaceSize：分配给类元数据空间的最大值，超过此值就会触发FullGC，此值默认没有限制，但应取决于系统内存的大小，JVM会动态改变此值。

